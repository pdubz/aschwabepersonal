
/*
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!READ ALL COMMENTS BEFORE INSTALLING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                                                                                           
  
				███╗   ███╗██╗███╗   ██╗██╗ ██████╗ ███╗   ██╗    ██████╗ ███████╗██╗███╗   ██╗██████╗ ███████╗██╗  ██╗     ██╗   ██████╗ 
				████╗ ████║██║████╗  ██║██║██╔═══██╗████╗  ██║    ██╔══██╗██╔════╝██║████╗  ██║██╔══██╗██╔════╝╚██╗██╔╝    ███║   ╚════██╗
				██╔████╔██║██║██╔██╗ ██║██║██║   ██║██╔██╗ ██║    ██████╔╝█████╗  ██║██╔██╗ ██║██║  ██║█████╗   ╚███╔╝     ╚██║    █████╔╝
				██║╚██╔╝██║██║██║╚██╗██║██║██║   ██║██║╚██╗██║    ██╔══██╗██╔══╝  ██║██║╚██╗██║██║  ██║██╔══╝   ██╔██╗      ██║   ██╔═══╝ 
				██║ ╚═╝ ██║██║██║ ╚████║██║╚██████╔╝██║ ╚████║    ██║  ██║███████╗██║██║ ╚████║██████╔╝███████╗██╔╝ ██╗     ██║██╗███████╗
				╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝  ╚═╝╚══════╝╚═╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝     ╚═╝╚═╝╚══════╝
                                                                                                                          
                                                                                                                                                                                                                      
														  .....................                                                              
                                                   ...................................                                                       
                                               ...........................................                                                   
                                           ...................................................                                               
                                        .........................................................                                            
                                      ..............................................................                                         
                                   ...................................................................                                       
                                 .......................................................................                                     
                               ...........................................................................                                   
                              ............,,,:1OGGGf:....................................................,..                                 
                            ..........tGBBBBBBBBBBBBBBB;..........................................,,.......,.                                
                           ........;GBBBBBBBBBBBBBBBBBBBBBBGGGB1:,...............,,......,....,..,.,.,,,,.,,,,                               
                          .......iGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,...,...,,.,,,.,,....,...,,,,,,,,,,,,,,,,,,.                             
                         ......:BBBBBBBBBBBBBBBBBBBBBBBBBG1BBBBBBBBBBt..,,.,,,.,iOBOOOOOOtBOOOOOi,,,,,,,,,,,,,,,.                            
                        ..,...OBBBBBBBBBBBBBBBBBBBBBBBBBBBiOBBBBBBBBBBf.,,,,,tOOOOOOOOOOitOOOOOOOOOt,,,,,,,,,,,,,.                           
                       ..,..;GBBBBBBBBBBBBBBBBO1;;tOBBBBBB,tBBBBBBBBBBBt.,,:f1BOOOOOOOO1,OOOOOOOOOOOOf.,,,,,,,,,,,                           
                      ..,;OBBBBBBBBBBBBBBBB;.,,,,,,,,.1Gt.,::;BBBBBBBBBBt,:1OOOOOOOOOOB.:OOOOOOOOOOiOOO,,,,,,,,,,,,                          
                     .,,,,..1BBBBBBBBBBBO.,,,,,,,,,,,,,,,,,,,,,1BBBBBBBBO,fOOOOOOOOti;;,,,,,fOOOOOOO1tOf,,,,,,,,,,,.                         
                     ,,,,,,tBBBBBBBBBBG:,,,,,,,,,,,,,,,,,,,,,,,.BBBBBBBB1fOOOOO:,,,,,,,,,,,,,,:OOOOOOttO:,,,,,,,,,,,                         
                    .,,,,,:GBBBBBBBBB:,,,,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBGiOOOO:,,,,,,,,,,,,,,,,,,iOOOOOiO;,,,,,,,,,,,,                        
                    ,,,,,,.GBBBBBBB1,,,,,,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBtfOOO,,,,,,,,,,,,,,,,,,,,,;OOOOO;;,,,,,,,,,,,,                        
                    ,,,,,,iBBB1BBBB,,,,Gf,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBiOOB,,,,,,,,,,,,,,,,,,,,,,,1OOOOi,,,,,,,,,,,,,.                       
                   .,,,,,iBBBG:,fBB,,,OBBBBG1.,,,,,,,,,,,,,,,,,,1BBBBBB;tO1,,,,,,,,,,,,,,,,,,,,,,,,BOOO1,,,,,,,,,,,,,.                       
                   .,,,,,.OBBG.,,1B:,;BBB;fGGBBGO,,,,,,,,,,,,,,,iBBBBBB;;B:,,,,,,,,,,,,,,,,,,,,,OO:OOOB1,,,,,,,,,,,,,,                       
                   .,,,:;OGBBG;,,.t,,;BBB:,,,,.OBBBt,,,,,,,,,,,,OBBBBBBf,1:,,,,,,,,,,,,,fBBOOOOOO1,tO,,,,,,,,,,,,,,,,,                       
                   .,,,,,,,;BG;,,,,,,,tBBBB:,,,,tBBBBBBBBBBGBt;tBBBBO,,,,,1OOOBOOOOOOBOOOi,,,iOO;,,1:,,,,,,,,,,,,,,,,,                       
                   .,,,,,,,,,,,,,,,,,,,,BBBBBBBBBt,,;BB:,,,,OBBBBBG;,,,,,,,,fOO:,,,iO,,fOOOOOB;,,,,,,,:OOO:,,,,,,,,,,,                       
                   .,,,,,,,,,,,,,,,,,,,,,,,,ift,,,,,,BBO,,,,:BBGi,,,,,,,,,,,,,:OOOOO,,,,,,,,,,,,,,,,,,:OOOOf,,,,,,,,,.                       
                    ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,iBBBBBBBO,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:OOOOf,,,,,,,,.                       
                    ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:i;:,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,fOOOOi,,,,,,,                        
                    .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:OOOOO1,,,,,:.                        
                     ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,OOOOOO1,:,::,                         
                      ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:,tOOOOOOO:::,,:.                         
                      .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:,,,:OOOOOOOOO1,::::,                          
                       ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,::::::::,,::OOOOOOOOOOtt,:,::,                           
                        ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:::::::::::::::::,:,:OOOOOOOOOOOBii:::::,                            
                         ,:,,,,,,,,,,,,,,,,,,:::,,,,,,,,::::::::::::::::::::::::::::::::::fOOOOOOOOOOOOti::::::,                             
                          ,:,,,,,,,,,,,,,::::::::::::::::::::::::::::::::::::::::::::::iOOOOOOOOOOOOOO::::::::,                              
                           .:::::::::::::::::::::::::::::::::::::::::::::::::::::::::;O;OOOOOOOOOOOf:::::::::,                               
                             ,::::::::::::::::::::::::::::::::::::::::::::::::::::::t:OOOOOOOOOOO1::::::::::                                 
                              .:::::::::::::::::::::::::::::::::::::::::::::::::::::;OOOOOOOOO1:::::::::::,                                  
                                ,:::::::::::::::::::::::::::::::::::::::::::::::::::BOOOOfi:::::::::::::,                                    
                                  ,::::::::::::::::::::::::::::::::::::::::::::::::fOOt::::::::::::::::                                      
                                    ,:::::::::::::::::::::::::::::::::::::::::::::;Of:::::::::::::::,                                        
                                      .:::::::::::::::::::::::::::::::::::::::::::11::::::::::::::.                                          
                                         .::::::::::::::::::::::::::::::::::::::::i::::::::::::,                                             
                                            .:::::::::::::::::::::::::::::::::::::::::::::::.                                                
                                                .,:::::::::::::::::::::::::::::::::::::,.                                                    
                                                     .,:::::::::::::::::::::::::::,.                                                         
                                                             ...,,,,,,,,,...                                                                 
 '
                                                        
 


								  ____                                        __              __           __           
								/ __ \   _____  ___    _____  ___    ____   / /_  ___   ____/ /          / /_    __  __
							   / /_/ /  / ___/ / _ \  / ___/ / _ \  / __ \ / __/ / _ \ / __  /          / __ \  / / / /
							  / ____/  / /    /  __/ (__  ) /  __/ / / / // /_  /  __// /_/ /          / /_/ / / /_/ / 
							 /_/      /_/     \___/ /____/  \___/ /_/ /_/ \__/  \___/ \__,_/          /_.___/  \__, /  
																											  /____/   


    __  __   _       _           _           _       _     _____    ____             
   |  \/  | (_)     | |         (_)         | |     | |   |  __ \  |  _ \      /\    
   | \  / |  _    __| |  _ __    _    __ _  | |__   | |_  | |  | | | |_) |    /  \   
   | |\/| | | |  / _` | | '_ \  | |  / _` | | '_ \  | __| | |  | | |  _ <    / /\ \  
   | |  | | | | | (_| | | | | | | | | (_| | | | | | | |_  | |__| | | |_) |  / ____ \ 
   |_|  |_| |_|  \__,_| |_| |_| |_|  \__, | |_| |_|  \__| |_____/  |____/  /_/    \_\
                                      __/ |                                          
															_                                                                                                                                  
														   | |                                                                                                                                 
										 __ _   _ __     __| |                                                                                                                                 
										/ _` | | '_ \   / _` |                                                                                                                                 
									   | (_| | | | | | | (_| |                                                                                                                                 
										\__,_| |_| |_|  \__,_|                                                                                                                                 
                                                                                                                                                                                                                                                                                                                     
    __  __   _       _           _           _       _      _____    ____    _           _____                                 _   _     _                 
   |  \/  | (_)     | |         (_)         | |     | |    / ____|  / __ \  | |         / ____|                               | | | |   (_)                
   | \  / |  _    __| |  _ __    _    __ _  | |__   | |_  | (___   | |  | | | |        | |        ___    _ __    ___   _   _  | | | |_   _   _ __     __ _ 
   | |\/| | | |  / _` | | '_ \  | |  / _` | | '_ \  | __|  \___ \  | |  | | | |        | |       / _ \  | '_ \  / __| | | | | | | | __| | | | '_ \   / _` |
   | |  | | | | | (_| | | | | | | | | (_| | | | | | | |_   ____) | | |__| | | |____    | |____  | (_) | | | | | \__ \ | |_| | | | | |_  | | | | | | | (_| |
   |_|  |_| |_|  \__,_| |_| |_| |_|  \__, | |_| |_|  \__| |_____/   \___\_\ |______|    \_____|  \___/  |_| |_| |___/  \__,_| |_|  \__| |_| |_| |_|  \__, |
                                      __/ |                                                                                                           __/ |
                                     |___/                                                                                                           |___/                                     |___/                                           

!!!!!!!!!!!!!!!!!!!!!!!

This installer turns on xp_cmdshell.  It is recommended that you take the proper steps to lock down xp_cmdshell so that only SQLADMINS have access to it.
For a full discussion on why xp_cmdshell doesn't pose any extra security risks to your system, see the following blog post:
http://www.midnightdba.com/DBARant/?p=1243

!!!!!!!!!!!!!!!!!!!!!!!

Once you run this installer there is nothing left to do.  All objects and metadata required are created and 
there are 2 jobs installed.
dba_MinionReindexDBs-All-All
dba_MinionReindexDBs-All-REORG

****The jobs assume you've run the script in master.  If that is not the case then just change the DB the jobs point to.******

The naming convention is as follows:
All-All = both Offline and Online indexes AND both REORG and REBUILD operations.
All-REORG = both Offline and Online indexes and only REORG will be used.

So in other words, Do REBUILDs ops once a wk, and REORGs every day. 
Change the schedules as they suite you.

See documentation for full explanation of everything you need to know to fully take advantage of all the features.
Also, check out our feature videos.

* By running this software you are agreeing to the terms of the license agreement.
* You can find a copy of the license agreement here: http://www.midnightsql.com/minion-end-user-license-agreement/

		HISTORY:

Version 1.2 Fixlist:
	• MR failed when running on mixed collations.
	• Help doesn’t install if Minion Backup is installed.
	• MR not handling XML and reorg properly.
	• ONLINE/OFFLINE modes not being handled properly.
	• XML indexes being put into ONLINE mode instead of OFFLINE mode.
	• Added a check for XML indexes when updating statistics.
	• Situation where indexes could be processed more than once.
	• Increased Status column in log tables to varchar(max).
	• Status variable in SPs has different sizes.
	• Wrong syntax created for Wait_at_low_priority option.

Version 1.2 New Features:
(See documentation for full details)
	• Statement Prefix - Add code to run before reindex in the same SPID context as the reindex stmt.
	• Statement Suffix - Add code to run after reindex in the same SPID context as the reindex stmt.


Version 1.1 Fixlist
• Fixed issues with nonstandard naming (e.g., object names with spaces or special characters.)
• Added support for Availability Group replicas.  Basic AG support has been added by only permitting Minion Reindex to run on an AG Primary DB.

Known issues with current installer:
1. If you install MR1.2 and then install MB1.0, the MR embedded docs will read "Minion Reindex 1.1" instead of "Minion Reindex 1.2".
   To prevent this, either install MB1.0 first, or install MB1.1.  If you don't have MB1.1 though, and you've already installed MR1.2,
   then you can simply run this installer again after you install MB1.0 and it will upgrade the MR1.2 help to what it should be.

*/
USE dba;
GO

SELECT	DB_NAME() AS dbname
INTO	#dbname; 

SET NOCOUNT ON;

USE master;
GO

EXEC sp_configure 'show', 1
GO
RECONFIGURE
go

EXEC sp_configure 'xp_cmdshell', 1
GO
RECONFIGURE
go

EXEC sp_configure 'show', 0
GO
RECONFIGURE
go

USE dba;
GO

IF SCHEMA_ID('Minion') IS NULL 
	BEGIN
		EXEC ('CREATE SCHEMA Minion')
	END


/****** Object:  Table [Minion].[IndexTableFrag]     ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

----------------BEGIN IndexTableFrag----------------------
IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexTableFrag' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexTableFrag](
	[ExecutionDateTime] [datetime] NOT NULL,
	[DBName] VARCHAR(400) NOT NULL,
	[DBID] [int] NOT NULL,
	[TableID] [bigint] NOT NULL,
	[SchemaName] VARCHAR(400) NOT NULL,
	[TableName] VARCHAR(400) NOT NULL,
	[IndexName] VARCHAR(400) NOT NULL,
	[IndexID] [bigint] NOT NULL,
	[IndexType] [tinyint] NULL,
	[IndexTypeDesc] [nvarchar](120) NULL,
	[IsDisabled] [bit] NULL,
	[IsHypothetical] [bit] NULL,
	[avg_fragmentation_in_percent] [float] NULL,
	[ReorgThreshold] [tinyint] NULL,
	[RebuildThreshold] [tinyint] NULL,
	[FILLFACTORopt] [tinyint] NULL,
	[PadIndex] [varchar](3) NULL,
	[ONLINEopt] [varchar](3) NULL,
	[SortInTempDB] [varchar](3) NULL,
	[MAXDOPopt] [tinyint] NULL,
	[DataCompression] [varchar](50) NULL,
	[GetRowCT] [bit] NULL,
	[GetPostFragLevel] [bit] NULL,
	[UpdateStatsOnDefrag] [bit] NULL,
	[StatScanOption] [varchar](25) NULL,
	[IgnoreDupKey] [varchar](3) NULL,
	[StatsNoRecompute] [varchar](3) NULL,
	[AllowRowLocks] [varchar](3) NULL,
	[AllowPageLocks] [varchar](3) NULL,
	[WaitAtLowPriority] [bit] NULL,
	[MaxDurationInMins] [int] NULL,
	[AbortAfterWait] [varchar](20) NULL,
	[LogProgress] [bit] NULL,
	[LogRetDays] [smallint] NULL,
	[PushToMinion] [bit] NULL,
	[LogIndexPhysicalStats] [bit] NULL,
	[IndexScanMode] [varchar](25) NULL,
	[TablePreCode] [nvarchar](max) NULL,
	[TablePostCode] [nvarchar](max) NULL,
	[Prepped] [bit] NULL,
	[ReindexGroupOrder] [int] NULL,
	[ReindexOrder] [int] NULL
 CONSTRAINT [PK_IndexTableFrag] PRIMARY KEY CLUSTERED 
(
	[ExecutionDateTime] ASC,
	[DBName] ASC,
	[TableID] ASC,
	[IndexID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END

IF NOT EXISTS(SELECT 1
          FROM   INFORMATION_SCHEMA.COLUMNS
          WHERE  
		  TABLE_SCHEMA = 'Minion'
		  AND TABLE_NAME = 'IndexTableFrag'
                 AND COLUMN_NAME = 'StmtPrefix')
BEGIN
	ALTER TABLE Minion.IndexTableFrag
	ADD StmtPrefix NVARCHAR(500),
		StmtSuffix NVARCHAR(500)
END

ALTER TABLE [Minion].[IndexTableFrag] DROP CONSTRAINT [PK_IndexTableFrag]
GO

BEGIN
	ALTER TABLE Minion.IndexTableFrag
	alter column
	[DBName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexTableFrag
	alter column
	[SchemaName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexTableFrag
	alter column
	[TableName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexTableFrag
	alter column
	[IndexName] VARCHAR(400) NOT NULL
END

ALTER TABLE [Minion].[IndexTableFrag] ADD  CONSTRAINT [PK_IndexTableFrag] PRIMARY KEY CLUSTERED 
(
	[ExecutionDateTime] ASC,
	[DBName] ASC,
	[TableID] ASC,
	[IndexID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON)
GO

IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id('Minion.IndexTableFrag') AND name ='nonExecDateDBName')
BEGIN
	CREATE NONCLUSTERED INDEX nonExecDateDBName ON Minion.IndexTableFrag (ExecutionDateTime)
	INCLUDE(DBName, SchemaName, TableName)
	WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)
END
GO
----------------END IndexTableFrag------------------------


----------------BEGIN IndexSettingsTable----------------------
IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexSettingsTable' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexSettingsTable](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[DBName] VARCHAR(400) NOT NULL,
	[SchemaName] [varchar](100) NOT NULL,
	[TableName] VARCHAR(400) NOT NULL,
	[Exclude] [bit] NULL,
	[ReindexGroupOrder] [int] NULL,
	[ReindexOrder] [int] NULL,
	[ReorgThreshold] [tinyint] NULL,
	[RebuildThreshold] [tinyint] NULL,
	[FILLFACTORopt] [tinyint] NULL,
	[PadIndex] [varchar](3) NULL,
	[ONLINEopt] [varchar](3) NULL,
	[SortInTempDB] [varchar](3) NULL,
	[MAXDOPopt] [tinyint] NULL,
	[DataCompression] [varchar](50) NULL,
	[GetRowCT] [bit] NULL,
	[GetPostFragLevel] [bit] NULL,
	[UpdateStatsOnDefrag] [bit] NULL,
	[StatScanOption] [varchar](25) NULL,
	[IgnoreDupKey] [varchar](3) NULL,
	[StatsNoRecompute] [varchar](3) NULL,
	[AllowRowLocks] [varchar](3) NULL,
	[AllowPageLocks] [varchar](3) NULL,
	[WaitAtLowPriority] [bit] NULL,
	[MaxDurationInMins] [int] NULL,
	[AbortAfterWait] [varchar](20) NULL,
	[PushToMinion] [bit] NULL,
	[LogIndexPhysicalStats] [bit] NULL,
	[IndexScanMode] [varchar](25) NULL,
	[TablePreCode] [varchar](max) NULL,
	[TablePostCode] [varchar](max) NULL,
	[LogProgress] [bit] NULL,
	[LogRetDays] [smallint] NULL,
	[PartitionReindex] [bit] NULL,
	[isLOB] [bit] NULL,
	[TableType] [char](1) NULL,
	[IncludeUsageDetails] [bit] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [Minion].[IndexSettingsTable]  WITH CHECK ADD  CONSTRAINT [ckRbuildGTReorgTable] CHECK  (([RebuildThreshold]>[ReorgThreshold]))

ALTER TABLE [Minion].[IndexSettingsTable] CHECK CONSTRAINT [ckRbuildGTReorgTable]
END

IF NOT EXISTS(SELECT 1
          FROM   INFORMATION_SCHEMA.COLUMNS
          WHERE  
		  TABLE_SCHEMA = 'Minion'
		  AND TABLE_NAME = 'IndexSettingsTable'
                 AND COLUMN_NAME = 'StmtPrefix')
BEGIN
	ALTER TABLE Minion.IndexSettingsTable
	ADD StmtPrefix NVARCHAR(500),
		StmtSuffix NVARCHAR(500)
END
----This is being altered as part of 1.2 upgrade.  The sysname can't be relied on for an accurate data type.
BEGIN
	ALTER TABLE Minion.IndexSettingsTable
	alter column
	[DBName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexSettingsTable
	alter column
	[SchemaName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexSettingsTable
	alter column
	[TableName] VARCHAR(400) NOT NULL
END
----------------END IndexSettingsTable------------------------



--------------------------------------------------BEGIN IndexSettingsDB-------------------------------------------------------------
IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexSettingsDB' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexSettingsDB](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[DBName] VARCHAR(400) NOT NULL,
	[Exclude] [bit] NULL,
	[ReindexGroupOrder] [tinyint] NULL,
	[ReindexOrder] [int] NULL,
	[ReorgThreshold] [tinyint] NULL,
	[RebuildThreshold] [tinyint] NULL,
	[FILLFACTORopt] [tinyint] NULL,
	[PadIndex] [varchar](3) NULL,
	[ONLINEopt] [varchar](3) NULL,
	[SortInTempDB] [varchar](3) NULL,
	[MAXDOPopt] [tinyint] NULL,
	[DataCompression] [varchar](50) NULL,
	[GetRowCT] [bit] NULL,
	[GetPostFragLevel] [bit] NULL,
	[UpdateStatsOnDefrag] [bit] NULL,
	[StatScanOption] [varchar](25) NULL,
	[IgnoreDupKey] [varchar](3) NULL,
	[StatsNoRecompute] [varchar](3) NULL,
	[AllowRowLocks] [varchar](3) NULL,
	[AllowPageLocks] [varchar](3) NULL,
	[WaitAtLowPriority] [bit] NULL,
	[MaxDurationInMins] [int] NULL,
	[AbortAfterWait] [varchar](20) NULL,
	[PushToMinion] [bit] NULL,
	[LogIndexPhysicalStats] [bit] NULL,
	[IndexScanMode] [varchar](25) NULL,
	[DBPreCode] [nvarchar](max) NULL,
	[DBPostCode] [nvarchar](max) NULL,
	[TablePreCode] [nvarchar](max) NULL,
	[TablePostCode] [nvarchar](max) NULL,
	[LogProgress] [bit] NULL,
	[LogRetDays] [smallint] NULL,
	[LogLoc] [varchar](25) NULL,
	[MinionTriggerPath] [varchar](1000) NULL,
	[RecoveryModel] [varchar](12) NULL,
	[IncludeUsageDetails] [bit] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

ALTER TABLE [Minion].[IndexSettingsDB]  WITH CHECK ADD  CONSTRAINT [ckRebuildGTReorg] CHECK  (([RebuildThreshold]>[ReorgThreshold]))

ALTER TABLE [Minion].[IndexSettingsDB] CHECK CONSTRAINT [ckRebuildGTReorg]

END

BEGIN
	ALTER TABLE Minion.IndexSettingsDB
	alter column
	[DBName] VARCHAR(400) NOT NULL
END

--------------------BEGIN Column Add----------------------
--We're inserting the Port col into the middle of the table
--so we have to drop/create it.
BEGIN TRANSACTION
SET QUOTED_IDENTIFIER ON
SET ARITHABORT ON
SET NUMERIC_ROUNDABORT OFF
SET CONCAT_NULL_YIELDS_NULL ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
COMMIT
BEGIN TRANSACTION
GO
CREATE TABLE Minion.Tmp_IndexSettingsDB
	(
	ID int NOT NULL IDENTITY (1, 1),
	DBName VARCHAR(400) NOT NULL,
	Port int NULL,
	Exclude bit NULL,
	ReindexGroupOrder tinyint NULL,
	ReindexOrder int NULL,
	ReorgThreshold tinyint NULL,
	RebuildThreshold tinyint NULL,
	FILLFACTORopt tinyint NULL,
	PadIndex varchar(3) NULL,
	ONLINEopt varchar(3) NULL,
	SortInTempDB varchar(3) NULL,
	MAXDOPopt tinyint NULL,
	DataCompression varchar(50) NULL,
	GetRowCT bit NULL,
	GetPostFragLevel bit NULL,
	UpdateStatsOnDefrag bit NULL,
	StatScanOption varchar(25) NULL,
	IgnoreDupKey varchar(3) NULL,
	StatsNoRecompute varchar(3) NULL,
	AllowRowLocks varchar(3) NULL,
	AllowPageLocks varchar(3) NULL,
	WaitAtLowPriority bit NULL,
	MaxDurationInMins int NULL,
	AbortAfterWait varchar(20) NULL,
	PushToMinion bit NULL,
	LogIndexPhysicalStats bit NULL,
	IndexScanMode varchar(25) NULL,
	DBPreCode nvarchar(MAX) NULL,
	DBPostCode nvarchar(MAX) NULL,
	TablePreCode nvarchar(MAX) NULL,
	TablePostCode nvarchar(MAX) NULL,
	LogProgress bit NULL,
	LogRetDays smallint NULL,
	LogLoc varchar(25) NULL,
	MinionTriggerPath varchar(1000) NULL,
	RecoveryModel varchar(12) NULL,
	IncludeUsageDetails bit NULL
	)  ON [PRIMARY]
	 TEXTIMAGE_ON [PRIMARY]
GO
ALTER TABLE Minion.Tmp_IndexSettingsDB SET (LOCK_ESCALATION = TABLE)
GO
SET IDENTITY_INSERT Minion.Tmp_IndexSettingsDB ON
GO
IF EXISTS(SELECT * FROM Minion.IndexSettingsDB)
	 EXEC('INSERT INTO Minion.Tmp_IndexSettingsDB (ID, DBName, Exclude, ReindexGroupOrder, ReindexOrder, ReorgThreshold, RebuildThreshold, FILLFACTORopt, PadIndex, ONLINEopt, SortInTempDB, MAXDOPopt, DataCompression, GetRowCT, GetPostFragLevel, UpdateStatsOnDefrag, StatScanOption, IgnoreDupKey, StatsNoRecompute, AllowRowLocks, AllowPageLocks, WaitAtLowPriority, MaxDurationInMins, AbortAfterWait, PushToMinion, LogIndexPhysicalStats, IndexScanMode, DBPreCode, DBPostCode, TablePreCode, TablePostCode, LogProgress, LogRetDays, LogLoc, MinionTriggerPath, RecoveryModel, IncludeUsageDetails)
		SELECT ID, DBName, Exclude, ReindexGroupOrder, ReindexOrder, ReorgThreshold, RebuildThreshold, FILLFACTORopt, PadIndex, ONLINEopt, SortInTempDB, MAXDOPopt, DataCompression, GetRowCT, GetPostFragLevel, UpdateStatsOnDefrag, StatScanOption, IgnoreDupKey, StatsNoRecompute, AllowRowLocks, AllowPageLocks, WaitAtLowPriority, MaxDurationInMins, AbortAfterWait, PushToMinion, LogIndexPhysicalStats, IndexScanMode, DBPreCode, DBPostCode, TablePreCode, TablePostCode, LogProgress, LogRetDays, LogLoc, MinionTriggerPath, RecoveryModel, IncludeUsageDetails FROM Minion.IndexSettingsDB WITH (HOLDLOCK TABLOCKX)')
GO
SET IDENTITY_INSERT Minion.Tmp_IndexSettingsDB OFF
GO
DROP TABLE Minion.IndexSettingsDB
GO
EXECUTE sp_rename N'Minion.Tmp_IndexSettingsDB', N'IndexSettingsDB', 'OBJECT' 
GO
ALTER TABLE Minion.IndexSettingsDB ADD CONSTRAINT
	ckRebuildGTReorg CHECK (([RebuildThreshold]>[ReorgThreshold]))
GO
COMMIT
--------------------END Column Add------------------------

IF NOT EXISTS(SELECT 1
          FROM   INFORMATION_SCHEMA.COLUMNS
          WHERE  
		  TABLE_SCHEMA = 'Minion'
		  AND TABLE_NAME = 'IndexSettingsDB'
                 AND COLUMN_NAME = 'StmtPrefix')
BEGIN
	ALTER TABLE Minion.IndexSettingsDB
	ADD StmtPrefix NVARCHAR(500),
		StmtSuffix NVARCHAR(500)
END

--------------------------------------------------END IndexSettingsDB---------------------------------------------------------------

IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexPhysicalStats' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexPhysicalStats](
	[ExecutionDateTime] [datetime] NULL,
	[IndexScanMode] [varchar](25) NULL,
	[DBName] [varchar](400) NULL,
	[SchemaName] [varchar](400) NULL,
	[TableName] [varchar](400) NULL,
	[IndexName] [varchar](400) NULL,
	[database_id] [smallint] NULL,
	[object_id] [int] NULL,
	[index_id] [int] NULL,
	[partition_number] [int] NULL,
	[index_type_desc] [nvarchar](60) NULL,
	[alloc_unit_type_desc] [nvarchar](60) NULL,
	[index_depth] [tinyint] NULL,
	[index_level] [tinyint] NULL,
	[avg_fragmentation_in_percent] [float] NULL,
	[fragment_count] [bigint] NULL,
	[avg_fragment_size_in_pages] [float] NULL,
	[page_count] [bigint] NULL,
	[avg_page_space_used_in_percent] [float] NULL,
	[record_count] [bigint] NULL,
	[ghost_record_count] [bigint] NULL,
	[version_ghost_record_count] [bigint] NULL,
	[min_record_size_in_bytes] [int] NULL,
	[max_record_size_in_bytes] [int] NULL,
	[avg_record_size_in_bytes] [float] NULL,
	[forwarded_record_count] [bigint] NULL,
	[compressed_page_count] [bigint] NULL
) ON [PRIMARY]
END

----This is being altered as part of 1.2 upgrade.  The sysname can't be relied on for an accurate data type.
BEGIN
	ALTER TABLE Minion.IndexPhysicalStats
	alter column
	[DBName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexPhysicalStats
	alter column
	[SchemaName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexPhysicalStats
	alter column
	[TableName] VARCHAR(400) NOT NULL

	ALTER TABLE Minion.IndexPhysicalStats
	alter column
	[IndexName] VARCHAR(400) NOT NULL
END


--------------------------------------------------BEGIN IndexSettingsDB---------------------------------------------------------------
IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexMaintLogDetails' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexMaintLogDetails](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[ExecutionDateTime] [datetime] NOT NULL,
	[Status] [varchar](500) NULL,
	[DBName] VARCHAR(400) NOT NULL,
	[TableID] [bigint] NULL,
	[SchemaName] VARCHAR(400) NULL,
	[TableName] VARCHAR(400) NULL,
	[IndexID] [int] NULL,
	[IndexName] VARCHAR(400) NULL,
	[IndexTypeDesc] [varchar](50) NULL,
	[IndexScanMode] [varchar](25) NULL,
	[Op] [varchar](10) NULL,
	[ONLINEopt] [varchar](3) NULL,
	[ReorgThreshold] [tinyint] NULL,
	[RebuildThreshold] [tinyint] NULL,
	[FILLFACTORopt] [tinyint] NULL,
	[PadIndex] [varchar](3) NULL,
	[FragLevel] [tinyint] NULL,
	[Stmt] [nvarchar](1000) NULL,
	[ReindexGroupOrder] [int] NULL,
	[ReindexOrder] [int] NULL,
	[PreCode] [varchar](max) NULL,
	[PostCode] [varchar](max) NULL,
	[OpBeginDateTime] [datetime] NULL,
	[OpEndDateTime] [datetime] NULL,
	[OpRunTimeInSecs] [int] NULL,
	[TableRowCTBeginDateTime] [datetime] NULL,
	[TableRowCTEndDateTime] [datetime] NULL,
	[TableRowCTTimeInSecs] [int] NULL,
	[TableRowCT] [bigint] NULL,
	[PostFragBeginDateTime] [datetime] NULL,
	[PostFragEndDateTime] [datetime] NULL,
	[PostFragTimeInSecs] [int] NULL,
	[PostFragLevel] [tinyint] NULL,
	[UpdateStatsBeginDateTime] [datetime] NULL,
	[UpdateStatsEndDateTime] [datetime] NULL,
	[UpdateStatsTimeInSecs] [int] NULL,
	[UpdateStatsStmt] [varchar](1000) NULL,
	[PreCodeBeginDateTime] [datetime] NULL,
	[PreCodeEndDateTime] [datetime] NULL,
	[PreCodeRunTimeInSecs] [int] NULL,
	[PostCodeBeginDateTime] [datetime] NULL,
	[PostCodeEndDateTime] [datetime] NULL,
	[PostCodeRunTimeInSecs] [bigint] NULL,
	[UserSeeks] [bigint] NULL,
	[UserScans] [bigint] NULL,
	[UserLookups] [bigint] NULL,
	[UserUpdates] [bigint] NULL,
	[LastUserSeek] [datetime] NULL,
	[LastUserScan] [datetime] NULL,
	[LastUserLookup] [datetime] NULL,
	[LastUserUpdate] [datetime] NULL,
	[SystemSeeks] [bigint] NULL,
	[SystemScans] [bigint] NULL,
	[SystemLookups] [bigint] NULL,
	[SystemUpdates] [bigint] NULL,
	[LastSystemSeek] [datetime] NULL,
	[LastSystemScan] [datetime] NULL,
	[LastSystemLookup] [datetime] NULL,
	[LastSystemUpdate] [datetime] NULL,
	[Warnings] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END

ALTER TABLE Minion.IndexMaintLogDetails
alter COLUMN [Status] varchar(MAX);

----This is being altered as part of 1.2 upgrade.  The sysname can't be relied on for an accurate data type.
BEGIN
	ALTER TABLE Minion.IndexMaintLogDetails
	alter column
	[DBName] VARCHAR(400) NULL

	ALTER TABLE Minion.IndexMaintLogDetails
	alter column
	[SchemaName] VARCHAR(400) NULL

	ALTER TABLE Minion.IndexMaintLogDetails
	alter column
	[TableName] VARCHAR(400) NULL

	ALTER TABLE Minion.IndexMaintLogDetails
	alter column
	[IndexName] VARCHAR(400) NULL
END


IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id('Minion.IndexMaintLogDetails') AND name ='clustID')
BEGIN
	CREATE UNIQUE CLUSTERED INDEX [clustID] ON [Minion].[IndexMaintLogDetails]
	(
		[ID] ASC
	)WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)
END
GO

IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id('Minion.IndexMaintLogDetails') AND name ='nonExecDateDBName')
BEGIN
	CREATE NONCLUSTERED INDEX nonExecDateDBName ON Minion.IndexMaintLogDetails (ExecutionDateTime, DBName, SchemaName, TableName)
	WITH (PAD_INDEX = ON, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 90)
END
GO
--------------------------------------------------END IndexSettingsDB---------------------------------------------------------------


IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexMaintLog' AND schema_id('Minion') IS NOT NULL)
BEGIN
CREATE TABLE [Minion].[IndexMaintLog](
	[ID] [bigint] IDENTITY(1,1) NOT NULL,
	[ExecutionDateTime] [datetime] NULL,
	[Status] [varchar](500) NULL,
	[DBName] VARCHAR(400) NOT NULL,
	[Tables] [varchar](7) NULL,
	[RunPrepped] [bit] NULL,
	[PrepOnly] [bit] NULL,
	[ReorgMode] [varchar](7) NULL,
	[NumTablesProcessed] [int] NULL,
	[NumIndexesProcessed] [int] NULL,
	[NumIndexesRebuilt] [int] NULL,
	[NumIndexesReorged] [int] NULL,
	[RecoveryModelChanged] [bit] NULL,
	[RecoveryModelCurrent] [varchar](12) NULL,
	[RecoveryModelReindex] [varchar](12) NULL,
	[SQLVersion] [varchar](20) NULL,
	[SQLEdition] [varchar](50) NULL,
	[DBPreCode] [nvarchar](max) NULL,
	[DBPostCode] [nvarchar](max) NULL,
	[DBPreCodeBeginDateTime] [datetime] NULL,
	[DBPreCodeEndDateTime] [datetime] NULL,
	[DBPostCodeBeginDateTime] [datetime] NULL,
	[DBPostCodeEndDateTime] [datetime] NULL,
	[DBPreCodeRunTimeInSecs] [int] NULL,
	[DBPostCodeRunTimeInSecs] [int] NULL,
	[ExecutionFinishTime] [datetime] NULL,
	[ExecutionRunTimeInSecs] [int] NULL,
	[IncludeDBs] [varchar](max) NULL,
	[ExcludeDBs] [varchar](max) NULL,
	[RegexDBsIncluded] [varchar](max) NULL,
	[RegexDBsExcluded] [varchar](max) NULL,
	[Warnings] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END

ALTER TABLE Minion.IndexMaintLog
alter COLUMN [Status] varchar(MAX);

----This is being altered as part of 1.2 upgrade.  The sysname can't be relied on for an accurate data type.
BEGIN
	ALTER TABLE Minion.IndexMaintLog
	alter column
	[DBName] VARCHAR(400) NOT NULL
END

-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- BEGIN IndexMaintDB ----------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------



IF EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexMaintDB' AND schema_id('Minion') IS NOT NULL)
BEGIN
DROP PROCEDURE Minion.IndexMaintDB
END

GO
CREATE PROCEDURE [Minion].[IndexMaintDB]
	@DBName VARCHAR(100) , 
	@IndexOption VARCHAR(7) ,
	@ReorgMode VARCHAR(7) , 
	@RunPrepped BIT , 
	@PrepOnly BIT , 
	@StmtOnly BIT , 
	@LogProgress BIT = 1 
AS 

--v.1.2
/***********************************************************************************
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
------------------Minion Reindex------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Created By: MidnightSQL Consulting LLC. and MidnightDBA.com

For SQL Server consulting, see our website http://www.MidnightSQL.com
No job is too big or too small.

Also, check out our FREE SQL Server training videos at http://www.MidnightDBA.com

This is a big routine with many nuances.  Our documentation is complete, but if 
you prefer, we also have videos that show you how to use each of the features.
You can find them at http://www.MidnightDBA.com/Minion

Minion Reindex is a free, standalone, index maintenance routine that is a component 
of the Minion Enterprise Management solution.

Minion Enterprise Management makes managing your SQL Server enterprise super easy. 
The reindex routine folds into the enterprise solution with ease.  By integrating 
your index maintenance into the Minion Enterprise Management solution, you get the 
ability to manage your reindex parameters from a central location. And, Minion 
Enterprise Management provides enterprise-level reporting and alerting.


* By running this software you are agreeing to the terms of the license agreement.
* You can find a copy of the license agreement here: http://www.midnightsql.com/minion-end-user-license-agreement/
--------------------------------------------------------------------------------

Purpose: This SP does a reindex or reorg of tables meeting the criteria stored in master..IndexMaint.
	It has many features that listed below.

Features:
	*  Redinex or reorg.
	*  Set reindex and reorg threshholds at the table level using the IndexMaint table.
	*  Reports everything it does to the IndexMaintLog table.  You can see how long it's taking at 
	   every step.
	*  A look at the IndexMaintLog table will tell you how long the current index took last time 
	   it was run.  So you can estimate how long it'll take this time.
	*  Get row counts for the tables after the reindex.  This can help with planning downtime windows when data expands.
	*  Get a frag % after the Op.  Some tables don't ever defrag completely.  Even when they're newly 
	   reindexed they're still at say 35%.  This lets you know what the % is when the reindex/reorg is fresh.
	*  Order the tables at 2 levels.  You can group them and say that you want this entire group of tables to be done
	   first.  And you can say that within those groups you want the tables to be done in a certain order. 
	*  Set the fillfactor and pad index options for each table in IndexMaint table.
	*  Process LOB, nonLOB or All tables from single sp.
	*  Specify many reindex options in IndexMaint table.
	*  Choose to update stats or not when you do a reorg.  Set in IndexMaint.
	*  You can specify that a table always gets processed, or never gets processed by setting the values in IndexMaint.
	   To make sure a table always gets processed, set the Threshold cols to 0.  To make sure they're never processed, set them
	   to above 100.  Since the percent will never be above 100, they'll never reach the threashold.
	*  Specify that any table can have online/offline reindex. (assuming it's supported).
	*  You can get the frag level of the desired tables beforehand and when this SP runs it'll spend its time actually reindexing
	   tables instead of finding frag levels.  In large DBs it can take a very long time to get the frag level of the tables so 
	   it can take up to several hours to even determine which tables need to be reindexed.  If you have such a DB and a tight 
	   maint window, you may take advantage of this feature and get the frag levels earlier in the day and spend your maint window
	   on the actual maint.   

Limitations:
	*  You can't specify a stop time for the sp.  So you can't tell it to say run for only 2hrs.
	*  Doesn't work for SQL Server 2000.
	*  All options specified in IndexMaint are for each table, which means that all the indexes on that table will
	   be processed with those values.  Keeping up with individual indexes would just be too much effort in an enterprise.

Notes:
	* Be careful when using PostFrag feature.  It can greately increase the length of your maint and
	  since it is done after every index is processed, you won't roll through the individual indexes as fast.
  
	* There are times when I could have used static tables and it may have even been easier and made the SP shorter.  However,
	  one of my main goals when pushing these objects out to servers is to push out as few objects as possible.  Therefore,
	  I will only push out static objects when there is no other choice.  


Walkthrough: 
      1. TBD


Conventions:


Parameters:
-----------

	@DBName	- Database name to be reindexed. We reindex a single DB at a time.
	
	@IndexOption - Valid options: All, ONLINE, OFFLINE.  So All the indexes, 
	or only the indexes that can be done online or offline.
    
	@ReorgMode - Valid options: All, REORG, REBUILD. For REORG mode, only 
	REORG stmts will be generated.  For REBUILD, only REBUILD stmts will be 
	generated.

	@RunPrepped - Valid options: 1, 0. If you've collected index frag stats 
	ahead of time by running with @PrepOnly = 1, then you can use this option. 
    
	@PrepOnly - Valid options: 1, 0. Only gets index frag stats and saves to a 
	table.  This preps the DB to be reindexed.  Run this with @RunPrepped = 1 
	to take advantage of the prep.
    
	@StmtOnly - Valid options: 1, 0. Only prints reindex stmts.  Excellent 
	choice for running stmts manually.  Allows you to pick and choose which 
	indexes you want to do or just see how many are over the thresholds.
    
	@LogProgress - Valid options: 1, 0.  Allows you to have every step of the 
	run printed in the log so you can see the progress it's making.  This can 
	take a little extra time so leave it out if you just want it to run without
	being monitored.

Tables:
--------
	#IndexName - The list of all indexes in the database.  This list is then reduced to only those
				 that meet the criteria for reindexing given in the parameters and settings tables.
	
	#PostFrag - For use in gathering fragmentation stats after index operations are complete, per DB. []
	
	#IndexPhysicalStats - For use in deciding which indexes are maintained, based on the index's physical
							stats. Used per DB


Example Execution:
	-- Demo DB, reorg all
	EXEC [Minion].[IndexMaintDB] @DBName = 'Demo'
		, @IndexOption = 'All'
		, @ReorgMode = 'All'
		, @RunPrepped = 0
		, @PrepOnly = 0
		, @StmtOnly = 0
	GO

	-- Demo DB, prep only
	EXEC [Minion].[IndexMaintDB] @DBName = 'Demo'
		, @IndexOption = 'All'
		, @ReorgMode = 'All'
		, @RunPrepped = 1
		, @PrepOnly = 0
		, @StmtOnly = 0
	GO


Revision History:
	9/23/2014	Added rowcount functionality, removed #TableFrag references. J.M.


DEPRECATED
	@PostFragVar - @table that holds intermediate results for the postFrag operation.  It's used because
					you need to get it from dynamic sql.  The data in this var is immediately
					moved to a local var to make the update easier.

***********************************************************************************/



--IF @DBName = 'Help'
--GOTO HELP
SET QUOTED_IDENTIFIER ON;

	DECLARE 
		@ReorgThreshold TINYINT ,
		@RebuildThreshold TINYINT ,
		@Fillfactor TINYINT ,
		@PadIndex VARCHAR(3) ,
		@Online VARCHAR(3) ,
		@SortInTempDB VARCHAR(3) ,
		@MAXDOP TINYINT ,
		@DataCompression VARCHAR(50) ,
		@PartitionReindex BIT ,
		@GetRowCT BIT ,
		@GetPostFragLevel BIT ,
		@UpdateStatsOnDefrag BIT ,
		@ReindexGroupOrder BIT ,
		@ReindexOrder BIT ,
		@StatScanOption VARCHAR(25) ,
		@IndexScanMode VARCHAR(25) ,
		@IncludeUsageDetails BIT,
		@IsClustered BIT;

	IF @IndexOption IS NULL 
		BEGIN
			SET @IndexOption = 'All'
		END

	IF @ReorgMode IS NULL 
		BEGIN
			SET @ReorgMode = 'All'
		END

	DECLARE	@ExecutionDateTime DATETIME ,
		@RebuildPct TINYINT ,
		@ReorgPct TINYINT ,
		@LogDB VARCHAR(100) ,
		@SQL NVARCHAR(2000) ,
		@LogSQL NVARCHAR(2000) ,
		@ReindexSQL NVARCHAR(4000) ,
		@RowCT BIGINT ,
		@RowCTSQL VARCHAR(1000) ,
		@LogPostFrag BIT ,
		@CurrentRecoveryModel VARCHAR(12) ,
		@ReindexRecoveryModel VARCHAR(12) ,
		@Version VARCHAR(50) ,
		@Edition VARCHAR(15) ,
		@TableCtrl VARCHAR(100) ,
		@currDBID INT ,
		@currSchemaName VARCHAR(100) ,
		@currTableID BIGINT ,
		@currTableName VARCHAR(400),
		@currIndexName VARCHAR(400),
		@currIndexID INT ,
		@currIndexType INT ,
		@currIndexTypeDesc VARCHAR(50) ,
		@currPartitionNumber INT ,
		@currFragLevel VARCHAR(50) ,
		@currOP VARCHAR(10) ,
		@currReorgThreshold VARCHAR(50) ,
		@currRebuildThreshold VARCHAR(50) ,
		@currFILLFACTORopt VARCHAR(50) ,
		@currPadIndex VARCHAR(50) ,
		@currONLINEopt VARCHAR(50) ,
		@currSortInTempDB VARCHAR(50) ,
		@currMAXDOPopt VARCHAR(50) ,
		@currDataCompression VARCHAR(100) ,
		@currIgnoreDupKey VARCHAR(50) ,
		@currStatsNoRecompute VARCHAR(50) ,
		@currAllowRowLocks VARCHAR(50) ,
		@currAllowPageLocks VARCHAR(50) ,
		@currLogProgress BIT ,
		@currLogRetDays SMALLINT ,
		@currPushToMinion BIT ,
		@currLogIndexPhysicalStats BIT ,
		@currTablePreCode VARCHAR(8000) ,
		@currTablePostCode VARCHAR(8000) ,
		@TablePreCodeBeginDateTime DATETIME ,
		@TablePreCodeEndDateTime DATETIME ,
		@TablePostCodeBeginDateTime DATETIME ,
		@TablePostCodeEndDateTime DATETIME ,
		@currPartitionReindex BIT ,
		@currGetRowCT BIT ,
		@currGetPostFragLevel BIT ,
		@currUpdateStatsOnDefrag BIT ,
		@currIndexScanMode VARCHAR(25) ,
		@currStatScanOption VARCHAR(25) ,
		@currWaitAtLowPriority BIT ,
		@currMaxDurationInMins INT ,
		@currAbortAfterWait VARCHAR(20) ,
		@currStmtPrefix NVARCHAR(500),
		@currStmtSuffix NVARCHAR(500),
		@OpBeginDateTime DATETIME ,
		@OpEndDateTime DATETIME ,
		@CallBeginDateTime DATETIME ,
		@CallEndDateTime DATETIME ,
		@RowCTBeginDateTime DATETIME ,
		@RowCTEndDateTime DATETIME ,
		@PostFragBeginDateTime DATETIME ,
		@PostFragEndDateTime DATETIME ,
		@PostFragLevel TINYINT ,
		@StatsBeginDateTime DATETIME ,
		@StatsEndDateTime DATETIME ,
		@StatsSQL VARCHAR(2000) ,
		@ChangeComment VARCHAR(100) ,
		@TableListSQL VARCHAR(2000) ,
		@FragStatsSQL VARCHAR(2000) ,
		@FragTableCtrl VARCHAR(100) ,
		@PostFragSQL VARCHAR(MAX) ,
		@currIndexForFragStats VARCHAR(500) ,
		@ErrLine INT ,
		@ErrMsg VARCHAR(8000) ,
		@ErrSev VARCHAR(50) ,
		@ErrProc VARCHAR(50) ,
		@ErrNum INT ,
		@DBPreCode NVARCHAR(MAX) ,
		@DBPostCode NVARCHAR(MAX) ,
		@DBPreCodeBeginDateTime DATETIME ,
		@DBPreCodeEndDateTime DATETIME ,
		@DBPostCodeBeginDateTime DATETIME ,
		@DBPostCodeEndDateTime DATETIME ,
		@DBPreCodeRunTimeInSecs INT ,
		@DBPostCodeRunTimeInSecs INT ,
		@NumTablesProcessed INT ,
		@NumIndexesProcessed INT ,
		@NumIndexesRebuilt INT ,
		@NumIndexesReorged INT ,
		@FragLogCtr INT ,
		@FragLogTotalCtr INT,
		@WithErrors BIT,
		@Status VARCHAR(1000),
		@TableCT INT,
		@currTableIterator INT,
		@Port VARCHAR(10),
		@ServerInstance VARCHAR(200),
		@MaintDB VARCHAR(150);

	SET @TableCtrl = '';				   
	SET @FragTableCtrl = '';
	SET @FragLogCtr = 0;	
	SET @ExecutionDateTime = GETDATE();
	SET @WithErrors = 0;
	
	IF @LogProgress IS NULL
	SET @LogProgress = 1

	SET NOCOUNT ON;

SET @MaintDB = DB_NAME();
SET @ServerInstance = @@ServerName;
SET @IsClustered = CONVERT(CHAR(1), SERVERPROPERTY('IsClustered'));

--Here we're connecting locally if it's not a cluster.  
 IF @ServerInstance NOT LIKE '%\%' AND (@IsClustered = 0 OR @IsClustered IS NULL)
	BEGIN
		SET @ServerInstance = '.'
	END
IF @ServerInstance LIKE '%\%' AND (@IsClustered = 0 OR @IsClustered IS NULL)
	BEGIN
			SET @ServerInstance = '.' + '\' + CONVERT(CHAR(100), SERVERPROPERTY('InstanceName'));
	END

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
---------------------------------------BEGIN Initial Status---------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------

----This initial log gives you something to look at while the routine is doing this initial stuff before
----it actually begins processing indexes.  This way you have some insight into what the routine is doing.

	IF @StmtOnly = 0 
		BEGIN --@StmtOnly = 0
			--If ((@PrepOnly <> 1) AND (@RunPrepped <> 1)) OR (@PrepOnly = 1)
				BEGIN
					INSERT	Minion.IndexMaintLog
							( ExecutionDateTime ,
							  Status ,
							  DBName,
							  Tables,
							  RunPrepped,
							  PrepOnly,
							  ReorgMode
						
							)
							SELECT	@ExecutionDateTime,
									'Configuring Run' ,
									@DBName,
									@IndexOption,
									@RunPrepped,
									@PrepOnly ,
									@ReorgMode
				END
		END --@StmtOnly = 0


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
---------------------------------------END Initial Status-----------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------
------------------BEGIN Get RecoveryModel----------------------------------------
---------------------------------------------------------------------------------

	IF @StmtOnly = 0 
		BEGIN  --@StmtOnly = 0   --RecoveryModel

		IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0

			SET @CurrentRecoveryModel = ( SELECT	recovery_model_desc
										  FROM		master.sys.databases
										  WHERE		name = @DBName
										);
			SET @ReindexRecoveryModel = ( SELECT	RecoveryModel
										  FROM		Minion.IndexSettingsDB
										  WHERE		DBName = 'MinionDefault'
										);

		----Override default RecoveryModel if a DB override exists.
			IF ( SELECT	RecoveryModel
				 FROM	Minion.IndexSettingsDB
				 WHERE	DBName = @DBName
			   ) IS NOT NULL 
				BEGIN
					SET @ReindexRecoveryModel = ( SELECT	RecoveryModel
												  FROM		Minion.IndexSettingsDB
												  WHERE		DBName = @DBName
												);
				END


			IF @ReindexRecoveryModel IS NULL 
				BEGIN
					SET @ReindexRecoveryModel = @CurrentRecoveryModel;
				END

----Don't change RecoveryModel if value is NULL in IndexDBSettings.

			BEGIN  --@ReindexRecoveryModel

				IF @CurrentRecoveryModel <> @ReindexRecoveryModel
					AND @ReindexRecoveryModel IS NOT NULL 
					BEGIN
						DECLARE	@RecoveryModelSQL VARCHAR(150) ,
							@RecoveryModelChanged BIT;
	
						SET @RecoveryModelSQL = 'ALTER DATABASE [' + @DBName + '] SET RECOVERY ' + @ReindexRecoveryModel;
						EXEC (@RecoveryModelSQL);
						SET @RecoveryModelChanged = 1;
					END
			END  --@ReindexRecoveryModel


			IF @ReindexRecoveryModel = @CurrentRecoveryModel 
				BEGIN 
					SET @RecoveryModelChanged = 0;
				END  
			END --@PrepOnly = 0

		END  --@StmtOnly = 0   --RecoveryModel
---------------------------------------------------------------------------------
------------------END Get RecoveryModel------------------------------------------
---------------------------------------------------------------------------------

---------------------------------------------------------------------------------
------------------ BEGIN Get Version Info----------------------------------------
---------------------------------------------------------------------------------

	SELECT	@Version = LEFT(CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(15)), CHARINDEX('.', CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(15)), 1) - 1)
	SELECT	@Edition = CAST(SERVERPROPERTY('Edition') AS VARCHAR(25));

	DECLARE	@OnlineEdition BIT
	IF @Edition LIKE '%Enterprise%'
		OR @Edition LIKE '%Developer%' 
		BEGIN
			SET @OnlineEdition = 1
		END
	
	IF @Edition NOT LIKE '%Enterprise%'
		AND @Edition NOT LIKE '%Developer%' 
		BEGIN
			SET @OnlineEdition = 0
		END	


---------------------------------------------------------------------------------
------------------ END Get Version Info------------------------------------------
---------------------------------------------------------------------------------



-----------------------------------
-----------------------------------
--------BEGIN Check Param Logic----
-----------------------------------
-----------------------------------

	IF @RunPrepped = 1
		AND @PrepOnly = 1
--You can't run in prepped mode and prep it at the same time.
--The SP would physically run, but you would get dupes it would never
--actually reindex anything.
		BEGIN

			UPDATE Minion.IndexMaintLog
			SET Status = 'FATAL ERROR: @RunPrepped and @PrepOnly are both 1.  This is a logic error.  Set one of them to 0.  You either want to prep or you want to run prepped.  You cannot do both at the same time.'
			WHERE ExecutionDateTime = @ExecutionDateTime 
			AND   DBName = @DBName

			RAISERROR ('@RunPrepped and @PrepOnly are both 1.  This is a logic error.  Set one of them to 0.  You either want to prep or you want to run prepped.  You cannot do both at the same time.', 16, 1); 

			RETURN;		    
		END	

	IF @OnlineEdition = 0
		AND @IndexOption = 'ONLINE'
--You can't reindex ONLINE on this edition of SQL Server.  No work will be done.  Change the @IndexOption parameter to 'All' or 'Offline'.
		BEGIN

			UPDATE Minion.IndexMaintLog
			SET Status = 'FATAL ERROR: @OnlineEdition = 0 and @IndexOption = ''ONLINE''.  This is a logic error.  You can''t reindex ONLINE on this edition of SQL Server.  No work will be done.  Change the @IndexOption parameter to ''All'' or ''Offline'''
			WHERE ExecutionDateTime = @ExecutionDateTime 
			AND   DBName = @DBName

			RAISERROR ('@OnlineEdition = 0 and @IndexOption = ''ONLINE''.  This is a logic error.  You can''t reindex ONLINE on this edition of SQL Server.  No work will be done.  Change the @IndexOption parameter to ''All'' or ''Offline''', 16, 1); 			
			
			RETURN;	    
		END	

-----------------------------------
-----------------------------------
--------END Check Param Logic------
-----------------------------------
-----------------------------------	


-----------------------------------------------------
-----------------------------------------------------
-----------BEGIN Port--------------------------------
-----------------------------------------------------
-----------------------------------------------------

SET @Port = (SELECT TOP 1 Port FROM Minion.IndexSettingsDB)

 IF @ServerInstance NOT LIKE '%\%'
	BEGIN
		SET @Port = CASE WHEN @Port IS NULL THEN ',' + '1433'
						 WHEN @Port IS NOT NULL THEN ',' + @Port
						 END
	END
IF @ServerInstance LIKE '%\%'
	BEGIN
			SET @Port = CASE WHEN @Port IS NULL THEN ''
							 WHEN @Port IS NOT NULL THEN ',' + @Port
							 END
	END

-----------------------------------------------------
-----------------------------------------------------
-----------END Port----------------------------------
-----------------------------------------------------
-----------------------------------------------------


------------------BEGIN Create #IndexTableFrag--------------------------

CREATE TABLE #TableFrag
    (
      ExecutionDateTime DATETIME NULL ,
      DBName VARCHAR(400) COLLATE DATABASE_DEFAULT NULL,
      DBID INT NULL ,
      TableID BIGINT NULL ,
      SchemaName VARCHAR(400) COLLATE DATABASE_DEFAULT NULL ,
      TableName VARCHAR(400) COLLATE DATABASE_DEFAULT NULL ,
      IndexName VARCHAR(400) COLLATE DATABASE_DEFAULT NULL ,
      IndexID BIGINT NULL ,
      IndexType TINYINT NULL ,
      IndexTypeDesc NVARCHAR(120) COLLATE DATABASE_DEFAULT NULL ,
      IsDisabled BIT NULL ,
      IsHypothetical BIT NULL ,
      avg_fragmentation_in_percent FLOAT NULL ,
      ReorgThreshold TINYINT NULL ,
      RebuildThreshold TINYINT NULL ,
      FILLFACTORopt TINYINT NULL ,
      PadIndex VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      ONLINEopt VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      SortInTempDB VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      MAXDOPopt TINYINT NULL ,
      DataCompression VARCHAR(50) COLLATE DATABASE_DEFAULT NULL ,
      GetRowCT BIT NULL ,
      GetPostFragLevel BIT NULL ,
      UpdateStatsOnDefrag BIT NULL ,
      StatScanOption VARCHAR(25) COLLATE DATABASE_DEFAULT NULL ,
      IgnoreDupKey VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      StatsNoRecompute VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      AllowRowLocks VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      AllowPageLocks VARCHAR(3) COLLATE DATABASE_DEFAULT NULL ,
      WaitAtLowPriority BIT NULL ,
      MaxDurationInMins INT NULL ,
      AbortAfterWait VARCHAR(20) COLLATE DATABASE_DEFAULT NULL ,
      LogProgress BIT NULL ,
      LogRetDays SMALLINT NULL ,
      PushToMinion BIT NULL ,
      LogIndexPhysicalStats BIT NULL ,
      IndexScanMode VARCHAR(25) COLLATE DATABASE_DEFAULT NULL ,
      TablePreCode NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ,
      TablePostCode NVARCHAR(MAX) COLLATE DATABASE_DEFAULT NULL ,
      Prepped BIT NULL ,
      ReindexGroupOrder INT NULL ,
      ReindexOrder INT NULL,
	  StmtPrefix NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL,
	  StmtSuffix NVARCHAR(500) COLLATE DATABASE_DEFAULT NULL
    )

------------------END Create #IndexTableFrag----------------------------


-----------------------------------
-----------------------------------
--------BEGIN DBPreCode------------
-----------------------------------
-----------------------------------	

	IF @StmtOnly = 0 
	BEGIN --@StmtOnly = 0 
			IF @PrepOnly = 0
				BEGIN --@PrepOnly = 0
				----Get default PreCode for all DBs.
					SET @DBPreCode = ( SELECT	DBPreCode
									   FROM		Minion.IndexSettingsDB
									   WHERE	DBName = 'MinionDefault'
									 )

				----Override default PreCode if a DB override exists.
					IF ( SELECT	DBPreCode
						 FROM	Minion.IndexSettingsDB
						 WHERE	DBName = @DBName
					   ) IS NOT NULL 
						BEGIN
							SET @DBPreCode = ( SELECT	DBPreCode
											   FROM		Minion.IndexSettingsDB
											   WHERE	DBName = @DBName
											 );
						END




					IF @DBPreCode IS NOT NULL 
						BEGIN --@DBPreCode IS NOT NULL

		------------------BEGIN Log Status---------------------------------

							IF @StmtOnly = 0 
								BEGIN --@StmtOnly = 0
								IF @PrepOnly = 0
									BEGIN
												UPDATE	Minion.IndexMaintLog
												SET		Status = 'Running DB PreCode'
												WHERE	ExecutionDateTime = @ExecutionDateTime
														AND DBName = @DBName
									END

								END --@StmtOnly = 0

		------------------END Log Status---------------------------------

							SET @DBPreCodeBeginDateTime = GETDATE();
							EXEC (@DBPreCode)
							SET @DBPreCodeEndDateTime = GETDATE();

						END --@DBPreCode IS NOT NULL
				END --@PrepOnly = 0
		END --@StmtOnly = 0


-----------------------------------
-----------------------------------
--------END DBPreCode--------------
-----------------------------------
-----------------------------------	



------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------BEGIN Index Selection---------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------


------------------BEGIN Log Status---------------------------------

	IF @StmtOnly = 0 
		BEGIN --@StmtOnly = 0

			IF @LogProgress = 1 
				BEGIN --@LogProgress = 1

							--If @PrepOnly = 0
							--	Begin --@PrepOnly = 0

									INSERT	Minion.IndexMaintLogDetails
											( ExecutionDateTime ,
											  Status,
											  DBName
											)
											SELECT	@ExecutionDateTime ,
													'Configuring tables to process',
													@DBName

								--End --@PrepOnly = 0
				END --@LogProgress = 1
		END --@StmtOnly = 0

------------------END Log Status---------------------------------


---In case there was an error during the last run and the table didn't get 
---completely cleared out, clear it out here.
	DELETE	Minion.IndexTableFrag
	WHERE	DBName = @DBName
			AND Prepped = 0


	DELETE	Minion.IndexTableFrag
	WHERE	DBName = @DBName
			AND Prepped = 1
			AND ExecutionDateTime <> (SELECT MAX(ExecutionDateTime) FROM Minion.IndexTableFrag WHERE DBName = @DBName AND Prepped = 1)


IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

	DECLARE	@IndexNameSQL VARCHAR(2000)
	SET @IndexNameSQL = 'USE [' + @DBName
		+ ']; SELECT DISTINCT
        so.object_id ,
        SCHEMA_NAME(so.schema_id) AS SchemaName ,
        OBJECT_NAME(so.object_id) TableName ,
        si.Name AS IndexName ,
        si.index_id ,
        CAST(''ON'' AS VARCHAR(3)) AS ONLINEopt, -- CAST(NULL AS VARCHAR(3)) AS ONLINEopt ,
        si.type AS IndexType ,
        si.type_desc AS IndexTypeDesc ,
        is_disabled AS IsDisabled ,
        is_hypothetical AS IsHypothetical
INTO    #T
FROM    sys.indexes si WITH ( NOLOCK )
        INNER JOIN sys.objects so WITH ( NOLOCK )
        ON si.object_id = so.object_id
WHERE   ( so.type = ''U''
          OR so.type = ''V''
        )
        AND so.is_ms_shipped <> 1; 
        SELECT * from #T;'

END --@RunPrepped = 0

--PRINT @IndexNameSQL --!-- Testing

IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

	CREATE TABLE #IndexName
		(
		  TableID INT ,
		  SchemaName VARCHAR(100) COLLATE DATABASE_DEFAULT ,
		  TableName VARCHAR(100) COLLATE DATABASE_DEFAULT ,
		  IndexName VARCHAR(1000) COLLATE DATABASE_DEFAULT ,
		  IndexID INT ,
		  ONLINEopt VARCHAR(3) COLLATE DATABASE_DEFAULT ,
		  IndexType TINYINT ,
		  IndexTypeDesc NVARCHAR(120) COLLATE DATABASE_DEFAULT ,
		  IsDisabled BIT ,
		  IsHypothetical BIT
		);

	INSERT #IndexName
	EXEC (@IndexNameSQL);

END --@RunPrepped = 0

------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------END Index Selection-----------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------

	CREATE TABLE #PostFrag
		(
		  MaxFrag TINYINT ,
		  Index_ID INT ,
		  Index_Level INT
		)


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
------------BEGIN delete excluded tables------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

	DELETE	FROM I
	FROM	#IndexName I
			INNER JOIN Minion.IndexSettingsTable IM ON I.SchemaName = IM.SchemaName 
													   AND I.TableName = IM.TableName 
	WHERE	IM.DBName = @DBName
			AND IM.Exclude = 1;

END --@RunPrepped = 0

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
------------END delete excluded tables--------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


------------------------------------------------------------
------------------------------------------------------------
------------BEGIN delete unwanted indexes-------------------
------------------------------------------------------------
------------------------------------------------------------

IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

----Disabled indexes
	DELETE	FROM #IndexName
	WHERE	IsDisabled = 1;

----Hypothetical indexes
	DELETE	FROM #IndexName
	WHERE	IsHypothetical = 1;

----HEAPs
	DELETE	FROM #IndexName
	WHERE	IndexName IS NULL;

----In-Memory (Heakton)
	DELETE	FROM #IndexName
	WHERE	IndexTypeDesc = 'NONCLUSTERED HASH';

END --@RunPrepped = 0
------------------------------------------------------------
------------------------------------------------------------
------------END delete unwanted indexes---------------------
------------------------------------------------------------
------------------------------------------------------------

IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

	SET @FragLogTotalCtr = ( SELECT	COUNT(*)
							 FROM	#IndexName
						   )

END --@RunPrepped = 0

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
------------Begin Get Index Fragmentation-----------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

	IF @RunPrepped = 0
		OR @PrepOnly = 1
--The point of having a prep mode is so you don't have to incur the cost
--of getting the frag stats during your maint window.  So we're only
--going to run this if we're trying to prep or running it w/o prep.
		BEGIN --@RunPrepped = 0 OR @PrepOnly = 1

-----------------------------------------------------------
----------BEGIN Get Current Options------------------------
--Set current DB options to Minion default for all DBs.
--This is used if you haven't chosen to manage at the DB or table levels.

--Get initial table and index list from #IndexName
			INSERT	Minion.IndexTableFrag
					( ExecutionDateTime ,
					  DBName ,
					  DBID,
					  TableID ,
					  SchemaName ,
					  TableName ,
					  IndexName ,
					  IndexID ,
					  IndexType ,
					  IndexTypeDesc ,
					  IsDisabled ,
					  ONLINEopt,
					  IsHypothetical
                    )
					SELECT	@ExecutionDateTime ,
							@DBName ,
							DB_ID(@DBName),
							TableID ,
							SchemaName ,
							TableName ,
							IndexName ,
							IndexID ,
							IndexType ,
							IndexTypeDesc ,
							IsDisabled ,
							ONLINEopt,
							IsHypothetical
					FROM	#IndexName


--Now update with default options.
			UPDATE	ITF
			SET		
					ReorgThreshold = IMD.ReorgThreshold ,
					RebuildThreshold = IMD.RebuildThreshold ,
					FILLFACTORopt = IMD.FILLFACTORopt ,
					PadIndex = IMD.PadIndex ,
					ONLINEopt = IMD.ONLINEopt ,
					SortInTempDB = IMD.SortInTempDB ,
					MAXDOPopt = IMD.MAXDOPopt ,
					DataCompression = IMD.DataCompression ,
					GetRowCT = IMD.GetRowCT ,
					GetPostFragLevel = IMD.GetPostFragLevel ,
					UpdateStatsOnDefrag = IMD.UpdateStatsOnDefrag ,
					StatScanOption = IMD.StatScanOption ,
					IgnoreDupKey = IMD.IgnoreDupKey ,
					StatsNoRecompute = IMD.StatsNoRecompute ,
					AllowRowLocks = IMD.AllowRowLocks ,
					AllowPageLocks = IMD.AllowPageLocks ,
					WaitAtLowPriority = IMD.WaitAtLowPriority ,
					MaxDurationInMins = IMD.MaxDurationInMins ,
					AbortAfterWait = IMD.AbortAfterWait ,
					LogProgress = IMD.LogProgress ,
					LogRetDays = IMD.LogRetDays ,
					PushToMinion = IMD.PushToMinion ,
					LogIndexPhysicalStats = IMD.LogIndexPhysicalStats ,
					IndexScanMode = IMD.IndexScanMode ,
					TablePreCode = IMD.TablePreCode ,
					TablePostCode = IMD.TablePostCode,
					StmtPrefix = IMD.StmtPrefix,
					StmtSuffix = IMD.StmtSuffix
			FROM	Minion.IndexTableFrag ITF 
					INNER JOIN Minion.IndexSettingsDB IMD ON 1 = 1 --We want to set all the values to default.  After, we'll override with either DB or table overrides.
			WHERE	IMD.DBName = 'MinionDefault'
					AND ITF.ExecutionDateTime = @ExecutionDateTime

-------DB override values-------------
--These are options for the individual DB.  Use this if you don't want to use the defaults.
--If you manage even 1 option at this level they all have to be managed here.

			UPDATE	ITF
			SET		ReorgThreshold = IMD.ReorgThreshold ,
					RebuildThreshold = IMD.RebuildThreshold ,
					FILLFACTORopt = IMD.FILLFACTORopt ,
					PadIndex = IMD.PadIndex ,
					ONLINEopt = IMD.ONLINEopt ,
					SortInTempDB = IMD.SortInTempDB ,
					MAXDOPopt = IMD.MAXDOPopt ,
					DataCompression = IMD.DataCompression ,
					GetRowCT = IMD.GetRowCT ,
					GetPostFragLevel = IMD.GetPostFragLevel ,
					UpdateStatsOnDefrag = IMD.UpdateStatsOnDefrag ,
					StatScanOption = IMD.StatScanOption ,
					IgnoreDupKey = IMD.IgnoreDupKey ,
					StatsNoRecompute = IMD.StatsNoRecompute ,
					AllowRowLocks = IMD.AllowRowLocks ,
					AllowPageLocks = IMD.AllowPageLocks ,
					WaitAtLowPriority = IMD.WaitAtLowPriority ,
					MaxDurationInMins = IMD.MaxDurationInMins ,
					AbortAfterWait = IMD.AbortAfterWait ,
					LogProgress = IMD.LogProgress ,
					LogRetDays = IMD.LogRetDays ,
					PushToMinion = IMD.PushToMinion ,
					LogIndexPhysicalStats = IMD.LogIndexPhysicalStats ,
					IndexScanMode = IMD.IndexScanMode ,
					TablePreCode = IMD.TablePreCode ,
					TablePostCode = IMD.TablePostCode,
					StmtPrefix = IMD.StmtPrefix,
					StmtSuffix = IMD.StmtSuffix
			FROM	Minion.IndexTableFrag ITF 
					INNER JOIN Minion.IndexSettingsDB IMD ON ITF.DBName = IMD.DBName
			WHERE	IMD.DBName = @DBName
					AND ITF.ExecutionDateTime = @ExecutionDateTime


----------------------------------------------------------------------------
----------------------------------------------------------------------------
--------------BEGIN Change Online Option------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------


--------------BEGIN All SQL Versions------------------------
----There are still datatypes that have to be done offline for all versions of SQL.
BEGIN --All Versions

	DECLARE	@UpdateONLINEoptSQL VARCHAR(2000)
	SET @UpdateONLINEoptSQL = 'USE [' + @DBName
		+ '];         UPDATE  T
SET     ONLINEopt = ''OFF''
FROM    [' + @MaintDB + '].Minion.IndexTableFrag T
        INNER JOIN sys.all_columns AC
        ON T.TableID = AC.object_id
WHERE   ( AC.system_type_id IN ( 34, 35, 99, 241 )
          OR AC.max_length = -1		  
        )
        AND T.IndexID = 1;

        UPDATE  T
SET     ONLINEopt = ''OFF''
FROM    [' + @MaintDB + '].Minion.IndexTableFrag T
        INNER JOIN sys.indexes si WITH ( NOLOCK )
        ON T.IndexID = si.index_id
           AND T.TableID = si.object_id
        INNER JOIN sys.index_columns ic WITH ( NOLOCK )
        ON si.object_id = ic.object_id
           AND si.index_id = ic.index_id
		   AND ic.index_id = T.IndexID -- Just mark the one index with the LOB column offline, not all indexes.
        INNER JOIN sys.columns sc WITH ( NOLOCK )
        ON si.object_id = sc.object_id
           AND sc.column_id = ic.column_id
WHERE   sc.system_type_id IN ( 34, 35, 99, 241 )
        OR sc.max_length = -1;';

	EXEC (@UpdateONLINEoptSQL);

END --All Versions
--------------END All SQL Versions--------------------------



--------------BEGIN Below 2012------------------------
If @Version < 11
BEGIN --@Version < 11

--	DECLARE	@UpdateONLINEoptSQL VARCHAR(2000)
	SET @UpdateONLINEoptSQL = 'USE [' + @DBName
		+ '];         UPDATE  T
SET     ONLINEopt = ''OFF''
FROM    [' + @MaintDB + '].Minion.IndexTableFrag T
        INNER JOIN sys.all_columns AC
        ON T.TableID = AC.object_id
WHERE   ( AC.system_type_id IN ( 240 )
          OR AC.max_length = -1		  
        )
		AND AC.user_type_id NOT IN (128)
        AND T.IndexID = 1;

        UPDATE  T
SET     ONLINEopt = ''OFF''
FROM    [' + @MaintDB + '].Minion.IndexTableFrag T
        INNER JOIN sys.indexes si WITH ( NOLOCK )
        ON T.IndexID = si.index_id
           AND T.TableID = si.object_id
        INNER JOIN sys.index_columns ic WITH ( NOLOCK )
        ON si.object_id = ic.object_id
           AND si.index_id = ic.index_id
		   AND ic.index_id = T.IndexID -- Just mark the one index with the LOB column offline, not all indexes.
        INNER JOIN sys.columns sc WITH ( NOLOCK )
        ON si.object_id = sc.object_id
           AND sc.column_id = ic.column_id
WHERE   sc.system_type_id IN ( 240 )
        OR sc.max_length = -1
		AND sc.user_type_id NOT IN (128);';


	EXEC (@UpdateONLINEoptSQL);

END --@Version < 11
--------------END Below 2012--------------------------



----------------------------------------------------
-------------BEGIN XML Indexes----------------------
---------------------------------------------------- 
----XML indexes still have to be done offline so we'll handle them here until they can be done online.  
----Either way, we'll handle them separately here.

UPDATE  Minion.IndexTableFrag
	SET     ONLINEopt = 'OFF'
	WHERE IndexTypeDesc = 'XML'
----------------------------------------------------
-------------END XML Indexes------------------------
---------------------------------------------------- 


----------------------------------------------------------------------------
----------------------------------------------------------------------------
--------------END Change Online Option--------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------




----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
------------BEGIN Remove (non)LOB Tables------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

-----Only do ONLINE or OFFLINE tables.  Whichever is passed in to the sp.
-----You may only want to do tables that can be online or offline.
-----The value gets passed into the SP and you delete the unwanted tables
-----here.  This only counts for any editions of SQL that can be done
-----ONLINE because otherwise they're all OFFLINE anyway.

-----You can't use online mode one some versions of SQL so there's no need to even try.
-----Set them all to OFF in this case.

IF @RunPrepped = 0
BEGIN --@RunPrepped = 0

	IF @OnlineEdition = 0 
		BEGIN
	
			UPDATE	Minion.IndexTableFrag --#IndexName
			SET		ONLINEopt = 'OFF'
	
		END

SET @OnlineEdition = 1
	IF @OnlineEdition = 1 
		BEGIN --@OnlineEdition = 1
			IF @IndexOption = 'ONLINE' --Only do ONLINE indexes.
				BEGIN --nonLOB
					DELETE	Minion.IndexTableFrag --#IndexName
					WHERE	ONLINEopt = 'OFF'
				END --nonLOB

			IF @IndexOption = 'OFFLINE' --Only do OFFLINE indexes.
				BEGIN --LOB
					DELETE	Minion.IndexTableFrag --#IndexName
					WHERE	ONLINEopt = 'ON'
				END --LOB

		END --@OnlineEdition = 1

END --@RunPrepped - 0

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
------------END Remove (non)LOB Tables--------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------





CREATE TABLE #ReindexResults
    (
        ID INT IDENTITY(1, 1),
        col1 VARCHAR(MAX) COLLATE DATABASE_DEFAULT
    )

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Frag Stats Cursor------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
			CREATE TABLE #IndexPhysicalStats
				(
				  ExecutionDateTime DATETIME ,
				  BatchDateTime DATETIME ,
				  IndexScanMode VARCHAR(25) COLLATE DATABASE_DEFAULT ,
				  DBName VARCHAR(100) COLLATE DATABASE_DEFAULT ,
				  SchemaName VARCHAR(1000) COLLATE DATABASE_DEFAULT ,
				  TableName VARCHAR(1000) COLLATE DATABASE_DEFAULT ,
				  IndexName VARCHAR(1000) COLLATE DATABASE_DEFAULT ,
				  database_id SMALLINT NULL ,
				  object_id INT NULL ,
				  index_id INT NULL ,
				  partition_number INT NULL ,
				  index_type_desc NVARCHAR(60) COLLATE DATABASE_DEFAULT NULL ,
				  alloc_unit_type_desc NVARCHAR(60) COLLATE DATABASE_DEFAULT NULL ,
				  index_depth TINYINT NULL ,
				  index_level TINYINT NULL ,
				  avg_fragmentation_in_percent FLOAT NULL ,
				  fragment_count BIGINT NULL ,
				  avg_fragment_size_in_pages FLOAT NULL ,
				  page_count BIGINT NULL ,
				  avg_page_space_used_in_percent FLOAT NULL ,
				  record_count BIGINT NULL ,
				  ghost_record_count BIGINT NULL ,
				  version_ghost_record_count BIGINT NULL ,
				  min_record_size_in_bytes INT NULL ,
				  max_record_size_in_bytes INT NULL ,
				  avg_record_size_in_bytes FLOAT NULL ,
				  forwarded_record_count BIGINT NULL -- ,
                  --compressed_page_count bigint NULL
                )
--We're going to cursor through and get the frag stats for all the indexes we want.
--We're doing it at the index level so each table and maybe each index some day
--can have it's own ScanMode.



------------------BEGIN Log Status---------------------------------

			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0

					UPDATE	Minion.IndexMaintLog
					SET		Status = 'Gathering Fragmentation Stats'
					WHERE	ExecutionDateTime = @ExecutionDateTime
							AND DBName = @DBName

				END --@StmtOnly = 0

------------------END Log Status---------------------------------




			DECLARE FragStats CURSOR READ_ONLY
			FOR
				SELECT	TableID ,
						SchemaName ,
						TableName ,
						IndexName AS IndexName ,
						IndexID AS IndexID ,
						ONLINEopt
				FROM	#IndexName

			OPEN FragStats

			FETCH NEXT FROM FragStats INTO @currTableID, @currSchemaName,
				@currTableName, @currIndexName, @currIndexID, @currONLINEopt
	
			WHILE ( @@fetch_Status <> -1 ) 
				BEGIN -- Begin Cursor Loop

	----Placeholder for index-level ops.
		--If @FragTableCtrl = @currTable	
		--	BEGIN
		--	END

					IF @FragTableCtrl <> @currTableName 
						BEGIN --@FragTableCtrl <> @currTable


-------Table override values-------------
--These are options for the individual table.  Use this if you don't want to use the defaults or DB level values.
--If you manage even 1 option at this level they all have to be managed here.  That means you have to duplicate the 
--threshold, indexscanmode, etc that you want to be used here.

							UPDATE	ITF
							SET		ITF.ReorgThreshold = IMD.ReorgThreshold ,
									ITF.RebuildThreshold = IMD.RebuildThreshold ,
									ITF.FILLFACTORopt = IMD.FILLFACTORopt ,
									ITF.PadIndex = IMD.PadIndex ,
									ITF.ONLINEopt = IMD.ONLINEopt ,
									ITF.SortInTempDB = IMD.SortInTempDB ,
									ITF.MAXDOPopt = IMD.MAXDOPopt ,
									ITF.DataCompression = IMD.DataCompression ,
									ITF.GetRowCT = IMD.GetRowCT ,
									ITF.GetPostFragLevel = IMD.GetPostFragLevel ,
									ITF.UpdateStatsOnDefrag = IMD.UpdateStatsOnDefrag ,
									ITF.StatScanOption = IMD.StatScanOption ,
									ITF.IgnoreDupKey = IMD.IgnoreDupKey ,
									ITF.StatsNoRecompute = IMD.StatsNoRecompute ,
									ITF.AllowRowLocks = IMD.AllowRowLocks ,
									ITF.AllowPageLocks = IMD.AllowPageLocks ,
									ITF.WaitAtLowPriority = IMD.WaitAtLowPriority ,
									ITF.MaxDurationInMins = IMD.MaxDurationInMins ,
									ITF.AbortAfterWait = IMD.AbortAfterWait ,
									ITF.LogProgress = IMD.LogProgress ,
									ITF.LogRetDays = IMD.LogRetDays ,
									ITF.PushToMinion = IMD.PushToMinion ,
									ITF.LogIndexPhysicalStats = IMD.LogIndexPhysicalStats ,
									ITF.IndexScanMode = IMD.IndexScanMode ,
									ITF.TablePreCode = IMD.TablePreCode ,
									ITF.TablePostCode = IMD.TablePostCode ,
									ITF.ReindexGroupOrder = IMD.ReindexGroupOrder ,
									ITF.ReindexOrder = IMD.ReindexOrder ,
									ITF.StmtPrefix = IMD.StmtPrefix ,
									ITF.StmtSuffix = IMD.StmtSuffix
							FROM	Minion.IndexTableFrag ITF
									      INNER JOIN Minion.IndexSettingsTable IMD 
											ON ITF.DBName = IMD.DBName
											AND ITF.TableName = IMD.TableName
											AND ITF.SchemaName = IMD.SchemaName

							WHERE	IMD.DBName = @DBName
									AND ITF.ExecutionDateTime = @ExecutionDateTime
									AND ITF.SchemaName = @currSchemaName
									AND ITF.TableName = @currTableName

						END --@FragTableCtrl <> @currTable

----------END Get Current Options-----------


---------------------------------------------------
--------------BEGIN Columnstore Settings-----------
---------------------------------------------------
--Some settings are incompatable with columnstore indexes.
--Therefore, they need to be set here if the table has any columnstore indexes on it.

--UPDATE ITF
--SET ITF.ONLINEopt = 'OFFLINE',
--	ITF.IgnoreDupKey = NULL

--FROM	Minion.IndexTableFrag ITF
--		INNER JOIN Minion.IndexTableFrag ITF2 ON ITF.DBName = ITF2.DBName
--WHERE	ITF2.DBName = @DBName
--		AND ITF.ExecutionDateTime = @ExecutionDateTime
--		AND ITF.SchemaName = @currSchemaName
--		AND ITF.TableName = @currTableName
--		AND ITF2.IndexTypeDesc LIKE '%COLUMNSTORE%'

---------------------------------------------------
--------------BEGIN Columnstore Settings-----------
---------------------------------------------------



------------------------------------------------------
------------BEGIN Get Index Frag Stats----------------
------------------------------------------------------

					SET @currIndexScanMode = ( SELECT TOP ( 1 )
														ISNULL(IndexScanMode,
															  'Limited') AS IndexScanMode -- Change NULL to Limited for logging purposes.  I don't like seeing NULL in the log if I can help it.
											   FROM		Minion.IndexTableFrag
											   WHERE	DBName = @DBName
														AND ExecutionDateTime = @ExecutionDateTime
														AND SchemaName = @currSchemaName
														AND TableID = @currTableID
														AND IndexID = @currIndexID
											 )

					--UPDATE Minion.IndexTableFrag
					--SET IndexScanMode = @currIndexScanMode
					--WHERE	DBName = @DBName
					--AND ExecutionDateTime = @ExecutionDateTime
					--AND SchemaName = @currSchemaName
					--AND TableID = @currTableID
					--AND IndexID = @currIndexID

------------------BEGIN Log Status---------------------------------

					IF @StmtOnly = 0 
						BEGIN --@StmtOnly = 0

							IF @LogProgress = 1 
								BEGIN --@LogProgress = 1
									SET @FragLogCtr = @FragLogCtr + 1

									--If @PrepOnly = 0
										--Begin --@PrepOnly = 0

											UPDATE	Minion.IndexMaintLogDetails
											SET		Status = CAST(@FragLogCtr AS VARCHAR(10))
													+ ' of '
													+ CAST(@FragLogTotalCtr AS VARCHAR(10))
													+ ': GATHERING FRAG STATS: '
													+ @currSchemaName + '.'
													+ @currTableName + '.'
													+ @currIndexName
											WHERE	ExecutionDateTime = @ExecutionDateTime
													AND DBName = @DBName

										--End --@PrepOnly = 0
								END --@LogProgress = 1
						END --@StmtOnly = 0

------------------END Log Status---------------------------------




----This just makes the below insert easier to read.
					SET @currIndexForFragStats = '[' + @DBName + ']' + '.'
						+ '[' + @currSchemaName + ']' + '.' + '[' + @currTableName + ']'

					INSERT	#IndexPhysicalStats
							( ExecutionDateTime ,
							  IndexScanMode ,
							  DBName ,
							  SchemaName ,
							  TableName ,
							  IndexName ,
							  database_id ,
							  object_id ,
							  index_id ,
							  partition_number ,
							  index_type_desc ,
							  alloc_unit_type_desc ,
							  index_depth ,
							  index_level ,
							  avg_fragmentation_in_percent ,
							  fragment_count ,
							  avg_fragment_size_in_pages ,
							  page_count ,
							  avg_page_space_used_in_percent ,
							  record_count ,
							  ghost_record_count ,
							  version_ghost_record_count ,
							  min_record_size_in_bytes ,
							  max_record_size_in_bytes ,
							  avg_record_size_in_bytes ,
							  forwarded_record_count--, compressed_page_count
 							)
							SELECT	@ExecutionDateTime ,
									@currIndexScanMode ,
									@DBName ,
									@currSchemaName ,
									@currTableName ,
									@currIndexName ,
									database_id ,
									object_id ,
									index_id ,
									partition_number ,
									index_type_desc ,
									alloc_unit_type_desc ,
									index_depth ,
									index_level ,
									avg_fragmentation_in_percent ,
									fragment_count ,
									avg_fragment_size_in_pages ,
									page_count ,
									avg_page_space_used_in_percent ,
									record_count ,
									ghost_record_count ,
									version_ghost_record_count ,
									min_record_size_in_bytes ,
									max_record_size_in_bytes ,
									avg_record_size_in_bytes ,
									forwarded_record_count--, compressed_page_count
							FROM	sys.dm_db_index_physical_stats(DB_ID(@DBName),
															  OBJECT_ID(@currIndexForFragStats),
															  @currIndexID,
															  NULL,
															  @currIndexScanMode) 					

--SELECT '#IndexPhysStats', * FROM #IndexPhysicalStats
------------------------------------------------------
------------END Get Index Frag Stats------------------
------------------------------------------------------


------------BEGIN Log IndexPhysicalStats-------------

--The purpose of logging this is to get the raw stats for all indexes.
--Therefore, the data is logged whether or not the index will have any
--run against it.  This data is for analysis should you need it.

					SET @currLogIndexPhysicalStats = ( SELECT TOP ( 1 )
															  LogIndexPhysicalStats
													   FROM	  Minion.IndexTableFrag
													   WHERE  DBName = @DBName
															  AND TableName = @currTableName
															  AND IndexName = @currIndexName
															  AND ExecutionDateTime = @ExecutionDateTime
													 );

					IF @currLogIndexPhysicalStats = 1
						AND @StmtOnly <> 1 
						BEGIN
							INSERT	Minion.IndexPhysicalStats
									( ExecutionDateTime ,
									  IndexScanMode ,
									  DBName ,
									  SchemaName ,
									  TableName ,
									  IndexName ,
									  database_id ,
									  object_id ,
									  index_id ,
									  partition_number ,
									  index_type_desc ,
									  alloc_unit_type_desc ,
									  index_depth ,
									  index_level ,
									  avg_fragmentation_in_percent ,
									  fragment_count ,
									  avg_fragment_size_in_pages ,
									  page_count ,
									  avg_page_space_used_in_percent ,
									  record_count ,
									  ghost_record_count ,
									  version_ghost_record_count ,
									  min_record_size_in_bytes ,
									  max_record_size_in_bytes ,
									  avg_record_size_in_bytes ,
									  forwarded_record_count --,
                                      --compressed_page_count
                                    )
									SELECT	ExecutionDateTime ,
											IndexScanMode ,
											DBName ,
											SchemaName ,
											TableName ,
											IndexName ,
											database_id ,
											object_id ,
											index_id ,
											partition_number ,
											index_type_desc ,
											alloc_unit_type_desc ,
											index_depth ,
											index_level ,
											avg_fragmentation_in_percent ,
											fragment_count ,
											avg_fragment_size_in_pages ,
											page_count ,
											avg_page_space_used_in_percent ,
											record_count ,
											ghost_record_count ,
											version_ghost_record_count ,
											min_record_size_in_bytes ,
											max_record_size_in_bytes ,
											avg_record_size_in_bytes ,
											forwarded_record_count --,
                                      --compressed_page_count
									FROM	#IndexPhysicalStats
						END

------------END Log IndexPhysicalStats---------------

-----------------------------------------------------
------BEGIN DELETE Unwanted index levels-------------
-----------------------------------------------------

--If it's a clustered index we're really only interested in the base level, which is 0.
--So we delete the rest of the levels and we're only going to compare the frag level
--against level 0.
					IF @currIndexScanMode = 'Detailed' 
						BEGIN
							DELETE	#IndexPhysicalStats
							WHERE	index_id = 1
									AND index_level > 0
						END

-----------------------------------------------------
------END DELETE Unwanted index levels---------------
-----------------------------------------------------

-----------------------------------------------------
------BEGIN Add Frag % to Minion.IndexTableFrag------
-----------------------------------------------------

--We're only taking the max fragmented of all the index levels.
--Different levels of the index will have different frag levels.  We have to measure against something, so we're using the max of all the levels for the index.
--The #IndexPhysicalStats table holds all of the stats for the different levels of the index.  So we're updating the Minion.IndexTableFrag table to reflect that max frag level we want.
					UPDATE	ITF
					SET		ITF.avg_fragmentation_in_percent = IPS.avg_fragmentation_in_percent ,
							ITF.DBID = IPS.database_id
					FROM	Minion.IndexTableFrag ITF
							INNER JOIN #IndexPhysicalStats IPS ON ITF.TableID = IPS.object_id
															  AND ITF.IndexID = IPS.index_id
															  AND ITF.ExecutionDateTime = @ExecutionDateTime
															  AND IPS.avg_fragmentation_in_percent IN (
															  SELECT
															  MAX(IPS.avg_fragmentation_in_percent)
															  FROM
															  #IndexPhysicalStats IPS
															  INNER JOIN Minion.IndexTableFrag ITF ON ITF.DBName = IPS.DBName 
															  AND ITF.TableID = IPS.object_id
															  AND ITF.IndexID = IPS.index_id
															  AND ITF.ExecutionDateTime = @ExecutionDateTime )


-----------------------------------------------------
------END Add Frag % to Minion.IndexTableFrag--------
-----------------------------------------------------

--Clear the table for the next index.
					TRUNCATE TABLE #IndexPhysicalStats

----Set the ctrl var that's used to tell when we've switched tables in the cursor.
					SET @FragTableCtrl = @currTableName;

					FETCH NEXT FROM FragStats INTO @currTableID,
						@currSchemaName, @currTableName, @currIndexName,
						@currIndexID, @currONLINEopt

				END -- End Cursor Loop

			CLOSE FragStats
			DEALLOCATE FragStats


-----------------------------------------------------------------------------------
------------END Frag Stats Cursor--------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


------------------BEGIN Log Status---------------------------------

			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0

					IF @LogProgress = 1 
						BEGIN --@LogProgress = 1
				
							--If @PrepOnly = 0
								--Begin --@PrepOnly = 0
							IF @ErrMsg IS NULL
							BEGIN --@ErrMsg IS NULL
									UPDATE	Minion.IndexMaintLogDetails
									SET		Status = 'Prepping Minion tables'
									WHERE	ExecutionDateTime = @ExecutionDateTime
											AND DBName = @DBName
							END --@ErrMsg IS NULL
								--End --@PrepOnly = 0
						END --@LogProgress = 1
				END --@StmtOnly = 0

------------------END Log Status---------------------------------


--------------------------------------------------------------
--------------BEGIN Delete Indexes Below Threshold------------
--------------------------------------------------------------
--Logically speaking, the reorgThreshold should always be lower than the rebuildThreshold since you would never
--do a reorg Op if you did a full rebuild before you even got to it.  So using the reorgThreshold as the metric
--to delete tables from the process is appropriate.

			DELETE	Minion.IndexTableFrag
			WHERE	avg_fragmentation_in_percent < ReorgThreshold
					AND ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName;

----If it's rebuild mode, then we need to delete everything below the rebuildthreshold.
IF @ReorgMode = 'Rebuild'
	BEGIN
			DELETE	Minion.IndexTableFrag
			WHERE	avg_fragmentation_in_percent < RebuildThreshold
					AND ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName;		
	END

--------------------------------------------------------------
--------------END Delete Indexes Below Threshold--------------
--------------------------------------------------------------



--------------------------------------------------------------
--------------BEGIN Set Default Index Order-------------------
--------------------------------------------------------------

			UPDATE	Minion.IndexTableFrag
			SET		ReindexGroupOrder = 0
			WHERE	ReindexGroupOrder IS NULL
					AND ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName


			UPDATE	Minion.IndexTableFrag
			SET		ReindexOrder = 0
			WHERE	ReindexOrder IS NULL
					AND ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName

--------------------------------------------------------------
--------------END Set Default Index Order---------------------
--------------------------------------------------------------

 
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Get Index Fragmentation--------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


		END-- @RunPrepped = 0 OR @PrepOnly = 1

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Prep Save--------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


	IF @PrepOnly = 0 AND @RunPrepped = 0
		BEGIN

	------------Set Prepped flag------------
	----This flag is used to keep from confusing prepped loads with unprepped loads.
			UPDATE	Minion.IndexTableFrag
			SET		Prepped = 0
			WHERE	ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName

		END


	IF @PrepOnly = 1 
		BEGIN

--Since this option only preps the index frag stats, that's all we're
--interested in.  So no further processing is needed.  
--We can end the SP here.


------------Set Prepped flag------------
----This flag is used to keep from confusing prepped loads with unprepped loads.
			UPDATE	Minion.IndexTableFrag
			SET		Prepped = 1
			WHERE	ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName


			UPDATE	Minion.IndexMaintLog
			SET		Status = 'Complete',
					ExecutionFinishTime = GETDATE(),
					ExecutionRunTimeInSecs = DATEDIFF(s,
														CONVERT(VARCHAR(25), @ExecutionDateTime, 21),
														CONVERT(VARCHAR(25), GETDATE(), 21)) 
			WHERE	ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName

			UPDATE	Minion.IndexMaintLogDetails
			SET		Status = 'Complete. ' + CAST(@FragLogCtr AS VARCHAR(10))
					+ ' of '
					+ CAST(@FragLogTotalCtr AS VARCHAR(10))
					+ ' Frag Stats Gathered. '
			WHERE	ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName

			RETURN;

		END

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Prep Save----------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Finalize Index Options-------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

--Use a @Table for this because it's filled from dynamic sql and this is the easiest
--way to get the data into a var.      
	DECLARE	@PostFragVar TABLE ( col1 INT );




-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Finalize Index Options---------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------Begin Initial Log Entry------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

----Put all the indexes to be done along with the table info into the log table.
----This is how you're going to tell how long you have to go before the job is finished.
----If you can see all the indexes it's expecting to do then you can make a good decision
----on whether to stop it if you need to.  But this step is essential to that goal because
----before you even start to reindex/reorg you need to have that complete list.

	IF @StmtOnly = 0 
		BEGIN --@StmtOnly = 0

			IF @PrepOnly = 0
				BEGIN --@PrepOnly = 0

					DELETE	Minion.IndexMaintLogDetails
					WHERE	ExecutionDateTime = @ExecutionDateTime
							AND DBName = @DBName;

IF @RunPrepped = 0
	BEGIN --@RunPrepped = 0

					INSERT	Minion.IndexMaintLogDetails
							( ExecutionDateTime ,
							  Status ,
							  DBName ,
							  TableID ,
							  SchemaName ,
							  TableName ,
							  IndexID ,
							  IndexName ,
							  IndexTypeDesc ,
							  IndexScanMode ,
							  ONLINEopt ,
							  ReorgThreshold ,
							  RebuildThreshold ,
							  FILLFACTORopt ,
							  PadIndex ,
							  ReindexGroupOrder ,
							  ReindexOrder
							)
							SELECT	@ExecutionDateTime ,
									'In Queue' ,
									@DBName ,
									TableID ,
									SchemaName ,
									TableName ,
									IndexID ,
									IndexName ,
									IndexTypeDesc ,
									IndexScanMode ,
									ONLINEopt ,
									ReorgThreshold ,
									RebuildThreshold ,
									FILLFACTORopt ,
									PadIndex ,
									ReindexGroupOrder ,
									ReindexOrder
							FROM	Minion.IndexTableFrag
							WHERE	ExecutionDateTime = @ExecutionDateTime
									AND DBName = @DBName
							ORDER BY ReindexGroupOrder DESC ,
									ReindexOrder DESC

	END --@RunPrepped = 0


IF @RunPrepped = 1
	BEGIN --@RunPrepped = 1

					INSERT	Minion.IndexMaintLogDetails
							( ExecutionDateTime ,
							  Status ,
							  DBName ,
							  TableID ,
							  SchemaName ,
							  TableName ,
							  IndexID ,
							  IndexName ,
							  IndexTypeDesc ,
							  IndexScanMode ,
							  ONLINEopt ,
							  ReorgThreshold ,
							  RebuildThreshold ,
							  FILLFACTORopt ,
							  PadIndex ,
							  ReindexGroupOrder ,
							  ReindexOrder
							)
							SELECT	@ExecutionDateTime ,
									'In Queue' ,
									@DBName ,
									TableID ,
									SchemaName ,
									TableName ,
									IndexID ,
									IndexName ,
									IndexTypeDesc ,
									IndexScanMode ,
									ONLINEopt ,
									ReorgThreshold ,
									RebuildThreshold ,
									FILLFACTORopt ,
									PadIndex ,
									ReindexGroupOrder ,
									ReindexOrder
							FROM	Minion.IndexTableFrag
							WHERE	DBName = @DBName
									AND ExecutionDateTime IN (SELECT MAX(ExecutionDateTime) FROM Minion.IndexTableFrag WHERE DBName = @DBName AND Prepped = 1)
									AND Prepped = 1
							ORDER BY ReindexGroupOrder DESC ,
									ReindexOrder DESC

	END --@RunPrepped = 1


				END --@PrepOnly = 0
		END --@StmtOnly = 0

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Initial Log Entry--------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Get Row Count---------------------------------------------------- 
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 

--!!!-- Need to inner join to make sure we only get rowcounts for those that WANT rowcounts!!
--!!!-- For now, going the easy route: update everything and let dog sort it out.  -J.M. 9/23/2014


------------------BEGIN Log Status---------------------------------

      	IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0 

	IF @LogProgress = 1 
		BEGIN --@LogProgress = 1

IF @ErrMsg IS NULL
BEGIN --@ErrMsg IS NULL
			UPDATE	Minion.IndexMaintLogDetails
			SET		Status = 'Getting table row count'
			WHERE	ExecutionDateTime = @ExecutionDateTime
									----AND DBName = @DBName
									----AND SchemaName = @currSchemaName
									----AND TableName = @currTableName
									----AND IndexName = @currIndexName
END --@ErrMsg IS NULL
		END --@LogProgress = 1

		END --@PrepOnly = 0

------------------END Log Status---------------------------------
	IF @StmtOnly = 0 
		BEGIN
			SET @RowCTBeginDateTime = GETDATE();

		-- Run a dynamic sql statement once for every DB in the current @ExecutionDateTime:
			CREATE TABLE #RowCount
				(
				  DBName VARCHAR(100) COLLATE DATABASE_DEFAULT NULL ,
				  TableID BIGINT NULL ,
				  IndexID BIGINT NULL ,
				  TableRowCT BIGINT NULL
				);


			DECLARE RowCT CURSOR READ_ONLY
			FOR
				SELECT  DISTINCT
						DBName
				FROM	Minion.IndexMaintLogDetails IML
				WHERE	ExecutionDateTime = @ExecutionDateTime;

			OPEN RowCT

			FETCH NEXT FROM RowCT INTO @DBName
	
			WHILE ( @@fetch_Status <> -1 ) 
				BEGIN -- Begin Cursor Loop

					SET @RowCTSQL = 'SELECT	''' + @DBName + ''' AS DBName ,
			IML.TableID,
			IML.IndexID,
			SUM(PS.row_count) AS TableRowCT
	FROM	Minion.IndexMaintLogDetails IML
			INNER JOIN [' + @DBName
						+ '].sys.dm_db_partition_stats AS PS ON IML.TableID = PS.OBJECT_ID
															AND IML.IndexID = PS.index_id
			INNER JOIN [' + @DBName
						+ '].sys.objects o ON IML.TableID = o.OBJECT_ID
			INNER JOIN [' + @DBName
						+ '].sys.schemas s ON o.schema_id = s.schema_id
	WHERE IML.ExecutionDateTime = '''
						+ CONVERT(VARCHAR(50), @ExecutionDateTime, 109) + '''
		AND IML.DBName = ''' + @DBName + '''
	GROUP BY IML.TableID ,
			IML.IndexID';
			


					INSERT	INTO #RowCount
							( DBName ,
							  TableID ,
							  IndexID ,
							  TableRowCT
							)
							EXEC ( @RowCTSQL
								);

					FETCH NEXT FROM RowCT INTO @DBName
				END

			CLOSE RowCT;
			DEALLOCATE RowCT;


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Row CT Log------------------------------------------------------- 
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 
					
			SET @RowCTEndDateTime = GETDATE();

						-------------------
						----BEGIN RUN------
						-------------------	
						
			WITH	rowCountCTE
					  AS ( SELECT	SUM(TableRowCT) AS TableRowCT ,
									DBName ,
									TableID ,
									IndexID
						   FROM		#RowCount
						   GROUP BY	DBName ,
									TableID ,
									IndexID
						 )
				UPDATE	IML
				SET		TableRowCTBeginDateTime = CONVERT(VARCHAR(25), @RowCTBeginDateTime, 21) ,
						TableRowCTEndDateTime = CONVERT(VARCHAR(25), @RowCTEndDateTime, 21) ,
						TableRowCTTimeInSecs = DATEDIFF(s,
														CONVERT(VARCHAR(25), @RowCTBeginDateTime, 21),
														CONVERT(VARCHAR(25), @RowCTEndDateTime, 21)) ,
						IML.TableRowCT = RC.TableRowCT
				FROM	Minion.IndexMaintLogDetails IML
						INNER JOIN rowCountCTE AS RC ON IML.DBName = RC.DBName
														AND IML.TableID = RC.TableID
														AND IML.IndexID = RC.IndexID
				WHERE	IML.ExecutionDateTime = @ExecutionDateTime

			DROP TABLE #RowCount;


		END --IF @StmtOnly = 0 
						-------------------
						----END RUN--------
						-------------------	
								
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Row CT Log------------------------------------------------------- 
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 		


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Get Row Count---------------------------------------------------- 
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 



------------------BEGIN Log Status---------------------------------

	IF @StmtOnly = 0 
		BEGIN --@StmtOnly = 0

			UPDATE	Minion.IndexMaintLog
			SET		Status = 'Processing Tables'
			WHERE	ExecutionDateTime = @ExecutionDateTime
					AND DBName = @DBName

		END --@StmtOnly = 0

------------------END Log Status---------------------------------



-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------Begin Reindex Stmt Cursor----------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------
------------------------------------BEGIN Insert #TableFrag-----------------------------------------------
----------------------------------------------------------------------------------------------------------
--Since we allow to run prepped, we have to have a common table here for the cursor.
--So we put into a #table and run the cursor off of that.
	
IF @RunPrepped = 0
BEGIN

INSERT #TableFrag
SELECT			
	  ExecutionDateTime,
      DBName,
      DBID,
      TableID,
      SchemaName,
      TableName,
      IndexName,
      IndexID,
      IndexType,
      IndexTypeDesc,
      IsDisabled,
      IsHypothetical,
      avg_fragmentation_in_percent,
      ReorgThreshold,
      RebuildThreshold,
      FILLFACTORopt,
      PadIndex,
      ONLINEopt,
      SortInTempDB,
      MAXDOPopt,
      DataCompression,
      GetRowCT,
      GetPostFragLevel,
      UpdateStatsOnDefrag,
      StatScanOption,
      IgnoreDupKey,
      StatsNoRecompute,
      AllowRowLocks,
      AllowPageLocks,
      WaitAtLowPriority,
      MaxDurationInMins,
      AbortAfterWait,
      LogProgress,
      LogRetDays,
      PushToMinion,
      LogIndexPhysicalStats,
      IndexScanMode,
      TablePreCode,
      TablePostCode,
      Prepped,
      ReindexGroupOrder,
      ReindexOrder,
	  StmtPrefix,
	  StmtSuffix
		FROM	Minion.IndexTableFrag
		WHERE	DBName = @DBName
				AND ExecutionDateTime = @ExecutionDateTime
		ORDER BY ReindexGroupOrder DESC ,
				ReindexOrder DESC

END

IF @RunPrepped = 1
	BEGIN

INSERT #TableFrag
SELECT			
	  ExecutionDateTime,
      DBName,
      DBID,
      TableID,
      SchemaName,
      TableName,
      IndexName,
      IndexID,
      IndexType,
      IndexTypeDesc,
      IsDisabled,
      IsHypothetical,
      avg_fragmentation_in_percent,
      ReorgThreshold,
      RebuildThreshold,
      FILLFACTORopt,
      PadIndex,
      ONLINEopt,
      SortInTempDB,
      MAXDOPopt,
      DataCompression,
      GetRowCT,
      GetPostFragLevel,
      UpdateStatsOnDefrag,
      StatScanOption,
      IgnoreDupKey,
      StatsNoRecompute,
      AllowRowLocks,
      AllowPageLocks,
      WaitAtLowPriority,
      MaxDurationInMins,
      AbortAfterWait,
      LogProgress,
      LogRetDays,
      PushToMinion,
      LogIndexPhysicalStats,
      IndexScanMode,
      TablePreCode,
      TablePostCode,
      Prepped,
      ReindexGroupOrder,
      ReindexOrder,
	  StmtPrefix,
	  StmtSuffix 
		FROM	Minion.IndexTableFrag
		WHERE	DBName = @DBName
				AND ExecutionDateTime IN (SELECT MAX(ExecutionDateTime) FROM Minion.IndexTableFrag WHERE DBName = @DBName AND Prepped = 1)
				AND Prepped = 1
		ORDER BY ReindexGroupOrder DESC ,
				ReindexOrder DESC

END

----------------------------------------------------------------------------------------------------------
------------------------------------END Insert #TableFrag-------------------------------------------------
----------------------------------------------------------------------------------------------------------
	
	DECLARE Tables CURSOR READ_ONLY
	FOR
		SELECT	TableID ,
				SchemaName ,
				TableName ,
				IndexName ,
				IndexID ,
				IndexType ,
				IndexTypeDesc ,
				avg_fragmentation_in_percent ,
				ReorgThreshold ,
				RebuildThreshold ,
				FILLFACTORopt ,
				PadIndex ,
				ONLINEopt ,
				SortInTempDB ,
				MAXDOPopt ,
				DataCompression ,
				GetRowCT ,
				GetPostFragLevel ,
				UpdateStatsOnDefrag ,
				StatScanOption ,
				IgnoreDupKey ,
				StatsNoRecompute ,
				AllowRowLocks ,
				AllowPageLocks ,
				WaitAtLowPriority ,
				MaxDurationInMins ,
				AbortAfterWait ,
				LogProgress ,
				LogRetDays ,
				PushToMinion ,
				LogIndexPhysicalStats ,
				IndexScanMode ,
				TablePreCode ,
				TablePostCode ,
				StmtPrefix,
				StmtSuffix
		FROM	#TableFrag
		ORDER BY ReindexGroupOrder DESC ,
				ReindexOrder DESC

	OPEN Tables

	FETCH NEXT FROM Tables INTO @currTableID, @currSchemaName, @currTableName,
		@currIndexName, @currIndexID, @currIndexType, @currIndexTypeDesc,
		@currFragLevel, @currReorgThreshold, @currRebuildThreshold,
		@currFILLFACTORopt, @currPadIndex, @currONLINEopt, @currSortInTempDB,
		@currMAXDOPopt, @currDataCompression, @currGetRowCT,
		@currGetPostFragLevel, @currUpdateStatsOnDefrag, @currStatScanOption,
		@currIgnoreDupKey, @currStatsNoRecompute, @currAllowRowLocks,
		@currAllowPageLocks, @currWaitAtLowPriority, @currMaxDurationInMins,
		@currAbortAfterWait, @currLogProgress, @currLogRetDays,
		@currPushToMinion, @currLogIndexPhysicalStats, @currIndexScanMode,
		@currTablePreCode, @currTablePostCode, @currStmtPrefix, @currStmtSuffix
	
	WHILE ( @@fetch_Status <> -1 ) 
		BEGIN -- Begin Cursor Loop

SET @ErrMsg = NULL;
SET @ReindexSQL = '';
IF @TableCtrl <> @currTableName
BEGIN
SET @currTableIterator = 1
END
IF @TableCtrl = @currTableName
BEGIN
SET @currTableIterator = @currTableIterator + 1
END
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Call Log--------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

--Log the call of the Op.  This is done just before the reindex/reorg is actually started.

			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0 
  					IF @PrepOnly = 0
						BEGIN --@PrepOnly = 0 
						     
							UPDATE	Minion.IndexMaintLogDetails
							SET		FragLevel = CAST(@currFragLevel AS DECIMAL(3, 0)) ,
									IndexTypeDesc = @currIndexTypeDesc
							WHERE	ExecutionDateTime = CONVERT(VARCHAR(25), @ExecutionDateTime, 21)
									AND DBName = @DBName
									AND SchemaName = @currSchemaName
									AND TableName = @currTableName
									AND IndexName = @currIndexName;

						END --@PrepOnly = 0 
				END --@StmtOnly = 0 

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Call Log----------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

IF @TableCtrl <> @currTableName
BEGIN

SET @TableCT = (SELECT COUNT(*) FROM #TableFrag WHERE TableName = @currTableName)

END
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Reindex Stmt Build----------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

SET @ReindexSQL = '';

-- If you're in REORG mode you won't be able to do REBUILD at all, but the conditions for REORG change.
-- If the REORG moce is 'REORG' then you're interested in indexes that are greater than @currReorgThreshold.
-- So since it's REORG mode then even the ones that would ordinarily be rebuilt are reorged.
-- Therefore you need 2 sets of criteria here.  The one for REORG mode uses the 1 set of criteria for the decision,
-- while the 'All' mode uses both @currReorgThreshold and @currRebuildThreshold.

			IF @ReorgMode <> 'REBUILD' 
				BEGIN  --@ReorgMode <> 'REBUILD' 
 
					IF @ReorgMode = 'REORG' 
						BEGIN -- @ReorgMode = 'REORG'
							IF CAST(@currFragLevel AS DECIMAL(3, 0)) >= @currReorgThreshold 
								BEGIN -- REORG Mode
					 
									SET @ReindexSQL = 'USE [' + @DBName
										+ ']; ' + ISNULL(@currStmtPrefix, '') + 'ALTER INDEX [' + @currIndexName
										+ '] ON [' + @currSchemaName + '].['
										+ @currTableName + '] REORGANIZE'
									SET @currOP = 'Reorg'
								END -- REORG Mode  
						END -- @ReorgMode = 'REORG'

					IF @ReorgMode = 'All' 
						BEGIN -- @ReorgMode = 'All'
							IF CAST(@currFragLevel AS DECIMAL(3, 0)) >= @currReorgThreshold
								AND CAST(@currFragLevel AS DECIMAL(3, 0)) < @currRebuildThreshold 
								BEGIN -- Reorg Mode
					 
									SET @ReindexSQL = 'USE [' + @DBName
										+ ']; ' + ISNULL(@currStmtPrefix, '') + 'ALTER INDEX [' + @currIndexName
										+ '] ON [' + @currSchemaName + '].['
										+ @currTableName + '] REORGANIZE'
									SET @currOP = 'Reorg'
								END -- Reorg Mode
						END -- @ReorgMode = 'All'
				END  --@ReorgMode <> 'REBUILD'  


			IF @ReorgMode <> 'REORG' 
				BEGIN  --@ReorgMode <> 'REORG'   
					IF CAST(@currFragLevel AS DECIMAL(3, 0)) >= @currRebuildThreshold 
						BEGIN -- @currFragLevel AS DECIMAL(3, 0)) >= @currRebuildThreshold

							IF @currFILLFACTORopt IS NOT NULL 
								SET @currFILLFACTORopt = 'FILLFACTOR = '
									+ @currFILLFACTORopt;

							IF @currPadIndex IS NOT NULL 
								SET @currPadIndex = ', PAD_INDEX = '
									+ @currPadIndex;
                           

							IF @currSortInTempDB IS NOT NULL 
								SET @currSortInTempDB = ', SORT_IN_TEMPDB = '
									+ @currSortInTempDB;
                           

							IF @currMAXDOPopt IS NOT NULL 
								SET @currMAXDOPopt = ', MAXDOP = '
									+ @currMAXDOPopt;
                           

							IF @currDataCompression IS NOT NULL 
								SET @currDataCompression = ', DATA_COMPRESSION = '
									+ @currDataCompression;
                           

							IF @currIgnoreDupKey IS NOT NULL 
								SET @currIgnoreDupKey = ', IGNORE_DUP_KEY = '
									+ @currIgnoreDupKey;
                           

							IF @currStatsNoRecompute IS NOT NULL 
								SET @currStatsNoRecompute = ', STATISTICS_NORECOMPUTE = '
									+ @currStatsNoRecompute;
                           

							IF @currAllowRowLocks IS NOT NULL 
								SET @currAllowRowLocks = ', ALLOW_ROW_LOCKS = '
									+ @currAllowRowLocks;
                           

							IF @currAllowPageLocks IS NOT NULL 
								SET @currAllowPageLocks = ', ALLOW_PAGE_LOCKS = '
									+ @currAllowPageLocks;
 
					----Set wait priority for SQL Server 2014 and above.
					----If MaxDurationInMins is NULL then we set it to 0.
					----If AbortAfterWait is NULL then we set it to NONE.    
					----!!! WaitPriority always has to stay above ONLINEopt because we have to eval it as ON before it gets turned into the flag itself.                   
							IF @Version >= '12' 
								BEGIN

									IF @currWaitAtLowPriority = 1 AND @currONLINEopt = 'ON'
										BEGIN
											DECLARE @currWaitAtLowPriorityTxt varchar(150);
										SET @currWaitAtLowPriorityTxt = ' (WAIT_AT_LOW_PRIORITY (MAX_DURATION = '
											+ CAST(ISNULL(@currMaxDurationInMins,
														  0) AS VARCHAR(10))
											+ ' MINUTES, ABORT_AFTER_WAIT = '
											+ ISNULL(@currAbortAfterWait,
													 'NONE') + '))'

										END

								END

							IF @currONLINEopt IS NOT NULL 
								SET @currONLINEopt = ', ONLINE = '
									+ @currONLINEopt;
                           
	
							SET @ReindexSQL = 'USE [' + @DBName
								+ ']; ' + ISNULL(@currStmtPrefix, '') + 'ALTER INDEX [' + @currIndexName
								+ '] ON [' + @currSchemaName + '].['
								+ @currTableName + '] ' + 'REBUILD WITH ('
								+ ISNULL(@currFILLFACTORopt, '')
								+ ISNULL(@currPadIndex, '')
								+ ISNULL(@currONLINEopt, '')
								+ ISNULL(@currWaitAtLowPriorityTxt, '')
								+ ISNULL(@currSortInTempDB, '')
								+ ISNULL(@currMAXDOPopt, '')
								+ ISNULL(@currDataCompression, '')
								+ ISNULL(@currIgnoreDupKey, '')
								+ ISNULL(@currStatsNoRecompute, '')
								+ ISNULL(@currAllowRowLocks, '')
								+ ISNULL(@currAllowPageLocks, '') + ')'

							SET @ReindexSQL = REPLACE(@ReindexSQL, 'WITH ()', '')
							SET @ReindexSQL = REPLACE(@ReindexSQL, 'WITH (, ', 'WITH (')
							SET @currOP = 'Rebuild'
						END -- @currFragLevel AS DECIMAL(3, 0)) >= @currRebuildThreshold

				END --@ReorgMode <> 'REORG' 


			IF @currIndexTypeDesc LIKE '%COLUMNSTORE%' 
				BEGIN

					SET @ReindexSQL = '';
					SET @ReindexSQL = 'USE [' + @DBName + ']; ' + ISNULL(@currStmtPrefix, '') + 'ALTER INDEX '
						+ @currIndexName + ' ON ' + @currSchemaName + '.'
						+ @currTableName + ' ' + 'REBUILD';

				END



			SET @ReindexSQL = @ReindexSQL + '; ' + ISNULL(@currStmtSuffix, '')

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Reindex Stmt Build------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------   


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Run or Print Reindex Stmt---------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------  

						-------------------
						----BEGIN PRINT----
						-------------------
			SET @OpBeginDateTime = GETDATE();
		
			IF @StmtOnly = 1 
				BEGIN --@StmtOnly = 1
					PRINT '------------------------------------------------------------------------------'
					PRINT '-------' + 'DB: ' + @DBName
					PRINT '-------' + 'Table: ' + @currSchemaName + '.'
						+ @currTableName
					PRINT '-------' + 'Index: ' + @currIndexName
					PRINT '-------' + 'Reorg Threshold: '
						+ @currReorgThreshold + '   Rebuid Threshold: '
						+ @currRebuildThreshold
					PRINT '-------' + 'Current Frag: ' + @currFragLevel
					PRINT @ReindexSQL;		
				END --@StmtOnly = 1
						-------------------
						----END PRINT------
						-------------------



-----------------------------------
-----------------------------------
--------BEGIN Table PreCode--------
-----------------------------------
-----------------------------------


			IF @StmtOnly = 0 
				BEGIN -- @StmtOnly = 0

					IF @TableCtrl <> @currTableName 
						BEGIN --TableCtrl

							IF @currTablePreCode IS NOT NULL 
								BEGIN --@currTablePreCode IS NOT NULL

									SET @TablePreCodeBeginDateTime = GETDATE();
							------------------BEGIN Log Status---------------------------------

										IF @StmtOnly = 0 
											BEGIN --@StmtOnly = 0

  										IF @PrepOnly = 0
											BEGIN --@PrepOnly = 0 

												IF @LogProgress = 1 
													BEGIN --@LogProgress = 1
														IF @currTablePreCode IS NOT NULL 
															BEGIN --@currTablePreCode IS NOT NULL

																UPDATE	Minion.IndexMaintLogDetails
																SET		Status = 'Running Table PreCode' ,
																		PreCode = @currTablePreCode ,
																		PreCodeBeginDateTime = @TablePreCodeBeginDateTime
																WHERE	ExecutionDateTime = @ExecutionDateTime
																		AND DBName = @DBName
																		AND SchemaName = @currSchemaName
																		AND TableName = @currTableName
																		AND IndexName = @currIndexName

															END  --@currTablePreCode IS NOT NULL
													END --@LogProgress = 1
												END --@PrepOnly = 0
											END --@StmtOnly = 0

							------------------END Log Status---------------------------------


							--------BEGIN Run Table PreCode----------

									EXEC (@currTablePreCode)

							--------END Run Table PreCode------------

									SET @TablePreCodeEndDateTime = GETDATE();

								END --@currTablePreCode IS NOT NULL

						END --TableCtrl
				END -- @StmtOnly = 0


-----------------------------------
-----------------------------------
--------END Table PreCode----------
-----------------------------------
-----------------------------------	


------------------BEGIN Log Status---------------------------------

			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0

  					IF @PrepOnly = 0
						BEGIN --@PrepOnly = 0 

							IF @LogProgress = 1 
								BEGIN --@LogProgress = 1

									UPDATE	Minion.IndexMaintLogDetails
									SET		Status = 'Processing index' ,
											Stmt = @ReindexSQL ,
											OpBeginDateTime = @OpBeginDateTime
									WHERE	ExecutionDateTime = @ExecutionDateTime
											AND DBName = @DBName
											AND SchemaName = @currSchemaName
											AND TableName = @currTableName
											AND IndexName = @currIndexName

								END --@LogProgress = 1

						END --@PrepOnly = 0
				END --@StmtOnly = 0

------------------END Log Status---------------------------------
					 
						-------------------
						----BEGIN RUN------
						-------------------


DECLARE @PreCMD varchar(2000),
		@TotalCMD varchar(2000);  
       
			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0

                    SET @PreCMD = 'sqlcmd -I -r 1 -S"' + @ServerInstance + CAST(@Port AS VARCHAR(6))
                    SET @TotalCMD = @PreCMD + '" -q "' + @ReindexSQL + '"' 

						--PRINT @TotalCMD

--WAITFOR DELAY '00:00:10'
					SET @ErrMsg = NULL;
                    INSERT #ReindexResults
                            (col1)
                            EXEC xp_cmdshell @TotalCMD;

                    DELETE FROM
                            #ReindexResults
                        WHERE
                            col1 IS NULL
							OR col1 LIKE '%Changed database context%';		

------------------------------------------------------------
-----------------BEGIN Error Var----------------------------
------------------------------------------------------------                   
                      SELECT @ErrMsg = STUFF((SELECT ' ' + col1 FROM #ReindexResults AS T1 ORDER BY T1.ID
                                            FOR XML PATH('')), 1, 1, '')
                        FROM
                            #ReindexResults AS T2;

						TRUNCATE TABLE #ReindexResults;
------------------------------------------------------------
-----------------END Error Var------------------------------
------------------------------------------------------------


----------------------------------------------------------------
----------------------------------------------------------------
----------------BEGIN Log Error---------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
					IF @ErrMsg IS NOT NULL
						BEGIN

							UPDATE	Minion.IndexMaintLogDetails
							SET		Status = 'FATAL ERROR: ' + @ErrMsg ,
									PostCode = @currTablePostCode ,
									PostCodeBeginDateTime = @TablePostCodeBeginDateTime
							WHERE	ExecutionDateTime = @ExecutionDateTime
									AND DBName = @DBName
									AND SchemaName = @currSchemaName
									AND TableName = @currTableName
									AND IndexName = @currIndexName

						END

----------------------------------------------------------------
----------------------------------------------------------------
----------------END Log Error-----------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
				END --@StmtOnly = 0        

			SET @OpEndDateTime = GETDATE();        
						-------------------
						----END RUN--------
						-------------------


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Run or Print Reindex Stmt------------------------------------------ Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------  



-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Log Reindex Op--------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------  


			IF @StmtOnly = 0 
				BEGIN --@StmtOnly = 0 

    				IF @PrepOnly = 0
					BEGIN --@PrepOnly = 0   
					    
							UPDATE	Minion.IndexMaintLogDetails
							SET		OpBeginDateTime = CONVERT(VARCHAR(25), @OpBeginDateTime, 21) ,
									OpEndDateTime = CONVERT(VARCHAR(25), @OpEndDateTime, 21) ,
									Op = @currOP ,
									Stmt = @ReindexSQL ,
									OpRunTimeInSecs = DATEDIFF(s,
															   CONVERT(VARCHAR(25), @OpBeginDateTime, 21),
															   CONVERT(VARCHAR(25), @OpEndDateTime, 21)) ,
									PreCode = @currTablePreCode ,
									PreCodeBeginDateTime = @TablePreCodeBeginDateTime ,
									PreCodeEndDateTime = @TablePreCodeEndDateTime ,
									PreCodeRunTimeInSecs = DATEDIFF(s,
																	CONVERT(VARCHAR(25), @TablePreCodeBeginDateTime, 21),
																	CONVERT(VARCHAR(25), @TablePreCodeEndDateTime, 21)) ,
									PostCode = @currTablePostCode ,
									PostCodeBeginDateTime = @TablePostCodeBeginDateTime ,
									PostCodeEndDateTime = @TablePostCodeEndDateTime ,
									PostCodeRunTimeInSecs = DATEDIFF(s,
																	 CONVERT(VARCHAR(25), @TablePostCodeBeginDateTime, 21),
																	 CONVERT(VARCHAR(25), @TablePostCodeEndDateTime, 21))
							WHERE	ExecutionDateTime = CONVERT(VARCHAR(25), @ExecutionDateTime, 21)
									AND DBName = @DBName
									AND SchemaName = @currSchemaName
									AND TableName = @currTableName
									AND IndexName = @currIndexName	

					END --@PrepOnly = 0

				END --@StmtOnly = 0 

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Log Reindex Op----------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Run Stats Update------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 

--Run Stats if the table has it flagged to do so, but only on defrags.
IF @StmtOnly = 0
BEGIN --@StmtOnly = 0
IF @ErrMsg IS NULL
BEGIN --@ErrMsg IS NULL

						-------------------
						--BEGIN LOG PREP---
						-------------------	

			IF @currOP = 'Reorg'
				AND @currUpdateStatsOnDefrag = 1
				AND @currIndexTypeDesc <> 'XML' 
				BEGIN --Stats Update and Log



------------------BEGIN Log Status---------------------------------

					IF @LogProgress = 1 
						BEGIN --@LogProgress = 1

    						IF @PrepOnly = 0
							BEGIN --@PrepOnly = 0   
								
								IF @ErrMsg IS NULL
								BEGIN --@ErrMsg IS NULL
									UPDATE	Minion.IndexMaintLogDetails
									SET		Status = 'Updating stats'
									WHERE	ExecutionDateTime = @ExecutionDateTime
											AND DBName = @DBName
											AND SchemaName = @currSchemaName
											AND TableName = @currTableName
											AND IndexName = @currIndexName
								END --@ErrMsg IS NULL
							END --@PrepOnly = 0

						END --@LogProgress = 1
------------------END Log Status---------------------------------



					SET @currOP = 'Stats';
					SET @StatsBeginDateTime = GETDATE();
	
						-------------------
						--END LOG PREP-----
						-------------------	
			
						-------------------
						--BEGIN STMT BUILD-
						-------------------		
	
					SET @StatsSQL = 'USE [' + @DBName
						+ ']; UPDATE STATISTICS [' + @currSchemaName + '].['
						+ @currTableName + '] ' + '[' + @currIndexName + ']'
						IF @currStatScanOption IS NOT NULL
						BEGIN
							SET @StatsSQL = @StatsSQL + ' WITH ' + @currStatScanOption;
						END
					SET @StatsEndDateTime = GETDATE();
			
						-------------------
						--END STMT BUILD---
						-------------------				

						-------------------
						----BEGIN RUN------
						-------------------
	
					EXEC (@StatsSQL);
	
						-------------------
						----END RUN--------
						-------------------

			
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Stats Log-------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 


					IF @StmtOnly = 0 
						BEGIN --@StmtOnly = 0

    				IF @PrepOnly = 0
					BEGIN --@PrepOnly = 0   
					        
							UPDATE	Minion.IndexMaintLogDetails
							SET		UpdateStatsBeginDateTime = CONVERT(VARCHAR(25), @StatsBeginDateTime, 21) ,
									UpdateStatsEndDateTime = CONVERT(VARCHAR(25), @StatsEndDateTime, 21) ,
									UpdateStatsStmt = @StatsSQL ,
									UpdateStatsTimeInSecs = DATEDIFF(s,
															  CONVERT(VARCHAR(25), @StatsBeginDateTime, 21),
															  CONVERT(VARCHAR(25), @StatsEndDateTime, 21))
							WHERE	ExecutionDateTime = CONVERT(VARCHAR(25), @ExecutionDateTime, 21)
									AND DBName = @DBName
									AND SchemaName = @currSchemaName
									AND TableName = @currTableName
									AND IndexName = @currIndexName	

					END --@PrepOnly = 0

						END	--@StmtOnly = 0		

END --@ErrMsg IS NULL			
				END --Stats Update and Log

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Stats Log---------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 

END --@StmtOnly = 0
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Run Stats Update--------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 




-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Post Frag-------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 

IF @ErrMsg IS NULL
BEGIN --@ErrMsg IS NULL

			IF @currGetPostFragLevel = 1 --AND @StmtOnly = 0
				BEGIN --Post Frag


------------------BEGIN Log Status---------------------------------

					IF @LogProgress = 1 
						BEGIN --@LogProgress = 1

    						IF @PrepOnly = 0
							BEGIN --@PrepOnly = 0  
							SET @PostFragBeginDateTime = GETDATE(); 

									UPDATE	Minion.IndexMaintLogDetails
									SET		Status = 'Getting Post Frag stats',
											PostFragBeginDateTime = @PostFragBeginDateTime
									WHERE	ExecutionDateTime = @ExecutionDateTime
											AND DBName = @DBName
											AND SchemaName = @currSchemaName
											AND TableName = @currTableName
											AND IndexName = @currIndexName

							END --@Preponly = 0

						END --@LogProgress = 1

------------------END Log Status---------------------------------


						-------------------
						--BEGIN STMT PREP--
						-------------------	   

					SET @currIndexForFragStats = '[' + @DBName + ']' + '.'
						+ '[' + @currSchemaName + ']' + '.' + '[' + @currTableName + ']'
						      
--This can be done better. Add some cols and make some decisions based off of scanmode, etc.			
					INSERT	#PostFrag
							SELECT	avg_fragmentation_in_percent ,
									index_id ,
									index_level
							FROM	sys.dm_db_index_physical_stats(DB_ID(@DBName),
															  OBJECT_ID(@currIndexForFragStats),
															  @currIndexID,
															  NULL,
															  @currIndexScanMode) 

							--SELECT 'SELECT	avg_fragmentation_in_percent ,
							--		index_id ,
							--		index_level
							--FROM	sys.dm_db_index_physical_stats(DB_ID(' + @DBName + '),' +
							--								  'OBJECT_ID(' + @currIndexForFragStats + '),'
							--								  + ISNULL(CAST(@currIndexID AS VARCHAR(5)), 'SEAN') + ',' +
							--								  'NULL,' + 
							--								  ISNULL(@currIndexScanMode, 'SEAN') + ') ' AS PostFragStmt
						-------------------
						--END STMT PREP----
						-------------------					    

END  --@ErrMsg IS NULL


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Post Frag Log---------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

IF @ErrMsg IS NULL
BEGIN --@ErrMsg IS NULL

-----The same conditions apply here as for the initial frag stats.  So we're either going to take the max
-----or we're going to take level 0 for the clustered index.

IF @currIndexScanMode IS NULL
	BEGIN
		SET @currIndexScanMode = 'Limited'
	END
					IF @currIndexScanMode = 'Limited' 
						BEGIN
							SET @PostFragLevel = ( SELECT	MAX(MaxFrag)
												   FROM		#PostFrag
												 );
						END

					IF @currIndexScanMode = 'Detailed' 
						BEGIN
							SET @PostFragLevel = ( SELECT	MAX(MaxFrag)
												   FROM		#PostFrag
												   WHERE	Index_ID = 1
															AND Index_Level = 0
												 );
		
						END

					--Prep #PostFrag for the next index.
					TRUNCATE TABLE #PostFrag

					SET @PostFragEndDateTime = GETDATE(); 
	
						-------------------
						----BEGIN RUN------
						-------------------	
					IF @StmtOnly = 0 
						BEGIN --@StmtOnly = 0
  
      						IF @PrepOnly = 0
							BEGIN --@PrepOnly = 0  
					      
									UPDATE	Minion.IndexMaintLogDetails
									SET		--PostFragBeginDateTime = CONVERT(VARCHAR(25), @RowCTBeginDateTime, 21) ,
											PostFragEndDateTime = CONVERT(VARCHAR(25), @PostFragBeginDateTime, 21) ,
											PostFragTimeInSecs = DATEDIFF(s,
																	  CONVERT(VARCHAR(25), @PostFragBeginDateTime, 21),
																	  CONVERT(VARCHAR(25), @PostFragEndDateTime, 21)) ,
											PostFragLevel = @PostFragLevel
									WHERE	ExecutionDateTime = CONVERT(VARCHAR(25), @ExecutionDateTime, 21)
											AND DBName = @DBName
											AND SchemaName = @currSchemaName
											AND TableName = @currTableName
											AND IndexID = @currIndexID;

							END --@PrepOnly = 0

						END --@StmtOnly = 0
						-------------------
						----END RUN--------
						-------------------	

END --@ErrMsg IS NULL
						
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Post Frag Log------------------------------------------------------ Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 		
		
				END --Post Frag  

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Post Frag---------------------------------------------------------- Inside cursor
-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------- 





-----------------------------------
-----------------------------------
--------BEGIN Table PostCode-------
-----------------------------------
-----------------------------------


			IF @StmtOnly = 0 
				BEGIN -- @StmtOnly = 0

					IF @currTableIterator = @TableCT--@TableCtrl <> @currTableName AND @TableCtrl <> ''
						BEGIN --TableCtrl

							IF @currTablePostCode IS NOT NULL 
								BEGIN --@currTablePostCode IS NOT NULL

									SET @TablePostCodeBeginDateTime = GETDATE();
							------------------BEGIN Log Status---------------------------------

										IF @StmtOnly = 0 
											BEGIN --@StmtOnly = 0
  												IF @PrepOnly = 0
													BEGIN --@PrepOnly = 0 

														IF @LogProgress = 1 
															BEGIN --@LogProgress = 1
																IF @currTablePostCode IS NOT NULL 
																	BEGIN --@currTablePostCode IS NOT NULL

																		IF @ErrMsg IS NULL
																		BEGIN --@ErrMsg IS NULL
																		UPDATE	Minion.IndexMaintLogDetails
																		SET		Status = 'Running Table PostCode' ,
																				PostCode = @currTablePostCode ,
																				PostCodeBeginDateTime = @TablePostCodeBeginDateTime
																		WHERE	ExecutionDateTime = @ExecutionDateTime
																				AND DBName = @DBName
																				AND SchemaName = @currSchemaName
																				AND TableName = @currTableName
																				AND IndexName = @currIndexName
																		END --@ErrMsg IS NULL

																	END  --@currTablePostCode IS NOT NULL
															END --@LogProgress = 1

													END --@PrepOnly = 0
											END --@StmtOnly = 0

							------------------END Log Status---------------------------------


							--------BEGIN Run Table PostCode----------

									EXEC (@currTablePostCode)

							--------END Run Table PostCode------------

									SET @TablePostCodeEndDateTime = GETDATE();

								END --@currTablePostCode IS NOT NULL

						END --TableCtrl
				END -- @StmtOnly = 0



-----------------------------------
-----------------------------------
--------END Table PostCode---------
-----------------------------------
-----------------------------------	






-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Usage Details----------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

IF @ErrMsg IS NULL
BEGIN

			IF @StmtOnly = 0 
				BEGIN  --@StmtOnly = 0   --UsageDetails


					SET @IncludeUsageDetails = ( SELECT	IncludeUsageDetails
												 FROM	Minion.IndexSettingsDB
												 WHERE	DBName = 'MinionDefault'
											   )

		----Override default PreCode if a DB override exists.
					IF ( SELECT	IncludeUsageDetails
						 FROM	Minion.IndexSettingsDB
						 WHERE	DBName = @DBName
					   ) IS NOT NULL 
						BEGIN
							SET @IncludeUsageDetails = ( SELECT
															  IncludeUsageDetails
														 FROM Minion.IndexSettingsDB
														 WHERE
															  DBName = @DBName
													   );
						END

				END  --@StmtOnly = 0   --UsageDetails


      	IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0  

			IF @IncludeUsageDetails = 1 
				BEGIN --@IncludeUsageDetails = 1 

					UPDATE	IML
					SET		IML.UserSeeks = IUS.user_seeks ,
							IML.UserScans = IUS.user_scans ,
							IML.UserLookups = IUS.user_lookups ,
							IML.UserUpdates = IUS.user_updates ,
							IML.LastUserSeek = IUS.last_user_seek ,
							IML.LastUserScan = IUS.last_user_scan ,
							IML.LastUserLookup = IUS.last_user_lookup ,
							IML.LastUserUpdate = IUS.last_user_update ,
							IML.SystemSeeks = IUS.system_seeks ,
							IML.SystemScans = IUS.system_scans ,
							IML.SystemLookups = IUS.system_lookups ,
							IML.SystemUpdates = IUS.system_updates ,
							IML.LastSystemSeek = IUS.last_system_seek ,
							IML.LastSystemScan = IUS.last_system_scan ,
							IML.LastSystemLookup = IUS.last_system_lookup ,
							IML.LastSystemUpdate = IUS.last_system_update
					FROM	Minion.IndexMaintLogDetails IML
							INNER JOIN sys.dm_db_index_usage_stats IUS ON @currTableID = IUS.object_id
															  AND @currIndexID = IUS.index_id
					WHERE	IML.DBName = @DBName
							AND IML.TableID = @currTableID
							AND IML.IndexID = @currIndexID
							AND IML.ExecutionDateTime = @ExecutionDateTime

		END --@PrepOnly = 0

				END --@IncludeUsageDetails = 1 

END --@ErrMsg IS NULL
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Usage Details------------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------




---------------------------------------------------------------------
---------------------------------------------------------------------
-------- BEGIN Delete Log History------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------


------------------BEGIN Log Status---------------------------------

      	IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0 
		
		IF @ErrMsg IS NULL
		BEGIN --@ErrMsg IS NULL
			IF @LogProgress = 1 
				BEGIN --@LogProgress = 1

					UPDATE	Minion.IndexMaintLogDetails
					SET		Status = 'Deleting Table History'
					WHERE	ExecutionDateTime = @ExecutionDateTime
							AND DBName = @DBName
							AND SchemaName = @currSchemaName
							AND TableName = @currTableName
							AND IndexName = @currIndexName

		END --@LogProgress = 1 
		END --@ErrMsg IS NULL

				END --@PrepOnly = 0

------------------END Log Status---------------------------------

      	IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0 

			DELETE	Minion.IndexMaintLogDetails
			WHERE	DATEDIFF(dd, ExecutionDateTime, GETDATE()) > @currLogRetDays
					AND DBName = @DBName
					AND TableName = @currTableName

		END --@PrepOnly = 0

---------------------------------------------------------------------
---------------------------------------------------------------------
-------- END Delete Log History--------------------------------------
---------------------------------------------------------------------
---------------------------------------------------------------------


-------------------------------------------------------
-------------------------------------------------------
-------- BEGIN Delete Current Table from TableFrag-----
-------------------------------------------------------
-------------------------------------------------------

IF @RunPrepped = 1
			BEGIN --@RunPrepped = 1
				DELETE	Minion.IndexTableFrag
				WHERE	TableID = @currTableID
						AND IndexID = @currIndexID
						AND DBName = @DBName
						AND Prepped = 1
			END --@RunPrepped = 1


IF @RunPrepped = 0
			BEGIN --@RunPrepped = 1
				DELETE	Minion.IndexTableFrag
				WHERE	TableID = @currTableID
						AND IndexID = @currIndexID
						AND DBName = @DBName
						AND Prepped = 0
			END --@RunPrepped = 1

-------------------------------------------------------
-------------------------------------------------------
-------- END Delete Current Table from Table Frag------
-------------------------------------------------------
-------------------------------------------------------




-------------------------------------------------------------------
-------------------------------------------------------------------
------------------BEGIN Log Complete Status------------------------
-------------------------------------------------------------------
-------------------------------------------------------------------

IF @ErrMsg IS NULL
BEGIN --@ErrMsg IS NULL

      	IF @PrepOnly = 0
		BEGIN --@PrepOnly = 0 

			IF @LogProgress = 1 
				BEGIN --@LogProgress = 1

					UPDATE	Minion.IndexMaintLogDetails
					SET		Status = 'Complete'
					WHERE	ExecutionDateTime = @ExecutionDateTime
							AND DBName = @DBName
							AND SchemaName = @currSchemaName
							AND TableName = @currTableName
							AND IndexName = @currIndexName

				END --@LogProgress = 1

		END --@PrepOnly = 0

END --@ErrMsg IS NULL

-------------------------------------------------------------------
-------------------------------------------------------------------
------------------END Log Complete Status--------------------------
-------------------------------------------------------------------
-------------------------------------------------------------------

----Set Error var for next index.



SET @TableCtrl = @currTableName




			FETCH NEXT FROM Tables INTO @currTableID, @currSchemaName,
				@currTableName, @currIndexName, @currIndexID, @currIndexType,
				@currIndexTypeDesc, @currFragLevel, @currReorgThreshold,
				@currRebuildThreshold, @currFILLFACTORopt, @currPadIndex,
				@currONLINEopt, @currSortInTempDB, @currMAXDOPopt,
				@currDataCompression, @currGetRowCT, @currGetPostFragLevel,
				@currUpdateStatsOnDefrag, @currStatScanOption,
				@currIgnoreDupKey, @currStatsNoRecompute, @currAllowRowLocks,
				@currAllowPageLocks, @currWaitAtLowPriority,
				@currMaxDurationInMins, @currAbortAfterWait, @currLogProgress,
				@currLogRetDays, @currPushToMinion, @currLogIndexPhysicalStats,
				@currIndexScanMode, @currTablePreCode, @currTablePostCode, @currStmtPrefix, @currStmtSuffix
	
		END -- End Cursor Loop

	CLOSE Tables
	DEALLOCATE Tables

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Reindex Stmt Cursor------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------


-----------------------------------
-----------------------------------
--------BEGIN DBPostCode-----------
-----------------------------------
-----------------------------------	

	IF @StmtOnly = 0 
		BEGIN --@StmtOnly = 0 MAIN

		IF @PrepOnly = 0
			BEGIN --@PrepOnly = 0

		----Get default PostCode for all DBs.
			SET @DBPostCode = ( SELECT	DBPostCode
								FROM	Minion.IndexSettingsDB
								WHERE	DBName = 'MinionDefault'
							  )

		----Override default PostCode if a DB override exists.
			IF ( SELECT	DBPostCode
				 FROM	Minion.IndexSettingsDB
				 WHERE	DBName = @DBName
			   ) IS NOT NULL 
				BEGIN
					SET @DBPostCode = ( SELECT	DBPostCode
										FROM	Minion.IndexSettingsDB
										WHERE	DBName = @DBName
									  );
				END


			IF @DBPostCode IS NOT NULL 
				BEGIN --@DBPostCode IS NOT NULL

------------------BEGIN Log Status---------------------------------

					IF @StmtOnly = 0 
						BEGIN --@StmtOnly = 0

							UPDATE	Minion.IndexMaintLog
							SET		Status = 'Running DB PostCode'
							WHERE	ExecutionDateTime = @ExecutionDateTime
									AND DBName = @DBName

						END --@StmtOnly = 0

------------------END Log Status---------------------------------

					SET @DBPostCodeBeginDateTime = GETDATE();
					EXEC (@DBPostCode)
					SET @DBPostCodeEndDateTime = GETDATE();

				END --@DBPostCode IS NOT NULL
			END --@PrepOnly = 0

		END --@StmtOnly = 0 MAIN
-----------------------------------
-----------------------------------
--------END DBPostCode-------------
-----------------------------------
-----------------------------------	



-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------Begin Central Logging--------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

--It's important that none of the trigger files have a file ext.  Just parse out the server.DBName.
--The template file is there because you can't just create a file in dos like you can in PS and 
--all the boxes can't have PS put on them.  This is the easiest low-tech way to accomplish this.
--So put an empty file called 'Template' with no ext and you rename it during the copy.

	IF @StmtOnly = 0 

		IF @PrepOnly = 0
			BEGIN --@PrepOnly = 0

				BEGIN -- @StmtOnly = 0
					DECLARE	@ReindexLogging VARCHAR(25) ,
						@ReindexLoggingPath VARCHAR(1000);

					SELECT	@ReindexLogging = LogLoc ,
							@ReindexLoggingPath = MinionTriggerPath
					FROM	Minion.IndexSettingsDB
					WHERE	DBName = 'MinionDefault';

					----Override default Logging if a DB override exists.
					IF ( SELECT	LogLoc
						 FROM	Minion.IndexSettingsDB
						 WHERE	DBName = @DBName
					   ) IS NOT NULL 
						BEGIN
							SELECT	@ReindexLogging = LogLoc ,
									@ReindexLoggingPath = MinionTriggerPath
							FROM	Minion.IndexSettingsDB
							WHERE	DBName = @DBName;
						END


					IF @ReindexLogging = 'Repo' 
						BEGIN
							DECLARE	@TriggerFile VARCHAR(8000) ,
								@InstanceName NVARCHAR(128) ,
								@FullServerName VARCHAR(200);
			
							--SET @InstanceName = CAST(SERVERPROPERTY('InstanceName') AS NVARCHAR(128));	

		----Separate the Instance and servername with a $ instead of a \.  This way it doesn't get turned into a folder 
		----in the dos call below.
							--IF @InstanceName IS NOT NULL 
							--	SET @InstanceName = '$' + @InstanceName;

							--IF @InstanceName IS NULL 
								SET @InstanceName = @@ServerName;

		----Build the full server$Instance name to make the dos call below cleaner.
							SET @FullServerName = REPLACE(@InstanceName, '\', '~')

		---Log to the trigger file to be pushed into repo.
							SET @TriggerFile = 'Powershell "' + ''''''''
								+ CONVERT(VARCHAR(25), @ExecutionDateTime, 21)
								+ '''''''' + ' | out-file "' + @ReindexLoggingPath
								+ @FullServerName + '.' + @DBName + ' -append"' 

							EXEC xp_cmdshell @TriggerFile 
						END

			END --@PrepOnly = 0

		END -- @StmtOnly = 0
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Central Logging----------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------



-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Reset RecoveryModel----------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
	
	IF @PrepOnly = 0
	BEGIN --@PrepOnly = 0

			IF @RecoveryModelChanged = 1 
				BEGIN
					SET @RecoveryModelSQL = 'ALTER DATABASE [' + @DBName
						+ '] SET RECOVERY ' + @CurrentRecoveryModel;
					EXEC (@RecoveryModelSQL);

				END

	END -- @PrepOnly = 0
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Reset RecoveryModel------------------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------




-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------BEGIN Log to IndexMaintLogMaster---------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

IF @PrepOnly = 0
	BEGIN --@PrepOnly = 0

		SET @NumTablesProcessed = ( SELECT	COUNT(DISTINCT TableName)
									FROM	Minion.IndexMaintLogDetails WITH ( NOLOCK )
									WHERE	ExecutionDateTime = @ExecutionDateTime AND DBName = @DBName
								  );
		SET @NumIndexesProcessed = ( SELECT	COUNT(IndexName)
									 FROM	Minion.IndexMaintLogDetails WITH ( NOLOCK )
									 WHERE	ExecutionDateTime = @ExecutionDateTime AND DBName = @DBName
								   );
		SET @NumIndexesRebuilt = ( SELECT	COUNT(*)
								   FROM		Minion.IndexMaintLogDetails WITH ( NOLOCK )
								   WHERE	UPPER(Op) = 'REBUILD'
											AND ExecutionDateTime = @ExecutionDateTime AND DBName = @DBName
								 );
		SET @NumIndexesReorged = ( SELECT	COUNT(*)
								   FROM		Minion.IndexMaintLogDetails WITH ( NOLOCK )
								   WHERE	UPPER(Op) = 'REORG'
											AND ExecutionDateTime = @ExecutionDateTime AND DBName = @DBName
								 );

DECLARE @FinalErrorCT INT,
		@FinalWarningCT INT;
SET @FinalErrorCT = (SELECT COUNT(*) FROM Minion.IndexMaintLogDetails WHERE ExecutionDateTime = @ExecutionDateTime AND (Status NOT LIKE '%Complete' AND Status LIKE 'FATAL ERROR%'));
SET @FinalWarningCT = 0;

		UPDATE	Minion.IndexMaintLog
		SET		ExecutionDateTime = @ExecutionDateTime ,
				Status = 
			CASE 
				 WHEN (@FinalErrorCT = 0 AND @FinalWarningCT = 0) THEN 'All Complete'
				 WHEN (@FinalErrorCT > 0 AND @FinalWarningCT = 0) THEN 'Complete with ' + CAST(@FinalErrorCT AS VARCHAR(10)) + ' Error' + CASE WHEN @FinalErrorCT > 1 THEN 's' ELSE '' END
				 WHEN (@FinalErrorCT = 0 AND @FinalWarningCT > 0) THEN 'Complete with ' + CAST(@FinalWarningCT AS VARCHAR(10)) + ' Warning' + CASE WHEN @FinalWarningCT > 1 THEN 's' ELSE '' END
				 WHEN (@FinalErrorCT > 0 AND @FinalWarningCT > 0) THEN 
				 ('Complete with ' + CAST(@FinalErrorCT AS VARCHAR(10)) + ' Error' + CASE WHEN @FinalErrorCT > 1 THEN 's' ELSE '' END) +
				 (' and ' + CAST(@FinalWarningCT AS VARCHAR(10)) + ' Warning' + CASE WHEN @FinalWarningCT > 1 THEN 's' ELSE '' END)
			END,
				DBName = @DBName ,
				Tables = @IndexOption ,
				RunPrepped = @RunPrepped ,
				PrepOnly = @PrepOnly ,
				ReorgMode = @ReorgMode ,
				NumTablesProcessed = ISNULL(@NumTablesProcessed, 0) ,
				NumIndexesProcessed = ISNULL(@NumIndexesProcessed, 0) ,
				NumIndexesRebuilt = ISNULL(@NumIndexesRebuilt, 0) ,
				NumIndexesReorged = ISNULL(@NumIndexesReorged, 0) ,
				RecoveryModelChanged = @RecoveryModelChanged ,
				RecoveryModelCurrent = @CurrentRecoveryModel ,
				RecoveryModelReindex = @ReindexRecoveryModel ,
				SQLVersion = @Version ,
				SQLEdition = @Edition ,
				DBPreCode = @DBPreCode ,
				DBPostCode = @DBPostCode ,
				DBPreCodeBeginDateTime = @DBPreCodeBeginDateTime ,
				DBPreCodeEndDateTime = @DBPreCodeEndDateTime ,
				DBPostCodeBeginDateTime = @DBPostCodeBeginDateTime ,
				DBPostCodeEndDateTime = @DBPostCodeEndDateTime ,
				DBPreCodeRunTimeInSecs = DATEDIFF(s,
												  CONVERT(VARCHAR(25), @DBPreCodeBeginDateTime, 21),
												  CONVERT(VARCHAR(25), @DBPreCodeEndDateTime, 21)) ,
				DBPostCodeRunTimeInSecs = DATEDIFF(s,
												   CONVERT(VARCHAR(25), @DBPostCodeBeginDateTime, 21),
												   CONVERT(VARCHAR(25), @DBPostCodeEndDateTime, 21)) ,
				ExecutionFinishTime = GETDATE() ,
				ExecutionRunTimeInSecs = DATEDIFF(s,
												  CONVERT(VARCHAR(25), @ExecutionDateTime, 21),
												  CONVERT(VARCHAR(25), GETDATE(), 21))
		WHERE	ExecutionDateTime = @ExecutionDateTime
				AND DBName = @DBName

	END --@PrepOnly = 0
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
------------END Log to IndexMaintLogMaster-----------------------------------------
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

GO


-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- END IndexMaintDB ------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- BEGIN IndexMaintMaster ------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------


IF EXISTS (SELECT name FROM sys.objects WHERE name = 'IndexMaintMaster' AND schema_id('Minion') IS NOT NULL)
BEGIN
DROP PROCEDURE Minion.IndexMaintMaster
END

GO
CREATE PROCEDURE [Minion].[IndexMaintMaster]
    @IndexOption VARCHAR(100) = 'All' , -- Valid options: All, ONLINE, OFFLINE.  So All the indexes, or only the indexes that can be done online or offline.
    @ReorgMode VARCHAR(7) , -- Valid options: All, REORG, REBUILD. For REORG mode, only REORG stmts will be generated.  For REBUILD, only REBUILD stmts will be generated.
    @RunPrepped BIT = 0 ,  --The index frag data has already been collected and you want to use that data instead of querying for the frag data now.
    @PrepOnly BIT = 0 , -- Valid options: 1, 0. Only gets index frag stats and saves to a table.  This preps the DB to be reindexed.  Run this with @RunPrepped = 1 to take advantage of the prep.
    @StmtOnly BIT = 0 ,  --Print the reindex calls only.
    @Include VARCHAR(2000) = NULL , --Index ONLY these DBs.  comma-separated like this : DB1,DB2,DB3
    @Exclude VARCHAR(2000) = NULL , -- Valid options: 1, 0. Only prints reindex stmts.  Excellent choice for running stmts manually.  Allows you to pick and choose which indexes you want to do or just see how many are over the thresholds.
    @LogProgress BIT = 1 -- Valid options: 1, 0.  Allows you to have every step of the run printed in the log so you can see the progress it's making.  This can take a little extra time so leave it out if you just want it to run w/o being monitored.
AS 

/***********************************************************************************
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
------------------Minion Reindex------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Created By: MidnightSQL Consulting LLC. and MidnightDBA.com

For SQL Server consulting, see our website http://www.MidnightSQL.com
No job is too big or too small.

Also, check out our FREE SQL Server training videos at http://www.MidnightDBA.com

This is a big routine with many nuances.  Our documentation is complete, but if 
you prefer, we also have videos that show you how to use each of the features.
You can find them at http://www.MidnightDBA.com/Minion

Minion Reindex is a free, standalone, index maintenance routine that is a component 
of the Minion Enterprise Management solution.

Minion Enterprise Management makes managing your SQL Server enterprise super easy. 
The reindex routine folds into the enterprise solution with ease.  By integrating 
your index maintenance into the Minion Enterprise Management solution, you get the 
ability to manage your reindex parameters from a central location. And, Minion 
Enterprise Management provides enterprise-level reporting and alerting.

--------------------------------------------------------------------------------

Example Execution: 
	[Minion].[IndexMaintMaster] 
	@IndexOption = 'All', -- All, ONLINE, OFFLINE
	@ReorgMode = 'All',
	@RunPrepped = 0, -- Valid options: 1, 0. If you've collected index frag stats ahead of time by running with @PrepOnly = 1, then you can use this option. 
	@PrepOnly = 0,
	@StmtOnly = 1,
	@Include = 'Minion%, ReportSERVER', -- Only do DBs listed here. Commas are used. ex: @Include = 'master, model, msdb'
	@Exclude = NULL, -- Do all DBs except the ones listed here. Commas are used. ex: @Exclude = 'master, model, msdb'
	@LogProgress = 1

Revisions:
	1.1		Add ability to handle Availability Groups


*/
    SET NOCOUNT ON;

    DECLARE @ExecutionDateTime DATETIME ,
        @currDB VARCHAR(100) ,
        @currTables VARCHAR(10) ,
        @currRunPrepped BIT ,
        @currStmtOnly BIT ,
        @DBName VARCHAR(100) ,
        @SQL NVARCHAR(200),
		@currDBName varchar(100),
		@IncludeRAW varchar(2000),
		@ExcludeRAW varchar(2000),
		@Version VARCHAR(50),
		@Edition VARCHAR(15),
		@RegexCT smallint,
		@IsPrimaryReplica bit,
		@DBIsInAG bit;

    SET @ExecutionDateTime = GETDATE();

----Seed initial AG value since most DBs won't be in an AG, we go ahead and set it here.  If it is 
----in an AG then we'll set it again later.
SET @DBIsInAG = 0;

CREATE TABLE #DBs
(
DBName varchar(100) COLLATE DATABASE_DEFAULT,
IsReadOnly BIT,
StateDesc VARCHAR(50) COLLATE DATABASE_DEFAULT,
ReindexGroupOrder INT ,
ReindexOrder INT
        )



---------------------------------------------------------------------------------
------------------ BEGIN Get Version Info----------------------------------------
---------------------------------------------------------------------------------

	SELECT	@Version = LEFT(CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(15)),
							CHARINDEX('.',
									  CAST(SERVERPROPERTY('ProductVersion') AS VARCHAR(15)),
									  1) - 1)
	SELECT	@Edition = CAST(SERVERPROPERTY('Edition') AS VARCHAR(25));

	DECLARE	@OnlineEdition BIT
	IF @Edition LIKE '%Enterprise%'
		OR @Edition LIKE '%Developer%' 
		BEGIN
			SET @OnlineEdition = 1
		END
	
	IF @Edition NOT LIKE '%Enterprise%'
		AND @Edition NOT LIKE '%Developer%' 
		BEGIN
			SET @OnlineEdition = 0
		END	

---------------------------------------------------------------------------------
------------------ END Get Version Info------------------------------------------
---------------------------------------------------------------------------------


------------------------------------------------------------
------------BEGIN Process Included DBs----------------------
------------------------------------------------------------

SET @IncludeRAW = @Include;

        IF @Include <> 'All' AND @Include IS NOT NULL 
            BEGIN -- <> All
--Get rid of any spaces in the DB list.
                SET @Include = REPLACE(@Include, ' ', '') 

                DECLARE @IncludeDBNameTable TABLE ( DBName VARCHAR(500) );
                DECLARE @IncludeDBNameString VARCHAR(500);
                WHILE LEN(@Include) > 0 
                    BEGIN
                        SET @IncludeDBNameString = LEFT(@Include,
                                                        ISNULL(NULLIF(CHARINDEX(',',
                                                            @Include) - 1,
                                                            -1),
                                                            LEN(@Include)))
                        SET @Include = SUBSTRING(@Include,
                                                    ISNULL(NULLIF(CHARINDEX(',',
                                                            @Include), 0),
                                                        LEN(@Include)) + 1,
                                                    LEN(@Include))

                        INSERT  INTO @IncludeDBNameTable
                                ( DBName )
                        VALUES  ( @IncludeDBNameString )
                    END  

----Insert Static DB Names----
--These are the actual DB names passed into the @Include param.
                INSERT  #DBs
                        SELECT  ID.DBName, SD.is_read_only, SD.state_desc, 0 , 0
                        FROM @IncludeDBNameTable ID
						INNER JOIN master.sys.databases SD
						ON ID.DBName = SD.Name COLLATE DATABASE_DEFAULT
						WHERE ID.DBName NOT LIKE '%\%%' ESCAPE '\'
				UNION
						SELECT DBName, NULL, NULL, NULL, NULL
						FROM @IncludeDBNameTable
						WHERE DBName LIKE '%\%%' ESCAPE '\'

----------------Insert LIKE Include DB Names----------------
--You can mix static and LIKE DB names so here's where we're processing the LIKE names.

IF @IncludeRAW LIKE '%\%%' ESCAPE '\'
BEGIN --@IncludeRAW
DECLARE LikeDBs CURSOR
READ_ONLY
FOR SELECT DBName
FROM #DBs
WHERE DBName LIKE '%\%%' ESCAPE '\' 

OPEN LikeDBs

	FETCH NEXT FROM LikeDBs INTO @currDBName
	WHILE (@@fetch_status <> -1)
	BEGIN
SELECT @currDBName AS CurrDBName
		INSERT #DBs
		SELECT Name, is_read_only, state_desc, 0, 0
		FROM master.sys.databases
		WHERE Name LIKE @currDBName
		
FETCH NEXT FROM LikeDBs INTO @currDBName
	END

CLOSE LikeDBs
DEALLOCATE LikeDBs

---Now delete the LIKE DBs that were passed into the param as the actual DB names are in the table now.
DELETE #DBs
WHERE DBName LIKE '%\%%' ESCAPE '\'

END --@IncludeRAW
-------------------END LIKE Include DB Names---------------------

            END -- <> All

        ELSE IF @Include = 'All' OR @Include IS NULL 
            BEGIN -- = 'All'

                INSERT  #DBs (DBName, IsReadOnly, StateDesc, ReindexGroupOrder, ReindexOrder)
                        SELECT  Name, is_read_only, state_desc, 0, 0
                        FROM    master.sys.databases
                        WHERE   NAME NOT IN ( 'ReportServerTempDB',
                                                'tempdb' )



						---------------------------------------
						-----BEGIN Delete ExcludeFromReindex---
						---------------------------------------
						DELETE D
						FROM #DBs D
						INNER JOIN Minion.IndexSettingsDB DBM WITH (NOLOCK)
						ON DBM.DBName = D.DBName
						WHERE DBM.Exclude = 1
						---------------------------------------
						-----END Delete ExcludeFromReindex-----
						---------------------------------------
						                        
						---------------------------------------
						-----BEGIN Set GroupOrder--------------
						---------------------------------------
						UPDATE D 
						SET D.ReindexGroupOrder = DBM.ReindexGroupOrder,
							D.ReindexOrder = DBM.ReindexOrder
						FROM #DBs D
						INNER JOIN Minion.IndexSettingsDB DBM WITH (NOLOCK)
						ON DBM.DBName = D.DBName
						---------------------------------------
						-----END Set GroupOrder----------------
						---------------------------------------

            END -- = 'All'

------------------------------------------------------------
------------END Process Included DBs------------------------
------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------BEGIN Process Excluded DBs----------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
SET @ExcludeRAW = @Exclude;

    IF @Exclude IS NOT NULL 
        BEGIN

--Get rid of any spaces in the DB list.
            SET @Exclude = REPLACE(@Exclude, ' ', '') 

            DECLARE @ExcludeDBNameTable TABLE ( DBName VARCHAR(500) );
            DECLARE @ExcludeDBNameString VARCHAR(500);
            WHILE LEN(@Exclude) > 0 
                BEGIN
                    SET @ExcludeDBNameString = LEFT(@Exclude,
                                                    ISNULL(NULLIF(CHARINDEX(',',
                                                              @Exclude) - 1,
                                                              -1),
                                                           LEN(@Exclude)))
                    SET @Exclude = SUBSTRING(@Exclude,
                                             ISNULL(NULLIF(CHARINDEX(',',
                                                              @Exclude), 0),
                                                    LEN(@Exclude)) + 1,
                                             LEN(@Exclude))

                    INSERT  INTO @ExcludeDBNameTable
                            ( DBName )
                    VALUES  ( @ExcludeDBNameString )
                END  

----------------Insert LIKE Exclude DB Names----------------
--You can mix static and LIKE DB names so here's where we're processing the LIKE names.

IF @ExcludeRAW LIKE '%\%%' ESCAPE '\'
BEGIN --@ExcludeRAW
DECLARE LikeDBs CURSOR
READ_ONLY
FOR SELECT DBName
FROM @ExcludeDBNameTable
WHERE DBName LIKE '%\%%' ESCAPE '\' 

OPEN LikeDBs

	FETCH NEXT FROM LikeDBs INTO @currDBName
	WHILE (@@fetch_status <> -1)
	BEGIN
SELECT @currDBName AS CurrDBName
		--INSERT @ExcludeDBNameTable (DBName)
		--SELECT Name
		--FROM master.sys.databases
		--WHERE Name LIKE @currDBName
		DELETE #DBs
		WHERE DBName LIKE @currDBName --'%\%%' ESCAPE '\'

--SELECT @currDBName AS 'CurrDBName'		
FETCH NEXT FROM LikeDBs INTO @currDBName
	END

CLOSE LikeDBs
DEALLOCATE LikeDBs


---Now delete the LIKE DBs that were passed into the param as the actual DB names are in the table now.
--DELETE #DBs
--WHERE DBName LIKE '%\%%' ESCAPE '\'

END --@ExcludeRAW
-------------------END LIKE Exclude DB Names---------------------
--SELECT 'ExcludedDBs', * FROM @ExcludeDBNameTable 


            DELETE  DBs
            FROM    #DBs DBs
                    INNER JOIN @ExcludeDBNameTable E ON DBs.DBName = E.DBName
--WHERE DBName IN (SELECT DBName from @ExcludeDBNameTable)
        END

------------------------------------------------------------------------------------------------------------------------
------------END Process Excluded DBs------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------


------------------------------------------------------------
------------------------------------------------------------
------------BEGIN Process Regex Excluded DBs----------------
------------------------------------------------------------
------------------------------------------------------------
--You may want to exclude DBs based off of a regex expression.  The regex expression is stored in the Minion.DBMaintRegexLookup table.
--This is great functionality and is meant for rotating dated archive DBs or dev DBs that rotate.  
--As an example, a prod DB will be picked up by the routine, but maybe you don't want the dated versions to be reindexed... like Minion201408 and Minion201409.
--These DBs get created and dropped every wk or so and you don't care about maintaining them.

------!!! The regex function isn't available for 2005.

If @Version >= 10
BEGIN --@Version >= 2008
        SELECT DISTINCT
                DFL.Regex,
                DFL.Action
		INTO #RegexMatch
        FROM    Minion.DBMaintRegexLookup DFL
        WHERE   Action = 'Exclude'
                AND ( MaintType = 'All'
                      OR MaintType = 'Reindex'
                    )

SET @RegexCT = (select count(*) from #RegexMatch)

If @RegexCT > 0

BEGIN --@RegexCT > 0
    CREATE TABLE #RegexLookup
        (
          DBName VARCHAR(400) NULL ,
          Action VARCHAR(10)
        )

    DECLARE @Regex VARCHAR(200) ,
        @Action VARCHAR(10) ,
        @RegexCMD VARCHAR(2000);

DECLARE @Instance NVARCHAR(128);
SET @Instance = (SELECT CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(128)));


    DECLARE DBs CURSOR READ_ONLY
    FOR
	SELECT * from #RegexMatch
        --SELECT DISTINCT
        --        DFL.Regex ,
        --        DFL.Action
        --FROM    Minion.DBMaintRegexLookup DFL
        --WHERE   Action = 'Exclude'
        --        AND ( MaintType = 'All'
        --              OR MaintType = 'Reindex'
        --            )

    OPEN DBs

    FETCH NEXT FROM DBs INTO @Regex, @Action
    WHILE ( @@fetch_status <> -1 ) 
        BEGIN

            SET @RegexCMD = 'EXEC xp_cmdshell ''powershell "'

			If @Version = 10
			BEGIN
                SET @RegexCMD = @RegexCMD  + 'ADD-PSSNAPIN SQLServerCmdletSnapin100; '
			END

			If @Version >= 11
			BEGIN
                SET @RegexCMD = @RegexCMD  + 'IMPORT-MODULE SQLPS -DisableNameChecking; '
			END
            SET @RegexCMD = @RegexCMD + '$DBList = invoke-sqlcmd -serverinstance "' + @Instance + '" -database master -query ''''select Name from master..sysdatabases''''; $FinalList = $DBList | ?{$_.Name -match '''''
       + @Regex + '''''}; $FinalList"  '''	--$FinalList = $DBList | ?{$_.Name -match ''''Minion\w+''''}; $FinalList"  '''	
PRINT @RegexCMD
            INSERT  #RegexLookup
                    ( DBName )
                    EXEC ( @RegexCMD
                        ) 

            FETCH NEXT FROM DBs INTO @Regex, @Action
        END

    CLOSE DBs
    DEALLOCATE DBs


--Get rid of any rows that aren't actually DBNames.  The cmdshell gives us back some crap with our results.-
    DELETE  #RegexLookup
    WHERE   DBName IS NULL

--Delete DBs that are meant to be excluded off of the Regex search.
    DELETE  DBs
    FROM    #DBs DBs
            INNER JOIN #RegexLookup FL ON DBs.DBName = FL.DBName

END --@RegexCT > 0

END --@Version >= 2008
------------------------------------------------------------
------------------------------------------------------------
------------END Process Regex Excluded DBs------------------
------------------------------------------------------------
------------------------------------------------------------



						---------------------------------------
						-----BEGIN ReadOnly DBs----------------
						---------------------------------------
						--This is done after everything else because no matter what you picked, you can't reindex a DB that isn't online and healthy,
						--so it has to be excluded, but we don't want it to fall out of the list until it's necessary or it may
						-- be put back in by a later step.
								DELETE #DBs
								WHERE StateDesc <> 'ONLINE'

						---------------------------------------
						-----END ReadOnly DBs------------------
						---------------------------------------


						---------------------------------------
						-----BEGIN ReadOnly DBs----------------
						---------------------------------------
						--This is done after everything else because no matter what you picked, you can't reindex a READONLY DB,
						--so it has to be excluded, but we don't want it to fall out of the list until it's necessary or it may
						-- be put back in by a later step.
								DELETE #DBs
								WHERE IsReadOnly = 1

						---------------------------------------
						-----END ReadOnly DBs------------------
						---------------------------------------




------------------------------------------------------------
------------------------------------------------------------
------------BEGIN Logging-----------------------------------
------------------------------------------------------------
------------------------------------------------------------

    IF @StmtOnly = 0

IF @RegexCT > 0
BEGIN
----Get comma-delimited list of DBs that were kicked out by the Regex lookup.
        DECLARE @RegexDBs VARCHAR(8000) 
    SELECT  @RegexDBs = COALESCE(@RegexDBs + ', ', '') + DBName
    FROM    #RegexLookup
    WHERE   DBName IS NOT NULL

END
------------------------------------------------------------
------------------------------------------------------------
------------END Logging-------------------------------------
------------------------------------------------------------
------------------------------------------------------------

	DECLARE	@AGResults TABLE ( numReplicaIDs INT );

    DECLARE DBs CURSOR READ_ONLY
    FOR
        SELECT  DBName
        FROM    #DBs
		ORDER BY ReindexGroupOrder DESC, ReindexOrder DESC

    OPEN DBs

    FETCH NEXT FROM DBs INTO @currDB
    WHILE ( @@fetch_status <> -1 ) 
        BEGIN

            IF @StmtOnly = 0 
                BEGIN --@StmtOnly = 0 

-------Check that the DB is the Primary Replica in an AG.
--Only Version 11 and Enterprise will work so we're only going to check if it meets both criteria.
		If @Version >= 11 AND @OnlineEdition = 1
			BEGIN --@Version >= 11

					--- We HAVE to run this select statement as an EXEC; even with the IF, this'd generate an error on SQL 05/08.
					INSERT	INTO @AGResults
							( numReplicaIDs
							)
							EXEC
								( 'select count(replica_id) from sys.databases where Name = '''
								  + @currDB + ''' AND replica_id IS NOT NULL'
								);

					SELECT TOP 1
							@DBIsInAG = numReplicaIDs
					FROM	@AGResults;

					DELETE FROM @AGResults; -- We're in a loop; clear results each time.


					If @DBIsInAG = 1
					BEGIN --@DBIsInAG = 1
						SET @IsPrimaryReplica = (SELECT count(*)        
						FROM             
							sys.databases dbs,             
							sys.dm_hadr_availability_replica_states ars         
						WHERE             
							dbs.replica_id = ars.replica_id             
							AND dbs.name = @currDB  
							AND ars.role = 1)
					END --@DBIsInAG = 1
			END --@Version >= 11


			If @DBIsInAG = 0 OR (@DBIsInAG = 1 AND @IsPrimaryReplica = 1)
				BEGIN
                    EXEC Minion.IndexMaintDB @currDB, @IndexOption, @ReorgMode,
                        @RunPrepped, @PrepOnly, @StmtOnly 
				END

                END --@StmtOnly = 0 

            IF @StmtOnly = 1 
                BEGIN
                    PRINT 'EXEC Minion.IndexMaintDB @DBName = ''' + @currDB
                        + ''', @IndexOption = ''' + @IndexOption
                        + ''', @ReorgMode = ''' + @ReorgMode + ''', '
                        + ' @RunPrepped = ' + CAST(@RunPrepped AS CHAR(1))
                        + ', ' + ' @PrepOnly = ' + CAST(@PrepOnly AS CHAR(1))
                        + ', @StmtOnly = ' + CAST(@StmtOnly AS CHAR(1))
                        + ', @LogProgress = ' + CAST(@StmtOnly AS CHAR(1))
                    PRINT 'GO'
                END
            FETCH NEXT FROM DBs INTO @currDB
        END

    CLOSE DBs
    DEALLOCATE DBs


        SELECT  *
        FROM    #DBs
		ORDER BY ReindexGroupOrder DESC, ReindexOrder DESC




GO


-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- END IndexMaintMaster --------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------




-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- HELP Tables and Data --------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------


IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'HELPObjects' AND schema_id('Minion') IS NOT NULL)
BEGIN

CREATE TABLE [Minion].[HELPObjects](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[Module] [varchar](50) NULL,
	[ObjectName] [varchar](100) NULL,
	[ObjectType] [varchar](100) NULL,
	[Synopsis] [varchar](1000) NULL,
	[Descript] [varchar](max) NULL,
	[MinionVersion] [float] NULL,
	[GlobalPosition] [int] NULL,
 CONSTRAINT [PK__Objects__3214EC27E83D3C4F] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

END

IF NOT EXISTS (SELECT name FROM sys.objects WHERE name = 'HELPObjectDetail' AND schema_id('Minion') IS NOT NULL)
BEGIN

CREATE TABLE Minion.HELPObjectDetail(
	[ObjectID] [int] NULL,
	[DetailName] [varchar](100) NULL,
	[GlobalPosition] [smallint] NULL,
	[Position] [smallint] NULL,
	[DetailType] VARCHAR(400) NULL,
	[DetailHeader] [varchar](100) NULL,
	[DetailText] [varchar](max) NULL,
	[DataType] [varchar](20) NULL,
	[max_length] [smallint] NULL,
	[precision] [tinyint] NULL,
	[scale] [tinyint] NULL,
	[is_nullable] [bit] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]


ALTER TABLE Minion.HELPObjectDetail  WITH CHECK ADD  CONSTRAINT [FK_ObjectDetail_Objects_ID] FOREIGN KEY([ObjectID])
REFERENCES [Minion].[HELPObjects] ([ID])

ALTER TABLE Minion.HELPObjectDetail CHECK CONSTRAINT [FK_ObjectDetail_Objects_ID]

END

IF NOT EXISTS ( SELECT	name
				FROM	sys.objects
				WHERE	name = 'DBMaintRegexLookup'
						AND SCHEMA_ID('Minion') IS NOT NULL ) 
	BEGIN
		CREATE TABLE [Minion].[DBMaintRegexLookup]
			(
			  [Action] [varchar](10) NULL ,
			  [MaintType] [varchar](20) NULL ,
			  [Regex] [nvarchar](2000) NULL
			)
		ON	[PRIMARY]
	END

----------------------------------FormatHelp Function ---------------------------------------------------

IF EXISTS (SELECT name FROM sys.objects WHERE name = 'FormatHelp' AND schema_id('Minion') IS NOT NULL)
BEGIN
	DROP FUNCTION [Minion].[FormatHelp];
END

GO

CREATE FUNCTION [Minion].[FormatHelp]
	(
	  @DetailText VARCHAR(8000) ,
	  @colWidth TINYINT , 
	  @Indent TINYINT
	)
RETURNS VARCHAR(8000)
AS 
	BEGIN
		DECLARE	@left NVARCHAR(4000) ,
			@breakPos TINYINT ,
			@hasbreak BIT ,
			@outStr VARCHAR(8000), 
			@spacer VARCHAR(1000);

		SET @spacer = ISNULL(REPLICATE(' ', @Indent), '');

		SET @outStr = '';

		IF LEN(@DetailText) <= @colWidth 
			SET @outStr = @spacer + @DetailText;

		WHILE 1 = 1
			AND LEN(@DetailText) > @colWidth 
			BEGIN
				SET @hasbreak = 0;

				--*-- Find the last space (or the first line break) in the current 100 characters:  
				SET @left = LEFT(@DetailText, @colWidth);
				SET @breakPos = 1 + CHARINDEX(CHAR(13) + CHAR(10), @left); 

				IF @breakPos = 1 
					SET @breakPos = @colWidth + 1 - ( CHARINDEX(' ',
															  REVERSE(@left)) );
				ELSE 
					SET @hasbreak = 1;
											
				--*-- Set @left to the first 100 characters or so, ending at the last space:
				SET @left = LEFT(@DetailText, @breakPos);

				--*-- Add the string to @outStr. And, Remove the @left string from @DetailText:
				IF @hasbreak = 1 
					BEGIN
						SET @outStr = @outStr + @spacer + @left;
						SET @DetailText = RIGHT(@DetailText,
												LEN(@DetailText) - @breakPos
												+ 1);
					END
				ELSE 
					BEGIN
						SET @outStr = @outStr + @spacer + @left + CHAR(13) + +CHAR(10);
						SET @DetailText = LTRIM(RIGHT(@DetailText,
												LEN(@DetailText) - @breakPos + 1)); -- picky line...
					END

				--*-- Add the very last line:
				IF LEN(@DetailText) <= @colWidth 
					BEGIN
						SET @outStr = @outStr + @spacer + @DetailText;       
						BREAK;
					END
		
			END

		RETURN @outStr;

	END
    
----------------------------------HELP SP ---------------------------------------------------
GO
IF EXISTS (SELECT name FROM sys.objects WHERE name = 'HELP' AND schema_id('Minion') IS NOT NULL)
BEGIN
	DROP PROCEDURE [Minion].[HELP];
END

GO

CREATE PROCEDURE [Minion].[HELP]
	(
	  @Module VARCHAR(50) = NULL ,
	  @Name VARCHAR(100) = NULL
	)
AS 
/***********************************************************************************
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
------------------Minion Reindex, Backup, CheckDB ------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Created By: MinionWare, LLC and MidnightDBA.com
http://www.MinionWare.net 

For SQL Server consulting, see our website http://www.MidnightSQL.com
No job is too big or too small.

Also, check out our FREE SQL Server training videos at http://www.MidnightDBA.com

About: 
This is a big routine with many nuances.  Our documentation is complete, but if 
you prefer, we also have videos that show you how to use each of the features.
You can find them at http://www.MinionWare.net

Minion Reindex is a free, standalone, index maintenance routine that is a component 
of the Minion Enterprise Management solution.

Minion Enterprise Management makes managing your SQL Server enterprise super easy. 
The reindex routine folds into the enterprise solution with ease.  By integrating 
your index maintenance into the Minion Enterprise Management solution, you get the 
ability to manage your reindex parameters from a central location. And, Minion 
Enterprise Management provides enterprise-level reporting and alerting.

--------------------------------------------------------------------------------

Purpose: To return help information on the Minion system and objects.

Example execution: 
	EXEC Minion.Help;				-- Returns a list of installed Minion modules.
	EXEC Minion.Help 'Backup';		-- Returns a list of topics for the Backup module.
	EXEC Minion.Help 'Backup', 'Quick Start';	-- Returns the Backup 'Quick Start' article.

	EXEC Minion.Help 'Reindex';		-- Returns a list of topics for the Reindex module.
	EXEC Minion.Help 'Reindex', 'Minion.IndexMaintDB'; -- Returns detailed help on object Minion.IndexMaintDB

Discussion:
	Help objects are currently of the following types:  
		* Information - Different types of Information require different formatting.
		
		* Procedure - ObjectName is printed first, and other features (Parameters, Discussion, 
		  Examples, etc) are printed according to their position.

		* Table - ObjectName is printed first, and other features (Column names, Discussion, 
		  Examples, etc) are printed according to their position.

Table of Contents:
	Declare varaibles
	Module help (includes cursor TopLevelHelp)
	Section help (includes cursor TopLevelHelp)
	Topic help	(includes cursor HelpText)
		ObjectType='Information'
			IF @DetailHeader NOT LIKE 'Troubleshoot:%' 
			IF @DetailHeader = 'System Requirements' 
			IF @DetailHeader <> 'ObjectName' 
			IF @DetailType <> 'ObjectName' 
		ObjectType='Procedure'
			IF @DetailType = 'ObjectName' 
			IF @DetailType = 'Param' 
		DetailType='Advice'	-- Advice is a DetailType of "Procedure" objects.
		ObjectType='Table'
			IF @DetailType = 'ObjectName' 
			IF @DetailHeader <> 'Column' AND @DetailType <> 'ObjectName' 
			IF @DetailType = 'Column' 


Revisions
	1.1	Updated printing process.
	1.2 Updated for Minion Backup 1.0 release; fixed SP display.
	1.3 Updated for Minion Reindex 1.2 and Minion Backup 1.1; added a more flexible graphics printing solution.
	    Also, if user inputs a module that isn't installed, help now responds with the list of installed modules.

NOTE: ASCII art generated from http://patorjk.com/software/taag/#p=display&f=Big&t=Minion%20Backup%201.0%20Help, font "Big".
***********************************************************************************/

--------------Declare varaibles
	DECLARE	@DetailName VARCHAR(100) ,
		@Position SMALLINT ,
		@DetailType SYSNAME ,
		@DetailHeader VARCHAR(100) ,
		@DetailText VARCHAR(MAX) ,
		@MaxLength SMALLINT ,
		@Precision TINYINT ,
		@Scale TINYINT ,
		@IsNullable BIT ,
		@ObjectType VARCHAR(100) ,
		@DataType VARCHAR(25) ,
		@DetailTextSpacer VARCHAR(100) ,
		@DataTypeSpacer VARCHAR(100) ,
		@currModule VARCHAR(50) ,
		@currObjectName VARCHAR(100) ,
		@TXTLen INT ,
		@i INT ,
		@colCT INT ,
		@colWidth INT ,
		@left NVARCHAR(4000) ,
		@breakPos TINYINT ,
		@outstr NVARCHAR(4000) ,
		@hasbreak BIT;


SET NOCOUNT ON;

IF NOT EXISTS (SELECT * FROM Minion.HELPObjects WHERE Module = @Module)
	SET @Module = NULL;

------------------------------------------------------------------------------
--------------BEGIN Print ASCII header----------------------------------------
------------------------------------------------------------------------------

CREATE TABLE #asciiArt
       (
         ID INT IDENTITY(1, 1)
       , TitleOrder INT
       , Title VARCHAR(100)
       , TextRow NVARCHAR(4000)
       );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'Minion', N'  __  __   _           _                   ' )		,
        ( 2, 'Minion', N' |  \/  | (_)         (_)                  ' )		,
        ( 3, 'Minion', N' | \  / |  _   _ __    _    ___    _ __    ' )		,
        ( 4, 'Minion', N' | |\/| | | | | ''_ \  | |  / _ \  | ''_ \   ' )		,
        ( 5, 'Minion', N' | |  | | | | | | | | | | | (_) | | | | |  ' )		,
        ( 6, 'Minion', N' |_|  |_| |_| |_| |_| |_|  \___/  |_| |_|  ' )		,
        ( 7, 'Minion', N'                                           ' )		,
        ( 8, 'Minion', N'                                           ' );


INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'Backup', N' ____                   _                      ' )		,
        ( 2, 'Backup', N'|  _ \                 | |                     ' )		,
        ( 3, 'Backup', N'| |_) |   __ _    ___  | | __  _   _   _ __    ' )		,
        ( 4, 'Backup', N'|  _ <   / _` |  / __| | |/ / | | | | | ''_ \   ' )		,
        ( 5, 'Backup', N'| |_) | | (_| | | (__  |   <  | |_| | | |_) |  ' )		,
        ( 6, 'Backup', N'|____/   \__,_|  \___| |_|\_\  \__,_| | .__/   ' )		,
        ( 7, 'Backup', N'                                      | |      ' )		,
        ( 8, 'Backup', N'                                      |_|      ' );
INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'Reindex', N' _____           _               _                 ' ) 		,
        ( 2, 'Reindex', N'|  __ \         (_)             | |                ' ) 		,
        ( 3, 'Reindex', N'| |__) |   ___   _   _ __     __| |   ___  __  __  ' ) 		,
        ( 4, 'Reindex', N'|  _  /   / _ \ | | | ''_ \   / _` |  / _ \ \ \/ /  ' ) 		,
        ( 5, 'Reindex', N'| | \ \  |  __/ | | | | | | | (_| | |  __/  >  <   ' ) 		,
        ( 6, 'Reindex', N'|_|  \_\  \___| |_| |_| |_|  \__,_|  \___| /_/\_\  ' ) 		,
        ( 7, 'Reindex', N'                                                   ' ) 		,
        ( 8, 'Reindex', N'                                                   ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'CheckDB',          N'  _____   _                     _      _____    ____    ' ),
        ( 2, 'CheckDB',          N' / ____| | |                   | |    |  __ \  |  _ \   ' ),
        ( 3, 'CheckDB',          N'| |      | |__     ___    ___  | | __ | |  | | | |_) |  ' ),
        ( 4, 'CheckDB',          N'| |      | ''_ \   / _ \  / __| | |/ / | |  | | |  _ <   ' ),
        ( 5, 'CheckDB',          N'| |____  | | | | |  __/ | (__  |   <  | |__| | | |_) |  ' ),
        ( 6, 'CheckDB',          N' \_____| |_| |_|  \___|  \___| |_|\_\ |_____/  |____/   ' ),
        ( 7, 'CheckDB',          N'                                                        ' ),
        ( 8, 'CheckDB',          N'                                                        ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'Enterprise',          N'  ______           _                                  _                ' ),
        ( 2, 'Enterprise',          N' |  ____|         | |                                (_)               ' ),
        ( 3, 'Enterprise',          N' | |__     _ __   | |_    ___   _ __   _ __    _ __   _   ___    ___   ' ),
        ( 4, 'Enterprise',          N' |  __|   | ''_ \  | __|  / _ \ | ''__| | ''_ \  | ''__| | | / __|  / _ \  ' ),
        ( 5, 'Enterprise',          N' | |____  | | | | | |_  |  __/ | |    | |_) | | |    | | \__ \ |  __/  ' ),
        ( 6, 'Enterprise',          N' |______| |_| |_|  \__|  \___| |_|    | .__/  |_|    |_| |___/  \___|  ' ),
        ( 7, 'Enterprise',          N'                                      | |                              ' ),
        ( 8, 'Enterprise',          N'                                      |_|                              ' );


INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '1', N' __  ' ) 		,
        ( 2, '1', N'/_ | ' ) 		,
        ( 3, '1', N' | | ' ) 		,
        ( 4, '1', N' | | ' ) 		,
        ( 5, '1', N' | | ' ) 		,
        ( 6, '1', N' |_| ' ) 		,
        ( 7, '1', N'     ' ) 		,
        ( 8, '1', N'     ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '2', N' ___   ' ) 		,
        ( 2, '2', N'|__ \  ' ) 		,
        ( 3, '2', N'   ) | ' ) 		,
        ( 4, '2', N'  / /  ' ) 		,
        ( 5, '2', N' / /_  ' ) 		,
        ( 6, '2', N'|____| ' ) 		,
        ( 7, '2', N'       ' ) 		,
        ( 8, '2', N'       ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '3', N' ____   ' ) 		,
        ( 2, '3', N'|___ \  ' ) 		,
        ( 3, '3', N'  __) | ' ) 		,
        ( 4, '3', N' |__ <  ' ) 		,
        ( 5, '3', N' ___) | ' ) 		,
        ( 6, '3', N'|____/  ' ) 		,
        ( 7, '3', N'       ' ) 		,
        ( 8, '3', N'       ' );


INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '4', N' _  _    ' ) 		,
        ( 2, '4', N'| || |   ' ) 		,
        ( 3, '4', N'| || |_  ' ) 		,
        ( 4, '4', N'|__   _| ' ) 		,
        ( 5, '4', N'   | |   ' ) 		,
        ( 6, '4', N'   |_|   ' ) 		,
        ( 7, '4', N'         ' ) 		,
        ( 8, '4', N'         ' );


INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '5', N' _____  ' ) 		,
        ( 2, '5', N'| ____| ' ) 		,
        ( 3, '5', N'| |__   ' ) 		,
        ( 4, '5', N'|___ \  ' ) 		,
        ( 5, '5', N' ___) | ' ) 		,
        ( 6, '5', N'|____/  ' ) 		,
        ( 7, '5', N'        ' ) 		,
        ( 8, '5', N'        ' );
       
INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '6', N'   __   ' ) 		,
        ( 2, '6', N'  / /   ' ) 		,
        ( 3, '6', N' / /_   ' ) 		,
        ( 4, '6', N'| ''_ \  ' ) 		,
        ( 5, '6', N'| (_) | ' ) 		,
        ( 6, '6', N' \___/  ' ) 		,
        ( 7, '6', N'        ' ) 		,
        ( 8, '6', N'        ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '7', N' ______  ' ) 		,
        ( 2, '7', N'|____  | ' ) 		,
        ( 3, '7', N'    / /  ' ) 		,
        ( 4, '7', N'   / /   ' ) 		,
        ( 5, '7', N'  / /    ' ) 		,
        ( 6, '7', N' /_/     ' ) 		,
        ( 7, '7', N'        ' ) 		,
        ( 8, '7', N'        ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '8', N'  ___   ' ) 		,
        ( 2, '8', N' / _ \  ' ) 		,
        ( 3, '8', N'| (_) | ' ) 		,
        ( 4, '8', N' > _ <  ' ) 		,
        ( 5, '8', N'| (_) | ' ) 		,
        ( 6, '8', N' \___/  ' ) 		,
        ( 7, '8', N'        ' ) 		,
        ( 8, '8', N'        ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '9', N'  ___   ' ) 		,
        ( 2, '9', N' / _ \  ' ) 		,
        ( 3, '9', N'| (_) | ' ) 		,
        ( 4, '9', N' \__, | ' ) 		,
        ( 5, '9', N'   / /  ' ) 		,
        ( 6, '9', N'  /_/   ' ) 		,
        ( 7, '9', N'        ' ) 		,
        ( 8, '9', N'        ' );
		
INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '0', N'  ___   ' ) 		,
        ( 2, '0', N' / _ \  ' ) 		,
        ( 3, '0', N'| | | | ' ) 		,
        ( 4, '0', N'| | | | ' ) 		,
        ( 5, '0', N'| |_| | ' ) 		,
        ( 6, '0', N' \___/  ' ) 		,
        ( 7, '0', N'        ' ) 		,
        ( 8, '0', N'        ' );            

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, '.', N'    ' ) 		,
        ( 2, '.', N'    ' ) 		,
        ( 3, '.', N'    ' ) 		,
        ( 4, '.', N'    ' ) 		,
        ( 5, '.', N' _  ' ) 		,
        ( 6, '.', N'(_) ' ) 		,
        ( 7, '.', N'    ' ) 		,
        ( 8, '.', N'    ' );

INSERT  INTO #asciiArt
        ( TitleOrder, Title, TextRow )
VALUES  ( 1, 'Help', N'   _    _          _          ' ) 		,
        ( 2, 'Help', N'  | |  | |        | |         ' ) 		,
        ( 3, 'Help', N'  | |__| |   ___  | |  _ __   ' ) 		,
        ( 4, 'Help', N'  |  __  |  / _ \ | | | ''_ \  ' ) 		,
        ( 5, 'Help', N'  | |  | | |  __/ | | | |_) | ' ) 		,
        ( 6, 'Help', N'  |_|  |_|  \___| |_| | .__/  ' ) 		,
        ( 7, 'Help', N'                      | |     ' ) 		,
        ( 8, 'Help', N'                      |_|     ' );




DECLARE @MinionVersion FLOAT
      , @MajorVersionNum SMALLINT
      , @MinorVersionNum SMALLINT
      , @isHelp BIT = 1;


-----------------------------------------------
--- Start the string graphic with "Minion":
-----------------------------------------------

CREATE TABLE #string
       (
         TitleOrder INT
       , Title VARCHAR(100)
       , TextRow NVARCHAR(4000)
       );

INSERT  INTO #string
        SELECT  TitleOrder
              , Title
              , TextRow
        FROM    #asciiArt
        WHERE   Title = 'Minion';


-----------------------------------------------
--- IF @Module is not null, add module info:
-----------------------------------------------
IF @Module IS NOT NULL
BEGIN
	SELECT  @MinionVersion = MAX(MinionVersion)
	FROM    Minion.HELPObjects
	WHERE   Module = @Module;

	-- Assign the whole number as the major version number:
	SET @MajorVersionNum = FLOOR(@MinionVersion);

	-- Get just the decimal places - converted to string, removing the "0.", and converting back - as minor version number: 
	SELECT  @MinorVersionNum = CAST(REPLACE(CAST(@MinionVersion
											- FLOOR(@MinionVersion) AS VARCHAR(100)),
											'0.', '') AS SMALLINT);

	-- If anything is null or zero, default to 1.0
	IF ( @MajorVersionNum IS NULL
		 OR @MajorVersionNum = 0
	   )
	   SELECT   @MajorVersionNum = 1
			  , @MinorVersionNum = 0;

	IF ( @MinorVersionNum IS NULL )
	   SELECT   @MinorVersionNum = 0;

	-----------------------------------------------
	--- Add the name of the module:
	-----------------------------------------------
	UPDATE  s
	SET     TextRow = s.TextRow + a.TextRow
	FROM    #string AS s
	JOIN    #asciiArt a
			ON s.TitleOrder = a.TitleOrder
			   AND a.Title = @Module;

	-----------------------------------------------
	--- Add the major version number. Could be 1 digit, 2 or more.
	-----------------------------------------------
	DECLARE @counter INT = 1
		  , @str VARCHAR(10)
		  , @char CHAR(1)
		  , @len SMALLINT;
		  --, @digit SMALLINT;

	SET @str = CAST(@MajorVersionNum AS VARCHAR(10));
	SET @len = LEN(@str);
 
	WHILE @counter <= @len
		  BEGIN
				SELECT  @char = SUBSTRING(@str, @counter, 1);

				UPDATE  s
				SET     TextRow = s.TextRow + a.TextRow
				FROM    #string AS s
				JOIN    #asciiArt a
						ON s.TitleOrder = a.TitleOrder
						   AND a.Title = @char;
	
				SET @counter = @counter + 1;
		  END;

	-----------------------------------------------
	--- Add the period between major and minor version number. 
	-----------------------------------------------

	UPDATE  s
	SET     TextRow = s.TextRow + a.TextRow
	FROM    #string AS s
	JOIN    #asciiArt a
			ON s.TitleOrder = a.TitleOrder
			   AND a.Title = '.';

	-----------------------------------------------
	--- Add the minor version number. Could be 1 digit, 2 or more.
	-----------------------------------------------

	SET @str = CAST(@MinorVersionNum AS VARCHAR(10));
	SET @len = LEN(@str);
	SET @counter = 1;
 
	WHILE @counter <= @len
		  BEGIN
				SELECT  @char = SUBSTRING(@str, @counter, 1);

				UPDATE  s
				SET     TextRow = s.TextRow + a.TextRow
				FROM    #string AS s
				JOIN    #asciiArt a
						ON s.TitleOrder = a.TitleOrder
						   AND a.Title = @char;
	
				SET @counter = @counter + 1;
		  END;
END; -- IF @Module IS NOT NULL


-----------------------------------------------
--- Add "Help"
-----------------------------------------------

   UPDATE   s
   SET      TextRow = s.TextRow + a.TextRow
   FROM     #string AS s
   JOIN     #asciiArt a
            ON s.TitleOrder = a.TitleOrder
               AND a.Title = 'Help';

-----------------------------------------------
--- Print to the screen.
-----------------------------------------------
DECLARE @printStr NVARCHAR(4000);
SET @i = 1;

WHILE @i <= ( SELECT    MAX(TitleOrder)
              FROM      #string
            )
      BEGIN
            SELECT  @printStr = TextRow
            FROM    #string
            WHERE   TitleOrder = @i;
            PRINT @printStr;
            SET @i = @i + 1;
      END;

DROP TABLE #string;
DROP TABLE #asciiArt;

------------------------------------------------------------------------------
--------------END Print ASCII header------------------------------------------
------------------------------------------------------------------------------



------------------------------------------------------------------------------
--------------BEGIN Module help-----------------------------------------------
------------------------------------------------------------------------------
----/ This prints a list of installed modules. This section runs for EXEC Minion.Help;
	IF @Module IS NULL 
		BEGIN --Module

			DECLARE TopLevelHelp CURSOR READ_ONLY
			FOR
				SELECT DISTINCT
						Module
				FROM	Minion.HELPObjects
				WHERE	Module <> 'All'
				ORDER BY Module ASC

			PRINT 'The following Minion modules are installed:'
			OPEN TopLevelHelp

			FETCH NEXT FROM TopLevelHelp INTO @currModule
			WHILE ( @@fetch_status <> -1 ) 
				BEGIN

					PRINT @currModule

					FETCH NEXT FROM TopLevelHelp INTO @currModule
				END

			CLOSE TopLevelHelp
			DEALLOCATE TopLevelHelp

			PRINT ''
			PRINT 'To get information on a module call Minion.HELP with the module name you''re interested in.'
			PRINT ''
			PRINT 'Example:'
			PRINT 'Minion.HELP ''Reindex'''
			PRINT ''
			PRINT 'For a printable version of this documentation go to http://www.MinionWare.net'
			PRINT ''
			PRINT '* By running this software you are agreeing to the terms of the license agreement.'
			PRINT '* You can find a copy of the license agreement here: http://www.MinionWare.net/wp-content/uploads/MinionModulesLicenseAgreement.pdf'

			RETURN;
		END --Module
------------------------------------------------------------------------------
--------------END Module help-------------------------------------------------
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--------------BEGIN Section help----------------------------------------------
------------------------------------------------------------------------------
----/ This prints a list of installed sections (topics). This section runs for EXEC Minion.Help 'Reindex';
	IF @Module IS NOT NULL
		AND @Name IS NULL 
		BEGIN --Name

			PRINT '														  .....................                                                              '
			PRINT '                                                   ...................................                                                       '
			PRINT '                                               ...........................................                                                   '
			PRINT '                                           ...................................................                                               '
			PRINT '                                        .........................................................                                            '
			PRINT '                                      ..............................................................                                         '
			PRINT '                                   ...................................................................                                       '
			PRINT '                                 .......................................................................                                     '
			PRINT '                               ...........................................................................                                   '
			PRINT '                              ............,,,:1OGGGf:....................................................,..                                 '
			PRINT '                            ..........tGBBBBBBBBBBBBBBB;..........................................,,.......,.                                '
			PRINT '                           ........;GBBBBBBBBBBBBBBBBBBBBBBGGGB1:,...............,,......,....,..,.,.,,,,.,,,,                               '
			PRINT '                          .......iGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,...,...,,.,,,.,,....,...,,,,,,,,,,,,,,,,,,.                             '
			PRINT '                         ......:BBBBBBBBBBBBBBBBBBBBBBBBBG1BBBBBBBBBBt..,,.,,,.,iOBOOOOOOtBOOOOOi,,,,,,,,,,,,,,,.                            '
			PRINT '                        ..,...OBBBBBBBBBBBBBBBBBBBBBBBBBBBiOBBBBBBBBBBf.,,,,,tOOOOOOOOOOitOOOOOOOOOt,,,,,,,,,,,,,.                           '
			PRINT '                       ..,..;GBBBBBBBBBBBBBBBBO1;;tOBBBBBB,tBBBBBBBBBBBt.,,:f1BOOOOOOOO1,OOOOOOOOOOOOf.,,,,,,,,,,,                           '
			PRINT '                      ..,;OBBBBBBBBBBBBBBBB;.,,,,,,,,.1Gt.,::;BBBBBBBBBBt,:1OOOOOOOOOOB.:OOOOOOOOOOiOOO,,,,,,,,,,,,                          '
			PRINT '                     .,,,,..1BBBBBBBBBBBO.,,,,,,,,,,,,,,,,,,,,,1BBBBBBBBO,fOOOOOOOOti;;,,,,,fOOOOOOO1tOf,,,,,,,,,,,.                         '
			PRINT '                     ,,,,,,tBBBBBBBBBBG:,,,,,,,,,,,,,,,,,,,,,,,.BBBBBBBB1fOOOOO:,,,,,,,,,,,,,,:OOOOOOttO:,,,,,,,,,,,                         '
			PRINT '                    .,,,,,:GBBBBBBBBB:,,,,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBGiOOOO:,,,,,,,,,,,,,,,,,,iOOOOOiO;,,,,,,,,,,,,                        '
			PRINT '                    ,,,,,,.GBBBBBBB1,,,,,,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBtfOOO,,,,,,,,,,,,,,,,,,,,,;OOOOO;;,,,,,,,,,,,,                        '
			PRINT '                    ,,,,,,iBBB1BBBB,,,,Gf,,,,,,,,,,,,,,,,,,,,,,,tBBBBBBiOOB,,,,,,,,,,,,,,,,,,,,,,,1OOOOi,,,,,,,,,,,,,.                       '
			PRINT '                   .,,,,,iBBBG:,fBB,,,OBBBBG1.,,,,,,,,,,,,,,,,,,1BBBBBB;tO1,,,,,,,,,,,,,,,,,,,,,,,,BOOO1,,,,,,,,,,,,,.                       '
			PRINT '                   .,,,,,.OBBG.,,1B:,;BBB;fGGBBGO,,,,,,,,,,,,,,,iBBBBBB;;B:,,,,,,,,,,,,,,,,,,,,,OO:OOOB1,,,,,,,,,,,,,,                       '
			PRINT '                   .,,,:;OGBBG;,,.t,,;BBB:,,,,.OBBBt,,,,,,,,,,,,OBBBBBBf,1:,,,,,,,,,,,,,fBBOOOOOO1,tO,,,,,,,,,,,,,,,,,                       '
			PRINT '                   .,,,,,,,;BG;,,,,,,,tBBBB:,,,,tBBBBBBBBBBGBt;tBBBBO,,,,,1OOOBOOOOOOBOOOi,,,iOO;,,1:,,,,,,,,,,,,,,,,,                       '
			PRINT '                   .,,,,,,,,,,,,,,,,,,,,BBBBBBBBBt,,;BB:,,,,OBBBBBG;,,,,,,,,fOO:,,,iO,,fOOOOOB;,,,,,,,:OOO:,,,,,,,,,,,                       '
			PRINT '                   .,,,,,,,,,,,,,,,,,,,,,,,,ift,,,,,,BBO,,,,:BBGi,,,,,,,,,,,,,:OOOOO,,,,,,,,,,,,,,,,,,:OOOOf,,,,,,,,,.                       '
			PRINT '                    ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,iBBBBBBBO,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:OOOOf,,,,,,,,.                       '
			PRINT '                    ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:i;:,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,fOOOOi,,,,,,,                        '
			PRINT '                    .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:OOOOO1,,,,,:.                        '
			PRINT '                     ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,OOOOOO1,:,::,                         '
			PRINT '                      ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:,tOOOOOOO:::,,:.                         '
			PRINT '                      .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:,,,:OOOOOOOOO1,::::,                          '
			PRINT '                       ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,::::::::,,::OOOOOOOOOOtt,:,::,                           '
			PRINT '                        ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,:::::::::::::::::,:,:OOOOOOOOOOOBii:::::,                            '
			PRINT '                         ,:,,,,,,,,,,,,,,,,,,:::,,,,,,,,::::::::::::::::::::::::::::::::::fOOOOOOOOOOOOti::::::,                             '
			PRINT '                          ,:,,,,,,,,,,,,,::::::::::::::::::::::::::::::::::::::::::::::iOOOOOOOOOOOOOO::::::::,                              '
			PRINT '                           .:::::::::::::::::::::::::::::::::::::::::::::::::::::::::;O;OOOOOOOOOOOf:::::::::,                               '
			PRINT '                             ,::::::::::::::::::::::::::::::::::::::::::::::::::::::t:OOOOOOOOOOO1::::::::::                                 '
			PRINT '                              .:::::::::::::::::::::::::::::::::::::::::::::::::::::;OOOOOOOOO1:::::::::::,                                  '
			PRINT '                                ,:::::::::::::::::::::::::::::::::::::::::::::::::::BOOOOfi:::::::::::::,                                    '
			PRINT '                                  ,::::::::::::::::::::::::::::::::::::::::::::::::fOOt::::::::::::::::                                      '
			PRINT '                                    ,:::::::::::::::::::::::::::::::::::::::::::::;Of:::::::::::::::,                                        '
			PRINT '                                      .:::::::::::::::::::::::::::::::::::::::::::11::::::::::::::.                                          '
			PRINT '                                         .::::::::::::::::::::::::::::::::::::::::i::::::::::::,                                             '
			PRINT '                                            .:::::::::::::::::::::::::::::::::::::::::::::::.                                                '
			PRINT '                                                .,:::::::::::::::::::::::::::::::::::::,.                                                    '
			PRINT '                                                     .,:::::::::::::::::::::::::::,.                                                         '
			PRINT '                                                             ...,,,,,,,,,...                                                                 '
			PRINT ' '


			SELECT DISTINCT
					ObjectName ,
					ObjectType ,
					GlobalPosition
			INTO	#T1
			FROM	Minion.HELPObjects
			WHERE	Module = @Module
					AND GlobalPosition IS NOT NULL
			ORDER BY GlobalPosition ASC


			DECLARE TopLevelHelp CURSOR READ_ONLY
			FOR
				SELECT	ObjectName ,
						ObjectType
				FROM	#T1
				ORDER BY GlobalPosition ASC

			PRINT 'You may get help on the following topics:'
			PRINT ''
			PRINT 'Section' + REPLICATE(' ', 100 - LEN('Section'))
				+ 'ObjectType'
			PRINT ''
			OPEN TopLevelHelp

			FETCH NEXT FROM TopLevelHelp INTO @currObjectName, @ObjectType
			WHILE ( @@fetch_status <> -1 ) 
				BEGIN

					PRINT @currObjectName + REPLICATE(' ',
													  100
													  - LEN(@currObjectName))
						+ @ObjectType

					FETCH NEXT FROM TopLevelHelp INTO @currObjectName,
						@ObjectType
				END

			CLOSE TopLevelHelp
			DEALLOCATE TopLevelHelp

			PRINT ''
			PRINT ''
			PRINT ''
			PRINT 'To get information on a module call Minion.HELP with the module and section you''re interested in.'
			PRINT ''
			PRINT 'Minion.HELP accepts 2 parameters: module and section.'
			PRINT 'To find the Minion modules installed on the server simply type Minion.HELP without any parameters.'
			PRINT 'Once you find the module you need you can run Minion.HELP with the module parameter you''re interested in.'
			PRINT ''
			PRINT 'Example 1:'
			PRINT 'Minion.HELP ''Reindex'', ''Quick Start'''
			PRINT ''
			PRINT 'You can also get help on any of the Minion objects within that module by calling Minion.HELP in the same manner as above.'
			PRINT 'Just choose the object you want help on from the list of sections above.'
			PRINT ''
			PRINT 'Example 2:'
			PRINT 'Minion.HELP ''Reindex'', ''Minion.IndexMaintDB'''

			PRINT ''
			PRINT 'For a printable version of this documentation go to http://www.MinionWare.net'
			PRINT ''
			PRINT '* By running this software you are agreeing to the terms of the license agreement.'
			PRINT '* You can find a copy of the license agreement here: http://www.MinionWare.net/wp-content/uploads/MinionModulesLicenseAgreement.pdf'

			RETURN;
		END --Name

------------------------------------------------------------------------------
--------------END Section help----------------------------------------------
------------------------------------------------------------------------------


------------------------------------------------------------------------------
--------------BEGIN Topic help------------------------------------------------
------------------------------------------------------------------------------
----/ This prints the details for a particular sections (topic). This section runs for EXEC Minion.Help 'Reindex', 'FAQ';

	IF @Module IS NOT NULL
		AND @Name IS NOT NULL 
		BEGIN --Objects

			SET @colCT = 0;

			DECLARE HelpText CURSOR READ_ONLY
			FOR
				SELECT	O.ObjectType ,
						OD.DetailName ,
						OD.Position ,
						OD.DetailType ,
						OD.DetailHeader ,
						OD.DetailText ,
						OD.DataType ,
						OD.max_length ,
						OD.precision ,
						OD.scale ,
						OD.is_nullable
				FROM	Minion.HELPObjectDetail OD
						INNER JOIN Minion.HELPObjects O ON OD.ObjectID = O.ID
				WHERE	O.Module = @Module
						AND O.ObjectName = @Name
				ORDER BY Position ASC;

			OPEN HelpText;

			FETCH NEXT FROM HelpText INTO @ObjectType, @DetailName, @Position,
				@DetailType, @DetailHeader, @DetailText, @DataType, @MaxLength,
				@Precision, @Scale, @IsNullable
			
			WHILE ( @@fetch_status <> -1 ) 
				BEGIN

					-------------------------------------------------------------
					------BEGIN ObjectType='Information' ------------------------
					-------------------------------------------------------------
					IF @ObjectType = 'Information' 
						BEGIN 

							IF @DetailHeader NOT LIKE 'Troubleshoot:%' 
								BEGIN --TShoot Header

									SET @colWidth = 100;
									SET @DetailText = Minion.FormatHelp(@DetailText, @colWidth, 0);
										
								END --TShoot Header

							-- Commented this out for Reindex 1.1; didn't like the formatting. -JM
							--IF @DetailHeader = 'System Requirements' 
							--	BEGIN

							--		--char(9) = TAB, char(149) = bullet, char(13/10) = carriage return/line feed.
							--		SET @DetailText = CHAR(9) + CHAR(149) + @DetailText;
							--		SET @DetailText = REPLACE(@DetailText,
							--								  '. ',
							--								  '.' + CHAR(13)
							--								  + CHAR(10)
							--								  + CHAR(9)
							--								  + CHAR(149))  
									
							--		SET @DetailText = LEFT(@DetailText, LEN(@DetailText) - 2);
							--	END

							IF @DetailHeader <> 'ObjectName' 
								BEGIN
									PRINT ''
									PRINT @DetailHeader
									PRINT REPLICATE('-', LEN(@DetailHeader))
								END

							IF @DetailType <> 'ObjectName' 
								BEGIN
									PRINT @DetailText
								END

						END --Information
					-------------------------------------------------------------
					------END ObjectType='Information' ------------------------
					-------------------------------------------------------------

					-------------------------------------------------------------
					------BEGIN ObjectType='Procedure' --------------------------
					-------------------------------------------------------------
					IF @ObjectType = 'Procedure' 
						BEGIN --ObjectType

							---- Print the section header, if a separate entry for it exists
							IF @DetailType = 'ObjectName' 
								BEGIN
									PRINT @DetailText 
									PRINT REPLICATE('-', LEN(@DetailText))

								END
							
							---- Print the parameter
							IF @DetailType = 'Param' 
								BEGIN

									SET @colCT = @colCT + 1;
									IF @colCT = 1 
										BEGIN
											PRINT 'Parameter' + REPLICATE(' ',
															  30
															  - LEN('Parameter'))

												+ 'Data Type' + REPLICATE(' ',
															  48
															  - LEN('Parameter'
															  + 'Data Type'))
												+ 'Definition'
											PRINT '---------' + REPLICATE(' ',
															  30
															  - LEN('Parameter'))
												+ '----------' + REPLICATE(' ',
															  47
															  - LEN('Parameter'
															  + 'Data Type'))
												+ '----------'
										END
									SET @DataTypeSpacer = REPLICATE(' ',
															  30
															  - LEN(@DetailName));

									---- Replace newlines with spacer+newline, to format detail text: ----
									SET @DetailTextSpacer = char(13) + REPLICATE(' ', 69) ; -- for newlines.

									-- Replace line feeds with carriage returns
									SET @DetailText = REPLACE(@DetailText, char(10), char(13));
									
									-- Replace double carriage returns with single
									SET @DetailText = REPLACE(@DetailText, char(13)+char(13), char(13));

									-- Add a spacer after the carriage return
									SET @DetailText = REPLACE(@DetailText, char(13), @DetailTextSpacer);

									PRINT @DetailName + REPLICATE(' ', 30 - LEN(@DetailName))
										+ @DataType + REPLICATE(' ', 39 - LEN( @DataType))
										+  LTRIM(ISNULL(Minion.FormatHelp(@DetailText, 100, 69), '')); 

								END

							IF @DetailType <> 'Param'
								AND @DetailType <> 'ObjectName' 
								BEGIN
									-- Print the header/text for Purpose, Important, Discussion, Examples, etc.
									PRINT @DetailHeader
									PRINT REPLICATE('-', LEN(@DetailHeader))
									SET @DetailText = Minion.FormatHelp(@DetailText,130, 0);
									PRINT @DetailText
									PRINT ''
								END
						END --ObjectType
					-------------------------------------------------------------
					------END ObjectType='Procedure' ----------------------------
					-------------------------------------------------------------
					
					
					-------------------------------------------------------------
					------BEGIN DetailType='Advice' ----------------------------
					-------------------------------------------------------------
					IF @DetailType = 'Advice' 
						BEGIN
							PRINT @DetailHeader
							PRINT @DetailText
						END
					-------------------------------------------------------------
					------END DetailType='Advice' ----------------------------
					-------------------------------------------------------------


					-------------------------------------------------------------
					------BEGIN ObjectType='Table' ------------------------------
					-------------------------------------------------------------
					IF @ObjectType = 'Table' 
						BEGIN --Table

							IF @DetailType = 'ObjectName' 
								BEGIN
									PRINT @DetailText 
									PRINT REPLICATE('-', LEN(@DetailText))

								END

--------
							IF @DetailHeader <> 'Column'
								AND @DetailType <> 'ObjectName' 
								BEGIN

									-- Print the header/text for Purpose, Important, Discussion, Examples, etc.
									PRINT @DetailHeader
									PRINT REPLICATE('-', LEN(@DetailHeader))
									SET @DetailText = Minion.FormatHelp(@DetailText,130, 0);
									PRINT @DetailText
									PRINT ''

								END
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
---------------------BEGIN Table Cols-----------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
							IF @DetailType = 'Column' 
								BEGIN --Column
											
									SET @colCT = @colCT + 1;
									IF @colCT = 1 
										BEGIN
											PRINT 'Column Name'
												+ REPLICATE(' ',
															30
															- LEN('Column Name'))
												+ 'Data Type' + REPLICATE(' ',
															  50
															  - LEN('Column Name'
															  + 'Data Type'))
												+ 'Definition'
											PRINT '-----------'
												+ REPLICATE(' ',
															30
															- LEN('Column Name'))
												+ '---------' + REPLICATE(' ',
															  50
															  - LEN('Column Name'
															  + 'Data Type'))
												+ '----------'
										END

									---- Replace newlines with spacer+newline, to format detail text: ----
									SET @DetailTextSpacer = char(13) + REPLICATE(' ', 69) ; -- for newlines.

									-- Replace line feeds with carriage returns
									SET @DetailText = REPLACE(@DetailText, CHAR(10), CHAR(13));

									-- Replace double carriage returns with single
									SET @DetailText = REPLACE(@DetailText, CHAR(13)+CHAR(13), CHAR(13));
									
									-- Add a spacer after the carriage return
									SET @DetailText = REPLACE(@DetailText, CHAR(13), @DetailTextSpacer);
									
									PRINT @DetailName + REPLICATE(' ', 30 - LEN(@DetailName))
										+ @DataType + REPLICATE(' ', 39 - LEN( @DataType))
										+ LTRIM(ISNULL(Minion.FormatHelp(@DetailText, 100, 69), '')); 

								END --Column
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
---------------------END Table Cols-------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
						END --Table
					-------------------------------------------------------------
					------END ObjectType='Table' ------------------------------
					-------------------------------------------------------------

					FETCH NEXT FROM HelpText INTO @ObjectType, @DetailName,
						@Position, @DetailType, @DetailHeader, @DetailText,
						@DataType, @MaxLength, @Precision, @Scale, @IsNullable
				END

			CLOSE HelpText
			DEALLOCATE HelpText

		END --Objects
------------------------------------------------------------------------------
--------------END Topic help--------------------------------------------------
------------------------------------------------------------------------------


	PRINT ''
	PRINT 'For a printable version of this documentation go to http://www.MidnightSQL.com/Minion'
	PRINT ''
	PRINT '* By running this software you are agreeing to the terms of the license agreement.'
	PRINT '* You can find a copy of the license agreement here: http://www.MinionWare.net/wp-content/uploads/MinionModulesLicenseAgreement.pdf'

GO

-----------------------------------------END HELP SP ---------------------------------





-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- HELP Tables and Data --------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------

/*

This is the process, including data, for the intaller script:
	Process of loading HELP to a new Minion Reinstall installation:
	
	1. Delete any old Reindex rows from Minion.HelpObjectDetail 
	2. Delete any old Reindex rows from Minion.HelpObjects 
	3. Load all HELP data to temp tables (#HelpObjects and #HelpObjectDetails)
	4. Insert all HelpObjects
	5. Update #HelpObjects and #HelpObjectDetails with the new object IDs from Minion.HelpObjects
	6. Insert all HelpObjectDetail rows
	7. Cleanup

*/

--&--------------------------------------------
-- 1. delete any old Reindex rows from Minion.HelpObjectDetail 
DELETE  FROM Minion.HELPObjectDetail
FROM    Minion.HELPObjects AS O
WHERE   ObjectID = O.ID
        AND O.Module = 'Reindex';
GO

--&--------------------------------------------
-- 2. delete any old Reindex rows from Minion.HelpObjects 
DELETE  Minion.HELPObjects
WHERE   Module = 'Reindex';
GO


--&--------------------------------------------
-- 3. Load all HELP data to temp tables (#HelpObjects and #HelpObjectDetails)
IF OBJECT_ID('tempdb..#HelpObjects') IS NOT NULL
BEGIN
	DROP TABLE #HelpObjects;
END

IF OBJECT_ID('tempdb..#HelpObjectDetail') IS NOT NULL
BEGIN
	DROP TABLE #HelpObjectDetail;
END

CREATE TABLE #HelpObjects
    (
      [ID] [INT] NOT NULL ,
      [Module] [VARCHAR](50) COLLATE DATABASE_DEFAULT NULL ,
      [ObjectName] [VARCHAR](100) COLLATE DATABASE_DEFAULT NULL ,
      [ObjectType] [VARCHAR](100) COLLATE DATABASE_DEFAULT NULL ,
      [Synopsis] [VARCHAR](1000) COLLATE DATABASE_DEFAULT NULL ,
      [Descript] [VARCHAR](MAX) COLLATE DATABASE_DEFAULT NULL ,
      [MinionVersion] [FLOAT] NULL ,
      [GlobalPosition] [INT] NULL ,
      NewObjectID INT NULL
    );

CREATE TABLE #HelpObjectDetail
    (
      [ObjectID] [INT] NULL ,
      [DetailName] [VARCHAR](100) COLLATE DATABASE_DEFAULT NULL ,
      [GlobalPosition] [SMALLINT] NULL ,
      [Position] [SMALLINT] NULL ,
      [DetailType] [sysname] COLLATE DATABASE_DEFAULT NULL ,
      [DetailHeader] [VARCHAR](100) COLLATE DATABASE_DEFAULT NULL ,
      [DetailText] [VARCHAR](MAX) COLLATE DATABASE_DEFAULT NULL ,
      [Datatype] [VARCHAR](20) COLLATE DATABASE_DEFAULT NULL ,
      [max_length] [SMALLINT] NULL ,
      [precision] [TINYINT] NULL ,
      [scale] [TINYINT] NULL ,
      [is_nullable] [BIT] NULL ,
      updated BIT NULL
    );


---- INSERTS GO HERE ---- 
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (1, N'Reindex', N'Minion.IndexMaintDB', N'Procedure', N'Performs index maintenance for tables that meet the criteria stored in master..IndexMaint.', N'This procedure should not be called manually.  It should be called by Minion.IndexMaintMaster.  For information on calling this procedure properly run Minion.IndexMaintMaster ''HELP''', 1.2, 130)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (2, N'Reindex', N'Minion.IndexSettingsTable', N'Table', N'', N'Table that holds table-level overrides.', 1.2, 90)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (3, N'Reindex', N'Minion.IndexPhysicalStats', N'Table', N'', N'Table that holds raw fragmentation stats for later investigation.', 1.2, 100)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (4, N'Reindex', N'Minion.IndexMaintLogDetails', N'Table', N'', N'Table that holds index-level log data.', 1.2, 115)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (5, N'Reindex', N'Minion.IndexMaintLog', N'Table', N'', N'Tables that holds database-level log data.', 1.2, 110)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (7, N'Reindex', N'Minion.IndexTableFrag', N'Table', N'', N'Holds PrepOnly data as well as realtime processing data for index operations.', 1.2, 105)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (13, N'Reindex', N'Minion.IndexMaintMaster', N'Procedure', N'', N'This is the main procedure.  It is responsible for making decisions on which databases will be processed, and hands each one off to Minion.IndexMaintDB for processing.', 1.2, 125)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (16, N'Reindex', N'Minion.DBMaintRegexLookup', N'Table', N'', N'Holds regex expressions to exclude databases from processing.', 1.2, 95)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (58, N'Reindex', N'Quick Start', N'Information', NULL, NULL, 1.2, 5)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (59, N'Reindex', N'Top 10 Features', N'Information', NULL, NULL, 1.2, 10)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (60, N'Reindex', N'Architecture Overview', N'Information', NULL, NULL, 1.2, 15)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (61, N'Reindex', N'How To: Configure settings for a single database', N'Information', NULL, NULL, 1.2, 20)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (62, N'Reindex', N'How To: Configure settings for a single table', N'Information', NULL, NULL, 1.2, 25)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (63, N'Reindex', N'How To: Reindex databases in a specific order', N'Information', NULL, NULL, 1.2, 30)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (64, N'Reindex', N'Minion.HELP', N'Procedure', NULL, NULL, 1.2, 135)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (66, N'Reindex', N'Minion.IndexSettingsDB', N'Table', NULL, NULL, 1.2, 85)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (68, N'Reindex', N'How To: Reindex tables in a specific order', N'Information', NULL, NULL, 1.2, 35)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (69, N'Reindex', N'How To: Generate Reindex Statement Only', N'Information', NULL, NULL, 1.2, 40)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (70, N'Reindex', N'How To: Reindex only indexes that are marked ONLINE = ON (or, only ONLINE = OFF)', N'Information', NULL, NULL, 1.2, 45)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (71, N'Reindex', N'How To: Gather index fragmentation statistics on a different schedule from the reindex routine', N'Information', NULL, NULL, 1.2, 50)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (72, N'Reindex', N'How To: Exclude databases from index maintenance', N'Information', NULL, NULL, 1.2, 55)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (73, N'Reindex', N'How To: Exclude a table from index maintenance', N'Information', NULL, NULL, 1.2, 60)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (75, N'Reindex', N'How To: Reindex databases on different schedules', N'Information', NULL, NULL, 1.2, 70)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (76, N'Reindex', N'Overview of Procedures', N'Information', NULL, NULL, 1.2, 120)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (77, N'Reindex', N'Overview of Jobs', N'Information', NULL, NULL, 1.2, 140)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (78, N'Reindex', N'About Us', N'Information', NULL, NULL, 1.2, 145)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (82, N'Reindex', N'How To: Run code before or after index maintenance', N'Information', NULL, NULL, 1.2, 65)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (83, N'Reindex', N'How To: Configure how long the reindex logs are kept', N'Information', NULL, NULL, 1.2, 75)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (112, N'Reindex', N'Overview of Tables', N'Information', NULL, NULL, 1.2, 80)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (113, N'Reindex', N'Troubleshoot: ONLINE was set, but all or some of the indexes are being done OFFLINE.', N'Information', N'', N'', 1.2, 250)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (114, N'Reindex', N'Troubleshoot: Why is a certain database not being processed?', N'Information', N'', N'', 1.2, 250)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (115, N'Reindex', N'Troubleshoot: Nothing happens when I run a specific database.', N'Information', N'', N'', 1.2, 250)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (116, N'Reindex', N'Troubleshoot: Some tables aren’t reindexing at the proper threshold.', N'Information', N'', N'', 1.2, 250)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (117, N'Reindex', N'Troubleshoot: Not all indexes in the Minion.IndexMaintLogDetails table are marked "Complete".', N'Information', N'', N'', 1.2, 250)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (125, N'Reindex', N'Revisions', N'Information', NULL, NULL, 1.2, 143)
GO
INSERT #HelpObjects ([ID], [Module], [ObjectName], [ObjectType], [Synopsis], [Descript], [MinionVersion], [GlobalPosition]) VALUES (126, N'Reindex', N'FAQ', N'Information', NULL, NULL, 1.2, 144)
GO




INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@DBName', 1, 3, N'Param', N'@DBName', N'Name of the database being reindexed.', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@IndexOption', 1, 3, N'Param', N'@IndexOption', N'Picks the online option for the indexes. Some indexes can only be rebuilt offline. This option allows you to specify whether you want the online, offline, or all indexes to be processed. This is very common in situations where you don''t want offline reindexing to occur during the week, for example. This way you can run the offline reindexes only during the slow times. Valid Options: All, Online, Offline', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@PrepOnly', 1, 6, N'Param', N'@PrepOnly', N'Allows you to gather the index fragmentation stats before your maintenance window. Many shops have tight maintenance windows and gathering the index fragmentation stats can take a very long time on large databases. That eats into your maintenance window significantly. This way you can setup a job to run earlier in the day to gather the stats, using this parameter. Then you can run the job during your maintenance window with the @RunPrepped flag.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@ReorgMode', 1, 3, N'Param', N'@ReorgMode', N'Chooses whether you want to do reorgs, rebuilds, or both. Sometimes you don''t want to do rebuilds during the week so you save them for the weekend. With this option you can make sure that you don''t do rebuild during your busy times. Simply create 2 separate jobs, one with REORG and the other with REBUILD or ALL. When using the REORG option, indexes that would ordinarily be rebuilt because they crossed the rebuild threshold, will be reorged instead. When using the REBUILD option, any indexes that fall below the reorg threshold and the rebuild threshold will be ignored. Only indexes that are above the reindex threshold will be processed. Valid Options: REORG, REBUILD, ALL.', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@RunPrepped', 1, 5, N'Param', N'@RunPrepped', N'Allows you to run the reindex operations off of previously gathered fragmentation stats. Many shops have tight maintenance windows and gathering the index fragmentation stats can take a very long time on large databases. That eats into your maintenance window significantly. This way you can setup a job to run earlier in the day to gather the stats using the @PrepOnly parameter. Then you can run the job during your maintenance window with @RunPrepped = 1.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'@StmtOnly', 1, 7, N'Param', N'@StmtOnly', N'Allows you to print the reorg or rebuild statements instead of running them. This is helpful when you just want to see which indexes are past their thresholds, and when you want to just pick and choose certain indexes to process. Either way, this is a powerful feature that''s easy to use and notice how we don''t make you alter the procedure to print the statements?', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'About', 1, 9, N'Advice', N'About Minion.IndexMaintMaster', N'The Minion.IndexMaintMaster procedure is what makes all the decisions on which datbases to backup, and what order they should be in. You *could* call this one manually if you like if you were going to run an individual database. However, even then the preferred usage is to run the Minion.IndexMaintMaster procedure and just include the single database you''re interested by putting it in the @Include parameter. There are a couple reasons why it is recommended to run the procedures this way. First, it unifies your code and therefore minimizes your effort. By calling the same procedure every time you reduce your learning curve and therefore reducing mistakes. Second, there may be functionality moved to the Minion.IndexMaintMaster procedure in the future and if you get used to using it now, then things will always work as intended.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'Example 1', 1, 10, N'Example', N'Example 1', N'Coming soon.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'ObjectName', 1, 1, N'ObjectName', N'ObjectName', N'Minion.IndexMaintDB', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'Purpose', 1, 2, N'Purpose', N'Purpose', N'The Minion.IndexMaintDB stored procedure performs index maintenance for a single database. Minion.IndexMaintDB is the procedure that creates and runs the actual reindex statements for tables that meet the criteria stored in the settings tables (Minion.IndexSettingsDB and Minion.IndexSettingsTable). IMPORTANT: We HIGHLY recommend using Minion.IndexMaintMaster for all of your reindex operations, even when reindexing a single database. Do not call Minion.IndexMaintDB to perform index maintenance. The Minion.IndexMaintMaster procedure makes all the decisions on which databases to reindex, and what order they should be in. It''s certainly possible to call Minion.IndexMaintDB manually, to run an individual database, but we instead recommend using the Minion.IndexMaintMaster procedure (and just include the single database using the @Include parameter). First, it unifies your code, and therefore minimizes your effort. By calling the same procedure every time you reduce your learning curve and cut down on mistakes. Second, future functionality may move to the Minion.IndexMaintMaster procedure; if you get used to using Minion.IndexMaintMaster now, then things will always work as intended.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (1, N'RunPrepped vs PrepOnly', 1, 8, N'Advice', N'RunPrepped vs PrepOnly', N'The @RunPrepped and @PrepOnly parameters are incompatible. Only one can be turned on at a time. If they''re both turned on this will throw a logic error as you can''t prep the stats and use them at the same time.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'AbortAfterWait', 2, 31, N'Column', N'Column', N'Enable or disable the ABORT_AFTER_WAIT option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: NONE SELF BLOCKERS', N'varchar (20)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'AllowPageLocks', 2, 28, N'Column', N'Column', N'Enable or disable the ALLOW_PAGE_LOCKS option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'AllowRowLocks', 2, 27, N'Column', N'Column', N'Enable or disable the ALLOW_ROW_LOCKS option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'DataCompression', 2, 20, N'Column', N'Column', N'The data compression option. The options are as follows: Valid inputs: NONE ROW PAGE COLUMNSTORE COLUMNSTORE_ARCHIVE', N'varchar (50)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'DBName', 2, 7, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'Discussion', 2, 43, N'Discussion', N'Discussion', N'Insert a new row for a single table in [YourDatabase], if you wish to specify different default values for the reorg threshold, rebuild threshold, fill factor, and so on. Important: Any row inserted for an individual table overrides only ALL of the values for that table, whether or not they are specified. Refer to the following for an example: ID DBName SchemaName TableName Exclude ReorgThreshold 1 YourDatabase dbo Table1 0 15 The first row specifies values for Table1 in YourDatabase. This row completely overrides all other values for that table. When index operations are performed for Table1, only the values from the Table1 row will be used. Even though the ReorgThreshold value may be specified in Minion.IndexSettingsDB for [YourDatabase] – and there is most definitely a default value specified there - Table1 will not use that database-level value.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'ReorgThreshold', 2, 13, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should reorganize an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'SchemaName', 2, 8, N'Column', N'Column', N'Schema name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'Examples', 2, 44, N'Examples', N'Examples', N'Set custom thresholds, fill factor, and PadIndex for Table1. INSERT INTO [Minion].[IndexSettingsTable] ( DBName , SchemaName , TableName , Exclude , ReorgThreshold , RebuildThreshold , FILLFACTORopt , PadIndex ) VALUES (''YourDatabase'' -- DBName , ''dbo'' -- SchemaName , ''Table1'' -- TableName , 0 -- Exclude , 15 -- ReorgThreshold , 25 -- RebuildThreshold , 90 -- FILLFACTORopt , ''ON'' -- PadIndex ); NOTE: While it is possible to exclude a single table from reindexing, by setting both the ReorgThreshold and RebuildThreshold above 100% for that database, we do not recommend this approach. Instead, set the Exclude column to 1 for that table. NOTE: To ensure a table is reindexed at every run, set the ReorgThreshold at 0%.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'Exclude', 2, 10, N'Column', N'Column', N'Exclude table from index maintenance. For more on this topic, see “How To: Exclude Databases from Index Maintenance”.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'FILLFACTORopt', 2, 15, N'Column', N'Column', N'Specify how full a reindex maintenance should make each page when it rebuilds an index. For example, a value of 85 would leave each data page 85% full of data. A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'GetPostFragLevel', 2, 22, N'Column', N'Column', N'Get the level of fragmentation for each index, after the index maintenance operations are complete.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'GetRowCT', 2, 21, N'Column', N'Column', N'Get a rowcount for this table.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'GroupOrder', 2, 11, N'Column', N'Column', N'Group to which this table belongs. Used solely for determining the order in which tables should be processed for index maintenance. By default, all tables have a value of 0, which means they’ll be processed in the order they’re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'ID', 2, 6, N'Column', N'Column', N'Primary key row identifier.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'IgnoreDupKey', 2, 25, N'Column', N'Column', N'Change the option so that for this index, inserts that add (normally illegal) duplicates generate a warning instead of an error. Applies to inserts that occur any time after the index operation. The default is OFF. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'IncludeUsageDetails', 2, 42, N'Column', N'Column', N'Save index usage details from sys.dm_db_index_usage_stats, to Minion.IndexMaintLogDetails.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'IndexScanMode', 2, 34, N'Column', N'Column', N'Valid inputs: Detailed Limited NULL A value of NULL indicates that reindexing should use the default (in this case, “LIMITED”).', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'isLOB', 2, 40, N'Column', N'Column', N'Internal use.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'LogIndexPhysicalStats', 2, 33, N'Column', N'Column', N'Save the current index physical stats to a table.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'LogProgress', 2, 37, N'Column', N'Column', N'Track the progress of index operations for this table. The overall index maintenance status is tracked in the Minion.IndexMaintLog table, while specific operations are tracked in the Status column Minion.IndexMaintLogDetails.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'LogRetDays', 2, 38, N'Column', N'Column', N'Number of days to retain index maintenance log data, for this table. Just like any setting, if a table-specific row exists (in Minion.IndexSettingTable), those settings take precedence over database level settings. That is, if DB1.Table1 has an entry for LogRetDays=50, and DB1 has an entry for LogRetDays=40, the log will keep 50 days for DB1.Table1. When first implemented, Minion Reindex defaults to 60 days of log retention.', N'smallint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'MAXDOPopt', 2, 19, N'Column', N'Column', N'Specify the max degree of parallelism (“MAXDOP”, the number of CPUs to use) for the index maintenance operations. If specified, this overrides the MAXDOP configuration option for the duration of the index operation.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'MaxDurationInMins', 2, 30, N'Column', N'Column', N'Set the MAX_DURATION option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'ObjectName', 2, 1, N'ObjectName', N'ObjectName', N'Minion.IndexSettingsTable', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'ONLINEopt', 2, 17, N'Column', N'Column', N'Perform ONLINE index maintenance for indexes in this database. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”, meaning the index maintenance will be done offline). Note that ONLINE index operations may not be possible for certain editions of SQL Server, and only for indexes that are eligible for ONLINE index operations. If you specify ONLINE when it is not possible, the routine will change it to OFFLINE.', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'PadIndex', 2, 16, N'Column', N'Column', N'Turn PAD_INDEX on or off. Valid inputs: ON OFF A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'PartitionReindex', 2, 39, N'Column', N'Column', N'Future use.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'Purpose', 2, 2, N'Purpose', N'Purpose', N'This table holds index maintenance default settings at the table level. You may insert rows for individual tables to override the default index maintenance settings (per table). Any table that does not have a value in this table will get all of its index maintenance settings from the Minion.IndexSettingsDB table. For example, if FillFactorOpt is set at 90 in Minion.IndexSettingsDB, but a row for Table1 here has FillFactorOpt at 95, then the 95 value is used. (If FillFactorOpt is left at NULL in the Minion.IndexSettingsTable row, the database level setting is still not used. Instead, the current index setting in sys.indexes will be used.) Note that many shops will have no values in this table, if there is no need for ordering the tables for reindex, or for setting options for specific tables.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'PushToMinion', 2, 32, N'Column', N'Column', N'Save these values to the central Minion server, if it exists. Modifies values for this particular table on the central Minion server. A value of NULL indicates that this feature is off. Functionality not yet supported.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'RebuildThreshold', 2, 14, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should rebuild an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'ReindexOrder', 2, 12, N'Column', N'Column', N'The index maintenance order within a group. Used solely for determining the order in which tables should be processed for index maintenance. By default, all tables have a value of 0, which means they’ll be processed in the order they’re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. We recommend leaving some space between assigned reindex order numbers (e.g., 10, 20, 30) so there is room to move or insert rows in the ordering. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'StmtPrefix', 2, 14, N'Column', N'Column', N'This column allows you to prefix every reindex statement with a statement of your own.  This is different from the table precode and postcode, because it is run in the same batch. Whereas, precode and postcode are run as completely separate statements, in different contexts.  
Code entered in this column MUST end in a semicolon.
For more information, see “How To: Run code before or after index maintenance”.', N'nvarchar', NULL, NULL, NULL, NULL);
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'StmtSuffix', 2, 16, N'Column', N'Column', N'This column allows you to suffix every reindex statement with a statement of your own.  This is different from the table precode and postcode, because it is run in the same batch. Whereas, precode and postcode are run as completely separate statements, in different contexts.  
Code entered in this column MUST end in a semicolon.
For more information, see “How To: Run code before or after index maintenance”.', N'nvarchar', NULL, NULL, NULL, NULL);
GO

INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'SortInTempDB', 2, 18, N'Column', N'Column', N'Direct index maintenance to use TempDB to store the intermediate sort results that are used to build the index. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'StatScanOption', 2, 24, N'Column', N'Column', N'Options available for the UPDATE STATISTICS statement (that is, anything that would go in the “WITH” statement). Valid inputs include any of the following options, as a comma-delimited list: FULLSCAN SAMPLE … RESAMPLE ON PARTITIONS ... STATS_STREAM ROWCOUNT PAGECOUNT For example, StatScanOption could be set to “SAMPLE 50 PERCENT”, or “FULLSCAN, NORECOMPUTE”.', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'StatsNoRecompute', 2, 26, N'Column', N'Column', N'Disable the automatic statistics update option, AUTO_UPDATE_STATISTICS. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'TableName', 2, 9, N'Column', N'Column', N'Table name.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'TablePostCode', 2, 36, N'Column', N'Column', N'Code to run for this table, after the index maintenance operations complete for that table. Note: To run postcode once after each and every individual table in a database, use the TablePreCode column in Minion.IndexSettingsDB. For more on this topic, see “How To: Run code before or after index maintenance”.', N'varchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'TablePreCode', 2, 35, N'Column', N'Column', N'Code to run for this table, before the index maintenance operations begin for that table. Note: To run precode once before each and every individual table in a database, use the TablePreCode column in Minion.IndexSettingsDB. For more on this topic, see “How To: Run code before or after index maintenance”.', N'varchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'TableType', 2, 41, N'Column', N'Column', N'Internal use.', N'char (1)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'UpdateStatsOnDefrag', 2, 23, N'Column', N'Column', N'Update statistics after defragmenting. This should always be on, but Minion provides the option just in case your stats are handled in some other way.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'Use', 2, 4, N'Use', N'Use', N'Insert a new row for each individual table that requires specific table-level values for index maintenance.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (2, N'WaitAtLowPriority', 2, 29, N'Column', N'Column', N'Enable or disable the WAIT_AT_LOW_PRIORITY option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'alloc_unit_type_desc', 3, 15, N'Column', N'Column', N'Allocation type unit, e.g. IN_ROW_DATA, LOB_DATA, ROW_OVERFLOW_DATA. * See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'nvarchar (60)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'avg_fragment_size_in_pages', 3, 20, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'float', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'avg_fragmentation_in_percent', 3, 18, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'float', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'avg_page_space_used_in_percent', 3, 22, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'float', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'avg_record_size_in_bytes', 3, 28, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'float', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'BatchDateTime', 3, 4, N'Column', N'Column', N'Date and time the index physical stats data was gathered.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'compressed_page_count', 3, 30, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'database_id ', 3, 10, N'Column', N'Column', N'Database ID. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'smallint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'DBName', 3, 6, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'ExecutionDateTime', 3, 3, N'Column', N'Column', N'The execution date and time, common to the entire run of a database index maintenance event.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'forwarded_record_count', 3, 29, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'fragment_count', 3, 19, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'ghost_record_count', 3, 24, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'index_depth', 3, 16, N'Column', N'Column', N'Number of index levels. Note that 1 means the table is a HEAP. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'index_id', 3, 12, N'Column', N'Column', N'Index ID. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'index_level', 3, 17, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'index_type_desc', 3, 14, N'Column', N'Column', N'Description of index type, e.g. HEAP, CLUSTERED, NONCLUSTERED, etc. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'nvarchar (60)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'IndexName', 3, 9, N'Column', N'Column', N'Index name.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'IndexScanMode', 3, 5, N'Column', N'Column', N'Scan level that is used to obtain statistics. This is equivalent to the ‘mode’ input for sys.dm_index_physical_stats.', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'max_record_size_in_bytes', 3, 27, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'min_record_size_in_bytes', 3, 26, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'object_id', 3, 11, N'Column', N'Column', N'Object ID. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'ObjectName', 3, 1, N'ObjectName', N'ObjectName', N'Minion.IndexPhysicalStats', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'page_count', 3, 21, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'partition_number', 3, 13, N'Column', N'Column', N'Partition ID. See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'Purpose', 3, 2, N'Purpose', N'Purpose', N'Stores the raw data from sys.dm_db_index_physical_stats. You can optionally save index size and fragmentation information to Minion.IndexPhysicalStats for use in investigating issues, as needed. To turn on IndexPhysicalStats logging, set the LogIndexPhysicalStats field to 1 for a database or table (in Minion.IndexSettingsDB or Minion.IndexSettingsTable, respectively). Data will be saved to Minion.IndexPhysicalStats for each index maintenance run thereafter. WARNING: LogIndexPhysicalStats is turned off by default because it can generate large amounts of data, and the table is currently not part of the log retention cleanup process. We recommend you use this feature only as needed. NOTE: Even if LogIndexPhysicalStats is enabled, this table will not store data for any table or database that is excluded from index maintenance, because the index process does not gather fragmentation stats for excluded tables\databases.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'record_count', 3, 23, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'SchemaName', 3, 7, N'Column', N'Column', N'Schema name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'TableName', 3, 8, N'Column', N'Column', N'Table name.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (3, N'version_ghost_record_count', 3, 25, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188917.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'DBName', 4, 33, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Discussion', 4, 89, N'Discussion', N'Discussion', N'The data available in this log includes the status of the operation, the object information, the statement used, operation type, reorg and rebuild thresholds, index usage information, and more.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ExecutionDateTime', 4, 31, N'Column', N'Column', N'Date and time the entire reindex operation took place. If the job were started through IndexMaintMaster then all databases in that run have the same ExecutionDateTime. If the job was run manually from Minion.IndexMaintDB, then this value will only be for this database. It will still have a matching row in the Minion.IndexMaintLog table.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'FragLevel', 4, 45, N'Column', N'Column', N'The fragmentation level of the current index at the time the fragmentation stats were taken. If they were taken earlier in the day as part of a PrepOnly run, then they may not match current fragmentation stats.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'GroupOrder', 4, 47, N'Column', N'Column', N'Group to which this table belongs. Used solely for determining the order in which tables should be processed for index maintenance. Most of the time this will be 0. However, if you choose to take advantage of this feature a row in Minion.IndexSettingsTable will get you there. This is a weighted list so higher numbers are more important and will be processed first. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ID', 4, 30, N'Column', N'Column', N'Primary key row identifier.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'IndexID', 4, 37, N'Column', N'Column', N'The index ID from sys.indexes.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'IndexName', 4, 38, N'Column', N'Column', N'The index name from sys.indexes.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'IndexScanMode', 4, 40, N'Column', N'Column', N'Either NULL, Limited, or Detailed. NULL means that nothing was entered into the column in either Minion.IndexSettingsDB or Minion.IndexSettingsTable and therefore the default (Limited) was used.', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'IndexTypeDesc', 4, 39, N'Column', N'Column', N'The index type description from sys.indexes.', N'varchar (50)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastSystemLookup', 4, 86, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastSystemScan', 4, 85, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastSystemSeek', 4, 84, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastSystemUpdate', 4, 87, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastUserLookup', 4, 78, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastUserScan', 4, 77, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastUserSeek', 4, 76, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'LastUserUpdate', 4, 79, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ObjectName', 4, 28, N'ObjectName', N'ObjectName', N'Minion.IndexMaintLogDetails', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'OnlineOpt', 4, 42, N'Column', N'Column', N'NULL, On, Off. If NULL, then nothing was entered into either the Minion.IndexSettingsDB or Minion.IndexSettingsTable tables, and the default (OFF) is used. So the operation was either done offline or online.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Op', 4, 41, N'Column', N'Column', N'Operation. Valid inputs are Reorg or Rebuild. This is the type of operation performed in the current index.', N'varchar (10)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'OpBeginDateTime', 4, 51, N'Column', N'Column', N'Date and time the reindex statement began running.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'OpEndDateTime', 4, 52, N'Column', N'Column', N'Date and time the reindex statement finished running.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'OpRunTimeInSecs', 4, 53, N'Column', N'Column', N'How many seconds the reindex statement took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostCode', 4, 50, N'Column', N'Column', N'Any postcode run after the table is processed. If the table has multiple indexes the postcode will only be run once.', N'varchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostCodeBeginDateTime', 4, 69, N'Column', N'Column', N'Date and time the postcode for the table began.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostCodeEndDateTime', 4, 70, N'Column', N'Column', N'Date and time the postcode for the table finished.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostCodeRunTimeInSecs', 4, 71, N'Column', N'Column', N'How many seconds the table postcode took.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostFragBeginDateTime', 4, 58, N'Column', N'Column', N'Date and time the post fragmentation statement began. The post fragmentation level is explained above in the Minion.IndexSettingsDB and Minion.IndexSettingsTable tables.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostFragEndDateTime', 4, 59, N'Column', N'Column', N'Date and time the post fragmentation statement finished. The post fragmentation level is explained above in the Minion.IndexSettingsDB and Minion.IndexSettingsTable tables.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostFragLevel', 4, 61, N'Column', N'Column', N'The fragmentation level of the index immediately after the reindex operation finished. This is an excellent way to see the effectiveness of your routines and whether you need to adjust your threshold levels for individual tables.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PostFragTimeInSecs', 4, 60, N'Column', N'Column', N'How many seconds the post fragmentation stats collection took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PreCode', 4, 49, N'Column', N'Column', N'Any precode run before the table is processed. If the table has multiple indexes the precode will only be run once.', N'varchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PreCodeBeginDateTime', 4, 66, N'Column', N'Column', N'Date and time the precode for the table began.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PreCodeEndDateTime', 4, 67, N'Column', N'Column', N'Date and time the precode for the table finished.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'PreCodeRunTimeInSecs', 4, 68, N'Column', N'Column', N'How many seconds the table precode took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Purpose', 4, 2, N'Purpose', N'Purpose', N'Keeps a record of individual index maintenance activities. It contains one time-stamped row for each individual index operation (e.g., a single index rebuild).', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ReindexOrder', 4, 48, N'Column', N'Column', N'The ordering of the tables within the previous group. Most of the time this will be 0. However, if you choose to take advantage of this feature a row in Minion.IndexSettingsTable will get you there. This is a weighted list so higher numbers are more important and will be processed first. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ReindexThreshold', 4, 44, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should rebuild an index.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'ReorgThreshold', 4, 43, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should reorganize an index.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'SchemaName', 4, 35, N'Column', N'Column', N'Schema name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Status', 4, 32, N'Column', N'Column', N'Current status of the index operation. If Live Insight is being used the status updates will appear here. When finished, this column will either read ‘Complete’ or ‘FATAL ERROR: error message’. The one exception is when the job has been run with PrepOnly = 1. When running with PrepOnly = 1, this column is updated with the index fragmentation gather stats. For example, say that you were pulling fragmentation stats for 7 indexes with PrepOnly = 1. The final status message would look something like this: ‘7 of 7: GATHERING FRAG STATS: dbo.fragment.ix_fragment2’. This shows you that all 7 of the fragmentation stats were collected.', N'varchar (500)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Stmt', 4, 46, N'Column', N'Column', N'The reindex statement that was run.', N'nvarchar (1000)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'SystemLookups', 4, 82, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'SystemScans', 4, 81, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'SystemSeeks', 4, 80, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'SystemUpdates', 4, 83, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableID', 4, 34, N'Column', N'Column', N'The table ID in sysobjects.', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableName', 4, 36, N'Column', N'Column', N'Table name.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableRowCT', 4, 57, N'Column', N'Column', N'The count of rows in the table. Therefore, all indexes for a single table will have the exact same row counts.', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableRowCTBeginDateTime', 4, 54, N'Column', N'Column', N'Internal use.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableRowCTEndDateTime', 4, 55, N'Column', N'Column', N'Internal use.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'TableRowCTTimeInSecs', 4, 56, N'Column', N'Column', N'Internal use.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UpdateStatsBeginDateTime', 4, 62, N'Column', N'Column', N'Date and time update statistics began. This will only be populated if the operation is a REORG and the UpdateStatsOnDefrag column in either Minion.IndexSettingsDB or Minion.IndexSettingsTable is set to 1. The value should always be set to 1 unless you have a specific reason not to.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UpdateStatsEndDateTime', 4, 63, N'Column', N'Column', N'Date and time update statistics finished. This will only be populated if the operation is a REORG and the UpdateStatsOnDefrag column in either Minion.IndexSettingsDB or Minion.IndexSettingsTable is set to 1. The value should always be set to 1 unless you have a specific reason not to.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UpdateStatsStmt', 4, 65, N'Column', N'Column', N'The exact update statistics statement that was run.', N'varchar (1000)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UpdateStatsTimeInSecs', 4, 64, N'Column', N'Column', N'How many seconds the update statistics statement took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UserLookups', 4, 74, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UserScans', 4, 73, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UserSeeks', 4, 72, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'UserUpdates', 4, 75, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188755.aspx', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (4, N'Warnings', 4, 88, N'Column', N'Column', N'Reserved for future use.', N'varchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBName', 5, 6, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPostCode', 5, 21, N'Column', N'Column', N'Any database-level code that was run after it processed all the tables.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPostCodeBeginDateTime', 5, 24, N'Column', N'Column', N'Date and time the postcode started.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPostCodeEndDateTime', 5, 25, N'Column', N'Column', N'Date and time the postcode ended.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPostCodeRunTimeInSecs', 5, 27, N'Column', N'Column', N'How many seconds the postcode took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPreCode', 5, 20, N'Column', N'Column', N'Any database-level code that was run before it processed any tables.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPreCodeBeginDateTime', 5, 22, N'Column', N'Column', N'Date and time the precode started.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPreCodeEndDateTime', 5, 23, N'Column', N'Column', N'Date and time the precode ended.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'DBPreCodeRunTimeInSecs', 5, 26, N'Column', N'Column', N'How many seconds the precode took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'Discussion', 5, 30, N'Discussion', N'Discussion', N'Discussion: Each row contains the database name, the start and end time of the index maintenance event, and much more.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ExecutionDateTime', 5, 4, N'Column', N'Column', N'Date and time of the entire run. If several databases are run in the same job then this value will be the same for all of them. Join ExecutionDatetime and DBName with the same columns in the IndexMaintDetails table to see full details.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ExecutionFinishTime', 5, 28, N'Column', N'Column', N'Date and time the entire database reindex operation finished.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ExecutionRunTime', 5, 29, N'Column', N'Column', N'How many seconds the database reindex operation took.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ID', 5, 3, N'Column', N'Column', N'IDENTITY column; primary key row identifier.', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'NumIndexesProcessed', 5, 12, N'Column', N'Column', N'The number of indexes processed for the current database.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'NumIndexesRebuilt', 5, 13, N'Column', N'Column', N'The number of indexes rebuilt for the current database.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'NumIndexesReorged', 5, 14, N'Column', N'Column', N'The number of indexes reorged for the current database.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'NumTablesProcessed', 5, 11, N'Column', N'Column', N'The number of tables processed for the current database.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ObjectName', 5, 1, N'ObjectName', N'ObjectName', N'Minion.IndexMaintLog', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'PrepOnly', 5, 9, N'Column', N'Column', N'This option is used to prepare a reindexing job for later processing. If you have a tight maintenance window and you don''t have time to query the fragmentation stats, you can run the job with this option earlier in the day and it will take the fragmentation stats and save them. Then later you run it with RunPrepped = 1 and it will use the fragmentation stats you just collected. This allows you to use your entire maintenance window for processing indexes instead of wasting part of it on finding the fragmentation. This setting is setting is incompatible with RunPrepped. One or the other must can be set to 1, but not both. However, they can both be set to 0.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'Purpose', 5, 2, N'Purpose', N'Purpose', N'Holds a database level summary of the maintenance operation. This table stores the parameters and settings that were used during the operation, as well as status and summary information. This information can help with troubleshooting, or just stats gathering when you want to see what has happened between one maintenance run to the next. For example, you can use this to determine why a job has wildly varying run times.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'RecoveryModelChanged', 5, 15, N'Column', N'Column', N'0 or 1. Was the recovery model for the current database changed?', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'RecoveryModelCurrent', 5, 16, N'Column', N'Column', N'This is the recovery model of the database before the reindex operation began.', N'varchar (12)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'RecoveryModelReindex', 5, 17, N'Column', N'Column', N'This is the recovery model of the database during the operation. The recovery model can be changed in the IndexSettingsDB table.', N'varchar (12)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'ReorgMode', 5, 10, N'Column', N'Column', N'Shows that the job was called with either REORG, REBUILD, or All. If set to REORG, tables will only be reorged. This includes tables that are past the RebuildThreshold. However, if REBUILD is used, only tables that are past the RebuildThreshold will be processed. Tables between the ReorgThreshold and RebuildThreshold will be ignored.', N'varchar (7)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'RunPrepped', 5, 8, N'Column', N'Column', N'This shows that the job was called with this option set to 1. RunPrepped means that a PrepOnly run was executed before in order to store the fragmentation stats for the indexes. See PrepOnly for more details.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'SQLEdition', 5, 19, N'Column', N'Column', N'The current edition of SQL Server.', N'varchar (50)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'SQLVersion', 5, 18, N'Column', N'Column', N'The current version of SQL Server.', N'varchar (20)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'Status', 5, 5, N'Column', N'Column', N'Status of the current reindex operation. If the database completes without error this column will be set to ''Complete''. If the database encountered errors you will see ''Complete with errors''. This column will also be updated with high level status messages when using the Live Insight feature. To see details of these high level messages check the Status column in the IndexMaintLogDetails table. If the current database is complete and this column doesn''t have ''Complete'' or ''Complete with errors'', then that probably means that the job was stopped either by an unhandled fatal error or manually. Once the job is stopped there is no way to update this column further so it will be stuck in an invalid status.', N'varchar (500)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (5, N'Tables', 5, 7, N'Column', N'Column', N'Shows whether Offline, Online, or All indexes were processed. Offline indexes are those that have to be done offline because they contain a legacy data type like text, image, etc. Online tables are the ones that can be processed online. If you choose Online for a table and it has an index that must be done offline, then that index will be excluded from processing.', N'varchar (7)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'* Footnote', 7, 45, N'* Footnote', N'* Footnote', N'* For information on this column, see the sys.indexes article on msdn.microsoft.com', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'** Footnote', 7, 46, N'** Footnote', N'** Footnote', N'** For information on this column, see the sys.dm_db_index_physical_stats article on msdn.microsoft.com', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'AbortAfterWait', 7, 34, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'AllowPageLocks', 7, 31, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'AllowRowLocks', 7, 30, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'avg_fragmentation_in_percent', 7, 15, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms173760.aspx', N'float', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'DataCompression', 7, 23, N'Column', N'Column', N'The data compression option. The options are as follows: Valid inputs: NONE ROW PAGE COLUMNSTORE COLUMNSTORE_ARCHIVE A NULL value here would indicate DataCompression=''NONE''.', N'varchar (50)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'DBID', 7, 5, N'Column', N'Column', N'Database ID.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'DBName', 7, 4, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'Discussion', 7, 47, N'Discussion', N'Discussion', NULL, NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'Examples', 7, 48, N'Examples', N'Examples', NULL, NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'ExecutionDateTime', 7, 3, N'Column', N'Column', N'The execution date and time, common to the entire run of a database index maintenance event.', N'datetime', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'FillFactorOpt', 7, 18, N'Column', N'Column', N'Specify how full a reindex maintenance should make each page when it rebuilds an index. For example, a value of 85 would leave each data page 85% full of data. A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'GetPostFragLevel', 7, 25, N'Column', N'Column', N'Get the fragmentation level for each index, after the index maintenance operations are complete. This is done on a per index basis as soon as the reindex operation is complete for each index.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'GetRowCT', 7, 24, N'Column', N'Column', N'Get a rowcount for each table.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'GroupOrder', 7, 43, N'Column', N'Column', N'Group to which this database belongs. Used solely for determining the order in which databases should be processed for index maintenance. By default, all tables have a value of 0, which means they’ll be processed in the order they’re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. The range of ReindexGroupOrder weight numbers is 0-255. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IgnoreDupKey', 7, 28, N'Column', N'Column', N'Change the option so that for this index, inserts that add (normally illegal) duplicates generate a warning instead of an error. Applies to inserts that occur any time after the index operation. The default is OFF. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IndexID', 7, 10, N'Column', N'Column', N'Index ID.', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IndexName', 7, 9, N'Column', N'Column', N'Index name from sysindexes.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IndexScanMode', 7, 39, N'Column', N'Column', N'Valid inputs: Detailed Limited NULL A value of NULL indicates that reindexing should use the default (in this case, “LIMITED”).', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IndexType', 7, 11, N'Column', N'Column', N'Index type number, e.g. 0 = HEAP, etc. See http://msdn.microsoft.com/en-us/library/ms173760.aspx', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IndexTypeDesc', 7, 12, N'Column', N'Column', N'Description of index type, e.g. HEAP, CLUSTERED, NONCLUSTERED, etc. See http://msdn.microsoft.com/en-us/library/ms173760.aspx', N'nvarchar (120)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IsDisabled', 7, 13, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms173760.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'IsHypothetical', 7, 14, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms173760.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'LogIndexPhysicalStats', 7, 38, N'Column', N'Column', N'Save the current index physical stats to a table (Minion.IndexPhysicalStats).', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'LogProgress', 7, 35, N'Column', N'Column', N'Track the progress of index operations for this database. The overall status is tracked in the Minion.IndexMaintLog table, while specific operations are tracked in the Status column Minion.IndexMaintLogDetails.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@IndexOption', 21, 3, N'Param', N'@IndexOption', N'Perform maintenance only for indexes marked for online operations; only for those marked for offline operations; or for all indexes. Valid inputs: ONLINE OFFLINE ALL For more information, see “How To: Reindex only indexes that are marked ONLINE = ON (or, only ONLINE = OFF)”', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'LogRetDays', 7, 36, N'Column', N'Column', N'Number of days to retain index maintenance log data, for this table. Just like any setting, if a table-specific row exists (in Minion.IndexSettingTable), those settings take precedence over database level settings. That is, if DB1.Table1 has an entry for LogRetDays=50, and DB1 has an entry for LogRetDays=40, the log will keep 50 days for DB1.Table1. When first implemented, Minion Reindex defaults to 60 days of log retention.', N'smallint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'MAXDOPopt', 7, 22, N'Column', N'Column', N'Specify the max degree of parallelism (“MAXDOP”, the number of CPUs to use) for the index maintenance operations. If specified, this overrides the MAXDOP configuration option for the duration of the index operation.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'MaxDurationInMins', 7, 33, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'ObjectName', 7, 1, N'ObjectName', N'ObjectName', N'Minion.IndexTableFrag', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'OnlineOpt', 7, 20, N'Column', N'Column', N'Perform ONLINE index maintenance for indexes in this database. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”, meaning the index maintenance will be done offline). Note that ONLINE index operations may not be possible for certain editions of SQL Server, and only for indexes that are eligible for ONLINE index operations. If you specify ONLINE when it is not possible, the routine will change it to OFFLINE.', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'PadIndex', 7, 19, N'Column', N'Column', N'Turn PAD_INDEX on or off. Valid inputs: ON OFF A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'Prepped', 7, 41, N'Column', N'Column', N'If Prepped=1, this data was entered into the table as a result of running the Minion.IndexMaintMaster stored procedure with @PrepOnly = 1. It is then necessary to run the reindexing routine with @RunPrepped = 1 to use this data. For more on this topic, see “How To: Gather index fragmentation statistics on a different schedule from the reindex routine”. NOTE: There can only be one set of prepared data per database at any given time. When you run @PrepOnly = 1, it enters the data into this table, and deletes any previous prep runs for the database in question. So while you can have as many databases as you like prepped in this table, each database can only have a single prep run.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'Purpose', 7, 2, N'Purpose', N'Purpose', N'Holds index fragmentation information on a short-term basis, to be used by the currently-running index maintenance process. Minion.IndexTableFrag also holds fragmentation data for prepped operations (created with Minion.IndexMaintMaster with @PrepOnly = 1). PrepOnly data is marked with Prepped = 1 in this table, so Minion Reindex knows the difference between a current process and a prepped process. For more information on these columns, see Minion.IndexMaintDB, Minion.IndexMaintTable, and/or the MSDN article on sys.dm_db_index_physical_stats at http://msdn.microsoft.com/en-us/library/ms188917.aspx', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'PushToMinion', 7, 37, N'Column', N'Column', N'Save these values to the central Minion server, if it exists. Modifies values for this particular table on the central Minion server. A value of NULL indicates that this feature is off. Functionality not yet supported.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'RebuildThreshold', 7, 17, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should rebuild an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'ReindexOrder', 7, 44, N'Column', N'Column', N'The index maintenance order within a group. Used solely for determining the order in which databases should be processed for index maintenance. By default, all tables have a value of 0, which means they’ll be processed in the order they’re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. We recommend leaving some space between assigned reindex order numbers (e.g., 10, 20, 30) so there is room to move or insert rows in the ordering. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'StmtPrefix', 7, 46, N'Column', N'Column', N'The code that will prefix every reindex statement with a statement of your own.  
For more information, see “How To: Run code before or after index maintenance”', N'nvarchar', NULL, NULL, NULL, NULL);
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'StmtSuffix', 7, 48, N'Column', N'Column', N'The code that will suffix every reindex statement with a statement of your own.  
For more information, see “How To: Run code before or after index maintenance”', N'nvarchar', NULL, NULL, NULL, NULL);
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'ReorgThreshold', 7, 16, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should reorganize an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'Tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'SchemaName', 7, 7, N'Column', N'Column', N'Schema name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'SortInTempDB', 7, 21, N'Column', N'Column', N'Direct index maintenance to use TempDB to store the intermediate sort results that are used to build the index. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'StatScanOption', 7, 27, N'Column', N'Column', N'Options available for the UPDATE STATISTICS statement (that is, anything that would go in the “WITH” statement). Valid inputs include any of the following options, as a comma-delimited list: FULLSCAN SAMPLE RESAMPLE ON PARTITIONS ... STATS_STREAM ROWCOUNT PAGECOUNT For example, StatScanOption could be set to “SAMPLE 50 PERCENT”, or “FULLSCAN, NORECOMPUTE”.', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'StatsNoRecompute', 7, 29, N'Column', N'Column', N'Disable the automatic statistics update option, AUTO_UPDATE_STATISTICS. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'TableID', 7, 6, N'Column', N'Column', N'Table ID.', N'bigint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'TableName', 7, 8, N'Column', N'Column', N'Table name.', N'varchar (100)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'TablePostCode', 7, 41, N'Column', N'Column', N'Code to run for a table, after the index maintenance operations complete for that table. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'TablePreCode', 7, 40, N'Column', N'Column', N'Code to run for a table, before the index maintenance operations begin for that table. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'UpdateStatsOnDefrag', 7, 26, N'Column', N'Column', N'Update statistics after defragmenting. This should always be on, but Minion provides the option just in case your stats are handled in some other way.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (7, N'WaitAtLowPriority', 7, 32, N'Column', N'Column', N'See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@Exclude', 21, 9, N'Param', N'@Exclude', N'Use @Exclude to skip index maintenance for a specific list of databases, or databases that match a LIKE expression. Examples of valid inputs include: DBname DBName1, DBname2, etc. DBName%, YourDatabase, Archive% For more information, see “How To: Exclude databases from index maintenance”.', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@Include', 21, 8, N'Param', N'@Include', N'Use @Include to run index maintenance on a specific list of databases, or databases that match a LIKE expression. Alternately, set @Include=’All’ or @Include=NULL to run maintenance on all databases. Examples of valid inputs include: All NULL DBname DBName1, DBname2, etc. DBName%, YourDatabase, Archive%', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@LogProgress', 21, 10, N'Param', N'@LogProgress', N'Track the progress of index operations for this database. The overall status is tracked in the Minion.IndexMaintLog table, while specific operations are tracked in the Status column Minion.IndexMaintLogDetails.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@PrepOnly', 21, 6, N'Param', N'@PrepOnly', N'Only gets index fragmentation stats, and saves to a table. This prepares the databases to be reindexed. If @PrepOnly = 1, then @RunPrepped must be set to 0. For more information, see “How To: Gather index fragmentation statistics on a different schedule from the reindex routine”.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@ReorgMode', 21, 4, N'Param', N'@ReorgMode', N'Perform maintenance only for indexes that meet the REORG threshold; only for those that meet the REBUILD threshold; or for all indexes that meet either threshold (when this is set to “All”). Note that for REORG mode, only REORG statements will be generated, even for indexes that are over the rebuild threshold. For REBUILD, only REBUILD statements will be generated. Valid inputs: All REORG REBUILD', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@RunPrepped', 21, 5, N'Param', N'@RunPrepped', N'If you''ve collected index fragmentation stats ahead of time by running with @PrepOnly = 1, then you can use this option. It causes the index maintenance to use the saved frag stats. For more information, see “How To: Gather index fragmentation statistics on a different schedule from the reindex routine”.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'@StmtOnly', 21, 7, N'Param', N'@StmtOnly', N'Only prints reindex statements. This is an excellent choice for running statements manually; it allows you to pick and choose which indexes you want to do, or just see how many are over the thresholds. For more information, see “How To: Generate reindex statements only”.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'Discussion', 21, 11, N'Discussion', N'Discussion', N'Discussion: Minion.IndexMaintMaster is the heart and brain of Minion Reindex; it decides what needs to be done and pushes out orders to get it done. A few things you can do with Minion.IndexMaintMaster include: Maintain only indexes that can be done online, only those that can be done offline, or all. Generate and execute only reorganize statements, only rebuild statements, or both. Run the procedure to gather index fragmentation stats, and save them to a table. This prepares the database to be reindexed. Run the procedure without gathering index fragmentation stats. This requires that the index fragmentation data has already been collected. Choose to maintain a specific set of databases, via the @Include parameter. (E.g., @Include=''DB1, DB2, DB3''…) Choose to maintain all databases Choose to maintain all databases, with specific exclusions, via the @Exclude parameter. Only print reindex statements, do not run. This is an excellent choice for running statements manually; it allows you to pick and choose which indexes you want to maintain, or just see how many indexes are over the thresholds. Have every step of the run printed in the log so you can watch the progress (called Live Insight). This option is on by default.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'ObjectName', 21, 1, N'ObjectName', N'ObjectName', N'Minion.IndexMaintMaster', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (13, N'Purpose', 21, 2, N'Purpose', N'Purpose', N'The Minion.IndexMaintMaster procedure makes all the decisions on which databases to reindex, and what order they should be in.  This stored procedure calls the Minion.IndexSettingsDB stored procedure once per each database specified in the parameters; or, if “All” is specified, per each eligible database in sys.databases.

Minion Reindex 1.2 supports SQL Server databases that are part of an Availability Group (AG). Reindex will run for databases that are not part of an AG, and for AG primaries, but not for databases that act as a secondary in an A scenario. (AG secondary databases do not require index maintenance.)', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'Action', 16, 3, N'Column', N'Column', N'Action to perform with this regular expression. Valid inputs: EXCLUDE', N'varchar (10)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'DetailName', 16, 1, N'DetailName', N'DetailName', N'Minion.DBMaintRegexLookup', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'Discussion', 16, 6, N'Discussion', N'Discussion', N'Discussion This table is meant to be inclusive for all maintenance operations. (Minion will, in future, be more than just an excellent reindex solution.) Therefore, the MaintType column is important. By specifying ''All'' you ensure that all databases that satisfy the regex expression are excluded from all maintenance operations (Reindex, Backup, CheckDB, Update Statistics, etc.). This is an excellent way to shotgun groups of databases and exclude them from all maintenance. However, if you want to only exclude the databases from reindexing, set MaintType to ''Reindex''.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'Examples', 16, 7, N'Examples', N'Examples', N'Example 1 To exclude any database named “Minion” followed by one or more characters, from ALL database maintenance routines, insert the following row: INSERT INTO Minion.DBMaintRegexLookup ( [Action], MaintType, RegEx ) VALUES ( ''Exclude'', ''All'', ''Minion\w+'' ); Example 2 To exclude any database named “ADB” followed by one or more decimal digits, from index maintenance, insert the following row: INSERT INTO Minion.DBMaintRegexLookup ( [Action], MaintType, RegEx ) VALUES ( ''Exclude'', ''Reindex'', ''ADB\d+'' ); These databases will still be processed in the backups, CheckDB, and other maintenance operations, if those Minion modules are running on your instance.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'MaintType', 16, 4, N'Column', N'Column', N'Maintenance type to which this applies. Valid inputs: ALL REINDEX', N'varchar (20)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'Purpose', 16, 2, N'Purpose', N'Purpose', N'Allows you to exclude databases from index maintenance (or all maintenance), based off of regular expressions.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (16, N'Regex', 16, 5, N'Column', N'Column', N'Regular expression to match a database name, or set of database names.', N'nvarchar (2000)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (58, N'Change Default Settings', 1, 5, N'Discussion', N'Change Default Settings', N'Minion Reindex stores default settings for the entire instance in a single row (where DBName=’MinionDefault’) in the Minion.IndexSettingsDB table.

Warning: Do not delete the MinionDefault row from Minion.IndexSettingsDB!

To change the default settings, run an update statement on the MinionDefault row in Minion.IndexSettingsDB. For example:

UPDATE [Minion].[IndexSettingsDB]
   SET [Exclude] = 0
      ,[ReindexGroupOrder] = 0
      ,[ReindexOrder] = 0
      ,[ReorgThreshold] = 10
      ,[RebuildThreshold] = 20
      ,[FILLFACTORopt] = 85
      ,[PadIndex] = ''ON''
      ,[SortInTempDB] = ''OFF''
      ,[DataCompression] = NULL
      ,[GetRowCT] = 1
      ,[GetPostFragLevel] = 1
      ,[UpdateStatsOnDefrag] = 1
      ,[LogIndexPhysicalStats] = 0
      ,[IndexScanMode] = ''Limited''
      ,[LogProgress] = 1
      ,[LogRetDays] = 60
      ,[LogLoc] = ''Local''
      ,[MinionTriggerPath] = ''\\minioncon\c$''
      ,[IncludeUsageDetails] = 1
 WHERE [DBName] = ''MinionDefault'';

Warning: Choose your settings wisely; these settings can have a massive impact on your system. For example, if you have a 500Gb database with fill factor set to 100, changing fill factor to 85 could increase the size of your database massively on the next reindex.

For more information on these settings, see the “Minion.IndexSettingsDB” section.

For instructions on setting database-level or table-level settings, see the section titled “How To: Configure settings for a single database”.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (58, N'Change Schedules', 1, 4, N'Discussion', N'Change Schedules', N'Optionally, you can change the reindexing schedules:
1.	View jobs: Connect to “YourServer” and expand the SQL Agent node. You’ll see two new jobs: 
    * dba_MinionReindexDBs-All-All – Runs once weekly – Fridays at 3:00 AM - to thoroughly defragment indexes (rebuild).
    * dba_MinionReindexDBs-All-REORG – Runs Daily – 3:00 AM except for Friday – to complete lightweight defragmenting (reorganize).
2.	Alter schedules: Edit the two job schedules to fit your company’s needs. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (58, N'Introduction', 1, 2, N'Discussion', N'Introduction', N'Minion Reindex by MidnightDBA is a stand-alone index maintenance solution that can be deployed on any number of servers, for free. Minion Reindex is comprised of SQL Server tables, stored procedures, and SQL Agent jobs. For links to downloads, tutorials and articles, see MidnightSQL.com/Minion.
		  
To install, download Minion Reindex from MidnightSQL.com/Minion and run it on your target server. For simplicity, this Quick Start guide assumes that you have installed Minion Reindex on one server, named “YourServer”.

Note: You can also use the Powershell script provided on MidnightSQL.com to install Minion Reindex on dozens or hundreds of servers at once, just as easily as you would install it on a single instance.

Once MinionReindexing.sql has been run, nothing else is required. From here on, Minion Reindex will run nightly to defragment all non-tempdb databases. The reindexing routine automatically handles databases as they are created, dropped, or renamed.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (58, N'ObjectName', 1, 1, N'ObjectName', N'ObjectName', N'Quick Start', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (58, N'System Requirements', 1, 3, N'Discussion', N'System Requirements', N'SQL Server 2005 or above. The sp_configure setting xp_cmdshell must be enabled*. Powershell 2.0 or above;  execution policy set to RemoteSigned.  

* xp_cmdshell can be turned on and off with the database PreCode / PostCode options, to help comply with security policies.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (59, N'Features', 2, 2, N'Discussion', N'Features', N'Minion Reindex by MidnightDBA is a stand-alone index maintenance module. Once installed, Minion Reindex automatically maintains all online databases on the SQL Server instance, and will automatically incorporate databases and indexes as they are added or removed.

Ten of the very best features of Minion Reindex are, in a nutshell:

1.	Automated operation – Run the Minion Reindex installation scripts, and it just goes.  

2.	Easy mass installation – Install Minion Reindex on hundreds of servers as easily as you can on one.

3.	Granular configuration without extra jobs – Configure extensive settings at the default, database, and/or table levels with ease.  

4.	Database and table reindex ordering – Reindex databases and tables in exactly the order you need.

5.	Flexible include and exclude – Reindex only the databases you want, using specific database names, LIKE expressions, and even regular expressions.

6.	Live Insight – See what Minion Reindex is doing every step of the way, and how much further it has to go.

7.	Maximized maintenance window – Spend the whole maintenance window on index maintenance, not on gathering fragmentation stats.

8.	Extensive, useful logging – Use the Minion Reindex log for estimating the end of the current reindexing run, troubleshooting, planning, and reporting.

9.	Built in manual runs – Choose to only print reindex statements, and run them individually as needed.

10.	Integrated help –Get help on any Minion Reindex object without leaving Management Studio.

For more information on these, additional features and settings, and How To topics, see the sections “How To” Topics, and Moving Parts. For links to downloads, tutorials and articles, see MidnightSQL.com/Minion.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (59, N'ObjectName', 2, 1, N'ObjectName', N'ObjectName', N'Top 10 Features', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (60, N'Configuration Settings Hierarchy', 3, 3, N'Discussion', N'Configuration Settings Hierarchy', N'As much as possible, configuration for reindex is stored in tables: Minion.IndexSettingsDB and Minion.IndexSettingsTable. A default row in Minion.IndexSettingsDB (DBName=’MinionDefault’) provides settings for any database that doesn’t have its own specific settings.  This is a hierarchy of granularity, where more specific configuration levels completely override the less specific levels. That is: 

  * Insert a row for a specific database into Minion.IndexSettingsDB, and that row will override ALL of the default settings for that database. 

  * Insert a row for a specific table in Minion.IndexSettingsTable, and that row will override ALL of the default (or, if available, database-specific) settings for that table.

Note a value left at NULL in one of these tables means that Minion will use the setting that the SQL Server instance itself uses.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (60, N'Introduction', 3, 2, N'Discussion', N'Introduction', N'Minion Reindex is made up of SQL Server stored procedures, tables, and jobs. There is an optional Powershell script for installation. The tables store configuration and log information; stored procedures perform reindex operations; and the jobs execute those index operations on a schedule.
Note: Minion is installed in the master database by default. You certainly can install Minion in another database (like a DBAdmin database), but when you do, you must also change the database that the jobs point to. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (60, N'Logging', 3, 5, N'Discussion', N'Logging', N'As a Minion Reindex routine runs, it keeps logs of all activity in two tables: 

  * Minion.IndexMaintLog – a log of activity at the database level.

  * Minion.IndexMaintLogDetail – a log of activity at the index level.

The Status column for the current run is updated continually in each of these tables. This way, status information (Live Insight) is available to you while index maintenance is still running, and historical data is available after the fact for help in planning future operations, reporting, troubleshooting, and more.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (60, N'ObjectName', 3, 1, N'ObjectName', N'ObjectName', N'Architecture Overview', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (60, N'Run Time Configuration', 3, 4, N'Discussion', N'Run Time Configuration', N'The main Minion Reindex stored procedure – Minion.IndexMaintMaster – takes a number of parameters that are specific to the current maintenance run. For example: 

  * Use @IndexOption to run index maintenance on only tables marked for ONLINE index maintenance. 

  * Use @PrepOnly to only gather index fragmentation stats. These are saved to a table, so that later you can run Minion.IndexMaintMaster using @RunPrepped, and the procedure will used the saved fragmentation stats (instead of gathering them anew).

  * Use @Include to run index maintenance on a specific list of databases, or databases that match a LIKE expression. Alternately, set @Include=’All’ or @Include=NULL to run maintenance on all databases.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (61, N'Configure settings for a single database', 4, 2, N'Discussion', N'Configure settings for a single database', N'Default settings for the whole system are stored in the Minion.IndexSettingsDB table. To specify settings for a specific database that override those defaults (for that database), insert a row for that database to the Minion.IndexSettingsDB table.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'PadIndex', 66, 12, N'Column', N'Column', N'Turn PAD_INDEX on or off. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (61, N'Example', 4, 3, N'Example', N'Example', N'INSERT	INTO [Minion].[IndexSettingsDB]
		( DBName ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [SortInTempDB] ,
		  [DataCompression] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [LogLoc] ,
		  [MinionTriggerPath] ,
		  [IncludeUsageDetails] 
		)
VALUES	( ''YourDatabase'' ,	--	DBName ,
		  0 ,		--	Exclude ,
		  0 ,		--	ReindexGroupOrder ,
		  0 ,		--	ReindexOrder ,
		  10 ,		--	ReorgThreshold ,
		  20 ,		--	RebuildThreshold ,
		  80 ,		--	FILLFACTORopt ,
		  ''ON'' ,		--	PadIndex ,
		  ''OFF'' ,		--	SortInTempDB ,
		  NULL ,		--	DataCompression ,
		  1 ,		--	GetRowCT ,
		  1 ,		--	GetPostFragLevel ,
		  1 ,		--	UpdateStatsOnDefrag ,
		  0 ,		--	LogIndexPhysicalStats ,
		  ''Limited'' ,	--	IndexScanMode ,
		  1 ,		--	LogProgress ,
		  60 ,		--	LogRetDays ,
		  ''Local'' ,	--	LogLoc ,
		  ''\\minioncon\c$'' ,	--	MinionTriggerPath ,
		  1		--	IncludeUsageDetails 
		);', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (61, N'ObjectName', 4, 1, N'ObjectName', N'ObjectName', N'Configure settings for a single database', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (62, N'Configure settings for a single table', 5, 2, N'Discussion', N'Configure settings for a single table', N'Default settings are stored in the Minion.IndexSettingsDB table. To specify settings for a specific table that override those defaults (for that table), insert a row for that table to the Minion.IndexSettingsTable table.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (62, N'Example', 5, 3, N'Example', N'Example', N'INSERT	INTO [Minion].[IndexSettingsTable]
		( [DBName] ,
		  [SchemaName] ,
		  [TableName] ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [ONLINEopt] ,
		  [SortInTempDB] ,
		  [DataCompression] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [IncludeUsageDetails]

		)
VALUES	( ''YourDatabase'' , -- DBName
	  ''dbo'' ,		-- SchemaName
	  ''YourTable'' ,	-- TableName
	  0 ,		-- Exclude
	  0 ,		-- ReindexGroupOrder
	  0 ,		-- ReindexOrder
	  10 ,		-- ReorgThreshold
	  20 ,		-- RebuildThreshold
	  80 ,		-- FILLFACTORopt
	  ''ON'' ,		-- PadIndex
	  NULL ,		-- ONLINEopt
	  NULL ,		-- SortInTempDB
	  NULL ,		-- DataCompression
	  1 ,		-- GetRowCT
	  1 ,		-- GetPostFragLevel
	  1 ,		-- UpdateStatsOnDefrag
	  0 ,		-- LogIndexPhysicalStats
	  ''Limited'' ,	-- IndexScanMode
	  1 ,		-- LogProgress
	  60 ,		-- LogRetDays
	  1		-- IncludeUsageDetails
 	);
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (62, N'ObjectName', 5, 1, N'ObjectName', N'ObjectName', N'Configure settings for a single table', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (63, N'Example', 6, 10, N'Example', N'Example', N'Because we have so few databases in this example, the simplest method is to assign the heaviest “weight” to YourDatabase, and lesser weights to the other databases, in decreasing order. In our example, we would insert four rows: 
-- Insert IndexSettingsDB row for [YourDatabase], ReindexOrder=255 (first)
INSERT	INTO [Minion].[IndexSettingsDB]
		( DBName ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [SortInTempDB] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [LogLoc] ,
		  [MinionTriggerPath] ,
		  [IncludeUsageDetails] 
		)
VALUES	( ''YourDatabase'' ,	--	DBName ,
		  0 ,		--	Exclude ,
		  0 ,		--	ReindexGroupOrder ,
		  255 ,		--	ReindexOrder ,
		  10 ,		--	ReorgThreshold ,
		  20 ,		--	RebuildThreshold ,
		  80 ,		--	FILLFACTORopt ,
		  ''ON'' ,		--	PadIndex ,
		  ''OFF'' ,		--	SortInTempDB ,
		  1 ,		--	GetRowCT ,
		  1 ,		--	GetPostFragLevel ,
		  1 ,		--	UpdateStatsOnDefrag ,
		  0 ,		--	LogIndexPhysicalStats ,
		  ''Limited'' ,	--	IndexScanMode ,
		  1 ,		--	LogProgress ,
		  60 ,		--	LogRetDays ,
		  ''Local'' ,	--	LogLoc ,
		  ''\\minioncon\c$'' ,	--	MinionTriggerPath ,
		  1		--	IncludeUsageDetails 
		);
-- Insert IndexSettingsDB row for “Semi”, ReindexOrder=150 (after [YourDatabase])
INSERT	INTO [Minion].[IndexSettingsDB]
		( DBName ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [SortInTempDB] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [LogLoc] ,
		  [MinionTriggerPath] ,
		  [IncludeUsageDetails] 
		)
VALUES	( ''Semi'' ,	--	DBName ,
		  0 ,		--	Exclude ,
		  0 ,		--	ReindexGroupOrder ,
		  150 ,		--	ReindexOrder ,
		  10 ,		--	ReorgThreshold ,
		  20 ,		--	RebuildThreshold ,
		  80 ,		--	FILLFACTORopt ,
		  ''ON'' ,		--	PadIndex ,
		  ''OFF'' ,		--	SortInTempDB ,
		  1 ,		--	GetRowCT ,
		  1 ,		--	GetPostFragLevel ,
		  1 ,		--	UpdateStatsOnDefrag ,
		  0 ,		--	LogIndexPhysicalStats ,
		  ''Limited'' ,	--	IndexScanMode ,
		  1 ,		--	LogProgress ,
		  60 ,		--	LogRetDays ,
		  ''Local'' ,	--	LogLoc ,
		  ''\\minioncon\c$'' ,	--	MinionTriggerPath ,
		  1		--	IncludeUsageDetails 
		);
-- Insert IndexSettingsDB row for “Lame”, ReindexOrder=100 (after “Semi”)
INSERT	INTO [Minion].[IndexSettingsDB]
		( DBName ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [SortInTempDB] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [LogLoc] ,
		  [MinionTriggerPath] ,
		  [IncludeUsageDetails] 
		)
VALUES	( ''Lame'' ,	--	DBName ,
		  0 ,		--	Exclude ,
		  0 ,		--	ReindexGroupOrder ,
		  100 ,		--	ReindexOrder ,
		  10 ,		--	ReorgThreshold ,
		  20 ,		--	RebuildThreshold ,
		  80 ,		--	FILLFACTORopt ,
		  ''ON'' ,		--	PadIndex ,
		  ''OFF'' ,		--	SortInTempDB ,
		  1 ,		--	GetRowCT ,
		  1 ,		--	GetPostFragLevel ,
		  1 ,		--	UpdateStatsOnDefrag ,
		  0 ,		--	LogIndexPhysicalStats ,
		  ''Limited'' ,	--	IndexScanMode ,
		  1 ,		--	LogProgress ,
		  60 ,		--	LogRetDays ,
		  ''Local'' ,	--	LogLoc ,
		  ''\\minioncon\c$'' ,	--	MinionTriggerPath ,
		  1		--	IncludeUsageDetails 
		);
-- Insert IndexSettingsDB row for “Unused”, ReindexOrder=50 (after [Lame])
INSERT	INTO [Minion].[IndexSettingsDB]
		( DBName ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [SortInTempDB] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [LogLoc] ,
		  [MinionTriggerPath] ,
		  [IncludeUsageDetails] 
		)
VALUES	( ''Unused'' ,	--	DBName ,
		  0 ,		--	Exclude ,
		  0 ,		--	ReindexGroupOrder ,
		  50 ,		--	ReindexOrder ,
		  10 ,		--	ReorgThreshold ,
		  20 ,		--	RebuildThreshold ,
		  80 ,		--	FILLFACTORopt ,
		  ''ON'' ,		--	PadIndex ,
		  ''OFF'' ,		--	SortInTempDB ,
		  1 ,		--	GetRowCT ,
		  1 ,		--	GetPostFragLevel ,
		  1 ,		--	UpdateStatsOnDefrag ,
		  0 ,		--	LogIndexPhysicalStats ,
		  ''Limited'' ,	--	IndexScanMode ,
		  1 ,		--	LogProgress ,
		  60 ,		--	LogRetDays ,
		  ''Local'' ,	--	LogLoc ,
		  ''\\minioncon\c$'' ,	--	MinionTriggerPath ,
		  1		--	IncludeUsageDetails 
		);
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (63, N'ObjectName', 6, 1, N'ObjectName', N'ObjectName', N'Reindex databases in a specific order', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (63, N'Reindex databases in a specific order', 6, 2, N'Discussion', N'Reindex databases in a specific order', N'You can choose the order in which databases will be maintained. For example, let’s say that you want your databases to be indexed in this order: 
1.	[YourDatabase] (it’s the most important database on your system)
2.	[Semi]
3.	[Lame]
4.	[Unused]
In this case, we would insert a row into the Minion.IndexSettingsDB for each one of the databases, specifying either ReindexGroupOrder, ReindexOrder, or both, as needed. 
NOTE: For ReindexGroupOrder and ReindexOrder, higher numbers have a greater “weight” - they have a higher priority - and will be indexed earlier than lower numbers. Note also that these columns are TINYINT, so weighted values must fall between 0 and 255.
NOTE: When you insert a row for a database, the settings in that row override all of the default index maintenance settings for that database. So, inserting a row for [YourDatabase] means that ONLY index settings from that row will be used for [YourDatabase]; none of the default settings will apply to [YourDatabase].
NOTE: Any databases that rely on the default system-wide settings (represented by the row where DBName=’MinionDefault’) will be indexed according to the values in the MinionDefault columns ReindexGroupOrder and ReindexOrder. By default, these are both 0 (lowest priority), and so non-specified databases would be maintained last. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (64, N'@Module', 64, 3, N'Param', N'@Module', N'The name of the module to retrieve help for. Valid inputs include: NULL Reindex', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (64, N'@Name', 64, 4, N'Param', N'@Module', N'The name of the topic for which you would like help. If you run Minion.HELP by itself, or with a @Module specified, it will return a list of available topics.', N'varchar', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (64, N'DetailName', 64, 1, N'DetailName', N'DetailName', N'Minion.HELP', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (64, N'Examples', 64, 5, N'Examples', N'Examples', N'Examples: For introductory help, run: EXEC Minion.HELP; For introductory help on Minion Reindex, run: EXEC Minion.HELP ''Reindex''; For help on a particular topic – in this case, the Top 10 Features – run: EXEC Minion.HELP ''Reindex'', ''Top 10 Features'';', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (64, N'Purpose', 64, 2, N'Purpose', N'Purpose', N'Use this stored procedure to get help on any Minion Reindex object without leaving Management Studio.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'AbortAfterWait', 66, 27, N'Column', N'Column', N'Enable or disable the ABORT_AFTER_WAIT option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: NONE SELF BLOCKERS', N'varchar (20)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'AllowPageLocks', 66, 24, N'Column', N'Column', N'Enable or disable the ALLOW_PAGE_LOCKS option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'AllowRowLocks', 66, 23, N'Column', N'Column', N'Enable or disable the ALLOW_ROW_LOCKS option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'DataCompression', 66, 16, N'Column', N'Column', N'The data compression option. The options are as follows: Valid inputs: NONE ROW PAGE COLUMNSTORE COLUMNSTORE_ARCHIVE A NULL value here would indicate DataCompression=‘‘NONE’‘.', N'varchar (50)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'DBName', 66, 5, N'Column', N'Column', N'Database name.', N'sysname', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'DBPostCode', 66, 32, N'Column', N'Column', N'Code to run for a database, after the index maintenance operations complete for that database. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'DBPreCode', 66, 31, N'Column', N'Column', N'Code to run for a database, before the index maintenance operations begin for that database. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Discussion', 66, 41, N'Discussion', N'Discussion', N'Insert a new row for [YourDatabase], if you wish to specify different default values for the reorg threshold, rebuild threshold, fill factor, and so on.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Discussion', 66, 42, N'Discussion', N'Discussion', N'The Minion.IndexSettingsDB table comes with a row with “MinionDefault” as the DBName value. This row defines the system-wide defaults. Important: Any row inserted for an individual database overrides only ALL of the values, whether or not they are specified. Refer to the following for an example: ID DBName Exclude ReorgThreshold RebuildThreshold FillFactorOpt 1 MinionDefault 0 10  20  90 2 YourDatabase 0 15  25  NULL The first row, “MinionDefault”, is the set of default values to use for all the databases in the SQL Server instance. These values will be used for index maintenance for all databases that do not have an additional row in this table. The second row, [YourDatabase], specifies some values for YourDatabase. This row completely overrides the “DefaultMinion” values for YourDatabase. When index operations are performed for YourDatabase, only the values from the YourDatabase row will be used. So, even though the system-wide default (as specified in the MinionDefault row) for Fill Factor is 90%, YourDatabase will not use that default value. Because Fill Factor is NULL for YourDatabase, index maintenance will use the current value specified for the index. You can find the current value for a specific index by running the following query: SELECT * FROM sys.indexes WHERE name = ''nonMyIndex'' Likewise, you can also specify table-level override settings in the Minion.IndexSettingsTable table, which will override any settings for that particular table (and ignore the settings in Minion.IndexSettingsDB). NOTE: While it is possible to exclude a single database from reindexing, by setting both the ReorgThreshold and RebuildThreshold above 100% for that database, we do not recommend this approach. This would cause Minion Reindex to gather fragmentation stats that will never be used. Instead, set the Exclude column to 1 for that database. Likewise, we do not recommend setting the thresholds at 0%. While this would guarantee that every index in the database would be reorganized at every maintenance execution, it would likely be an unnecessary waste of resources.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Discussion', 66, 42, N'Discussion', N'Discussion', N'The Minion.IndexSettingsDB table comes with a row with “MinionDefault” as the DBName value. This row defines the system-wide defaults. Important: Any row inserted for an individual database overrides only ALL of the values, whether or not they are specified. Refer to the following for an example: ID DBName Exclude ReorgThreshold RebuildThreshold FillFactorOpt 1 MinionDefault 0 10 20 90 2 YourDatabase 0 15 25 NULL The first row, “MinionDefault”, is the set of default values to use for all the databases in the SQL Server instance. These values will be used for index maintenance for all databases that do not have an additional row in this table. The second row, [YourDatabase], specifies some values for YourDatabase. This row completely overrides the “DefaultMinion” values for YourDatabase. When index operations are performed for YourDatabase, only the values from the YourDatabase row will be used. So, even though the system-wide default (as specified in the MinionDefault row) for Fill Factor is 90%, YourDatabase will not use that default value. Because Fill Factor is NULL for YourDatabase, index maintenance will use the current value specified for the index. You can find the current value for a specific index by running the following query: SELECT * FROM sys.indexes WHERE name = ''nonMyIndex'' Likewise, you can also specify table-level override settings in the Minion.IndexSettingsTable table, which will override any settings for that particular table (and ignore the settings in Minion.IndexSettingsDB). NOTE: While it is possible to exclude a single database from reindexing, by setting both the ReorgThreshold and RebuildThreshold above 100% for that database, we do not recommend this approach. This would cause Minion Reindex to gather fragmentation stats that will never be used. Instead, set the Exclude column to 1 for that database. Likewise, we do not recommend setting the thresholds at 0%. While this would guarantee that every index in the database would be reorganized at every maintenance execution, it would likely be an unnecessary waste of resources.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Examples', 66, 43, N'Examples', N'Examples', N'Usage examples: Example 1: Set custom thresholds, fill factor, and PadIndex for database ''YourDatabase''. INSERT INTO [Minion].[IndexSettingsDB] ( DBName , Exclude , ReorgThreshold , RebuildThreshold , FILLFACTORopt , PadIndex ) VALUES (''YourDatabase'' -- DBName , 0 -- Exclude , 15 -- ReorgThreshold , 25 -- RebuildThreshold , 90 -- FILLFACTORopt , ''ON'' -- PadIndex ); Example 2: Set custom reindex settings, and enable additional logging options for database ''YourDatabase''. INSERT INTO [Minion].[IndexSettingsDB] ( DBName , Exclude , ReorgThreshold , RebuildThreshold , FILLFACTORopt , PadIndex , SortInTempDB , UpdateStatsOnDefrag , GetRowCT , GetPostFragLevel , LogIndexPhysicalStats , LogProgress , LogRetDays , LogLoc) VALUES (''YourDatabase'' -- DBName , 0 -- Exclude , 15 -- ReorgThreshold , 25 -- RebuildThreshold , 90 -- FILLFACTORopt , ''ON'' -- PadIndex , ''ON'' -- SortInTempDB , 1 -- UpdateStatsOnDefrag , 1 -- GetRowCT , 1 -- GetPostFragLevel , 1 -- LogIndexPhysicalStats , 1 -- LogProgress , 90 -- LogRetDays , ''Local'' -- LogLoc );', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Exclude', 66, 6, N'Column', N'Column', N'Exclude database from index maintenance. For more on this topic, see “How To: Exclude Databases from Index Maintenance”.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'FILLFACTORopt', 66, 11, N'Column', N'Column', N'Specify how full a reindex maintenance should make each page when it rebuilds an index. For example, a value of 85 would leave each data page 85% full of data. A value of NULL indicates that reindexing should use the current index setting (viewable for that index in sys.indexes).', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'GetPostFragLevel', 66, 18, N'Column', N'Column', N'Get the fragmentation level for each index, after the index maintenance operations are complete. This is done on a per index basis as soon as the reindex operation is complete for each index.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'GetRowCT', 66, 17, N'Column', N'Column', N'Get a rowcount for each table.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ID', 66, 4, N'Column', N'Column', N'Primary key row identifier.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'IgnoreDupKey', 66, 21, N'Column', N'Column', N'Change the option so that for this index, inserts that add (normally illegal) duplicates generate a warning instead of an error. Applies to inserts that occur any time after the index operation. The default is OFF. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Important', 66, 3, N'Important', N'Important', N'Important: Do not delete the MinionDefault row, or rename the DBName column for this row!', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'IncludeUsageDetails', 66, 40, N'Column', N'Column', N'Save index usage details from sys.dm_db_index_usage_stats, to Minion.IndexMaintLogDetails. This feature is useful for tracking which indexes are being used the most over time.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'StmtPrefix', 66, 14, N'Column', N'Column', N'This column allows you to prefix every reindex statement with a statement of your own.  This is different from the table precode and postcode, because it is run in the same batch. Whereas, precode and postcode are run as completely separate statements, in different contexts.  
Code entered in this column MUST end in a semicolon.
For more information, see “How To: Run code before or after index maintenance”.', N'nvarchar', NULL, NULL, NULL, NULL);
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'StmtSuffix', 66, 16, N'Column', N'Column', N'This column allows you to suffix every reindex statement with a statement of your own.  This is different from the table precode and postcode, because it is run in the same batch. Whereas, precode and postcode are run as completely separate statements, in different contexts.  
Code entered in this column MUST end in a semicolon.
For more information, see “How To: Run code before or after index maintenance”.', N'nvarchar', NULL, NULL, NULL, NULL);
GO

INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'IndexScanMode', 66, 30, N'Column', N'Column', N'Valid inputs: Detailed Limited NULL A value of NULL indicates that reindexing should use the default (in this case, “LIMITED”).', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'LogIndexPhysicalStats', 66, 29, N'Column', N'Column', N'Save the current index physical stats to a table (Minion.IndexPhysicalStats).', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'LogLoc', 66, 37, N'Column', N'Column', N'Determines whether log data is only stored on the local (client) server, or on both the local server and the central Minion (repository) server. Valid inputs: Local Repo', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'LogProgress', 66, 35, N'Column', N'Column', N'Track the progress of index operations for this database. The overall status is tracked in the Minion.IndexMaintLog table, while specific operations are tracked in the Status column Minion.IndexMaintLogDetails.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'LogRetDays', 66, 36, N'Column', N'Column', N'Number of days to retain index maintenance log data, for this database. Just like any setting, if a table-specific row exists (in Minion.IndexSettingTable), those settings take precedence over database level settings. That is, if DB1.Table1 has an entry for LogRetDays=50, and DB1 has an entry for LogRetDays=40, the log will keep 50 days for DB1.Table1. When first implemented, Minion Reindex defaults to 60 days of log retention.', N'smallint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'MAXDOPopt', 66, 15, N'Column', N'Column', N'Specify the max degree of parallelism (“MAXDOP”, the number of CPUs to use) for the index maintenance operations. If specified, this overrides the MAXDOP configuration option for the duration of the index operation.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'MaxDurationInMins', 66, 26, N'Column', N'Column', N'Set the MAX_DURATION option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'MinionTriggerPath', 66, 38, N'Column', N'Column', N'UNC path where the Minion logging trigger file is located. Not applicable for a standalone Minion Reindex instance.', N'varchar (1000)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ObjectName', 66, 1, N'ObjectName', N'ObjectName', N'Minion.IndexSettingsDB', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ONLINEopt', 66, 14, N'Column', N'Column', N'Perform ONLINE index maintenance for indexes in this database. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”, meaning the index maintenance will be done offline). Note that ONLINE index operations may not be possible for certain editions of SQL Server, and only for indexes that are eligible for ONLINE index operations. If you specify ONLINE when it is not possible, the routine will change it to OFFLINE.', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'Purpose', 66, 2, N'Purpose', N'Purpose', N'This table holds index maintenance default settings at the default and database levels. You may insert rows for individual databases to override the default index maintenance settings (per database). Minion.IndexSettingsDB is installed with default settings already in place, via the system-wide default row (identified by DBName = “MinionDefault”). If you do not need to fine tune the reindexing process at all, no action is required, and all maintenance will use this default configuration. To override these default settings for a specific database, insert a new row for the individual database with the desired settings. Note that any database with its own entry in Minion.IndexSettingsDB retrieves ALL its configuration data from that row. For example, if you enter a row for [YourDatabase] and leave the FILLFACTORopt at NULL, Minion Reindex does not retrieve that value from the “MinionDefault” row; in this case, fill factor for YourDatabase would default to the current index setting (viewable for that index in sys.indexes).', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'PushToMinion', 66, 28, N'Column', N'Column', N'Save these values to the central Minion server, if it exists. Modifies values for this particular database on the central Minion server. A value of NULL indicates that this feature is off. Functionality not yet supported.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'RebuildThreshold', 66, 10, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should rebuild an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'RecoveryModel', 66, 39, N'Column', N'Column', N'Change the recovery model of the database for the duration of the index maintenance operation. After index maintenance operations, the database will be set back to its original recovery model. Valid inputs: FULL BULK_LOGGED SIMPLE WARNING: While we have done extensive testing and checking for this feature, it may still be possible for the process to fail in such a way that a database changed (for example) from FULL to SIMPLE may not switch back. Therefore, we advise that if you’‘re in FULL you switch to BULK_LOGGED instead. It won’‘t break your log chain and it has the same effect as switching to SIMPLE.', N'varchar (12)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ReindexGroupOrder', 66, 7, N'Column', N'Column', N'Group to which this database belongs. Used solely for determining the order in which databases should be processed for index maintenance. By default, all databases have a value of 0, which means they’‘ll be processes in the order they’‘re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. The range of ReindexGroupOrder weight numbers is 0-255. For more information, see “How To: Reindex databases in a specific order”.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ReindexOrder', 66, 8, N'Column', N'Column', N'The index maintenance order within a group. Used solely for determining the order in which databases should be processed for index maintenance. By default, all databases have a value of 0, which means they’‘ll be processes in the order they’‘re queried from sysobjects. Higher numbers have a greater “weight” (they have a higher priority), and will be indexed earlier than lower numbers. We recommend leaving some space between assigned reindex order numbers (e.g., 10, 20, 30) so there is room to move or insert rows in the ordering. For more information, see “How To: Reindex databases in a specific order”.', N'int', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'ReorgThreshold', 66, 9, N'Column', N'Column', N'The percentage threshold at which Index Maintenance should reorganize an index. For example, if ReorgThreshold is set to 10 and the RebuildThreshold is 20, then a reorg will be done for all indexes between 10 and 19. And a rebuild will be done for all indexes 20 and above.', N'tinyint', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'SortInTempDB', 66, 13, N'Column', N'Column', N'Direct index maintenance to use TempDB to store the intermediate sort results that are used to build the index. Valid inputs: ON OFF NULL A value of NULL indicates that reindexing should use the system setting (in this case, “OFF”).', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'StatScanOption', 66, 20, N'Column', N'Column', N'Options available for the UPDATE STATISTICS statement (that is, anything that would go in the “WITH” statement). Valid inputs include any of the following options, as a comma-delimited list: FULLSCAN SAMPLE … RESAMPLE ON PARTITIONS ... STATS_STREAM ROWCOUNT PAGECOUNT For example, StatScanOption could be set to “SAMPLE 50 PERCENT”, or “FULLSCAN, NORECOMPUTE”.', N'varchar (25)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'StatsNoRecompute', 66, 22, N'Column', N'Column', N'Disable the automatic statistics update option, AUTO_UPDATE_STATISTICS. Valid inputs: ON OFF', N'varchar (3)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'TablePostCode', 66, 34, N'Column', N'Column', N'Code to run for each and every table, after the index maintenance operations end for that table. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'TablePreCode', 66, 33, N'Column', N'Column', N'Code to run for each and every table, before the index maintenance operations begin for that table. Note: To run precode just once, before maintenance for the database begins, use the DBPreCode column. For more on this topic, see “How To: Run code before or after index maintenance”.', N'nvarchar (max)', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'UpdateStatsOnDefrag', 66, 19, N'Column', N'Column', N'Update statistics after defragmenting. This should always be on, but Minion provides the option just in case your stats are handled in some other way.', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (66, N'WaitAtLowPriority', 66, 25, N'Column', N'Column', N'Enable or disable the WAIT_AT_LOW_PRIORITY option of ALTER INDEX. See http://msdn.microsoft.com/en-us/library/ms188388.aspx', N'bit', NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (70, N'Example', 70, 20, N'Example', N'Example', N'To reindex the only OFFLINE indexes (again, any index which does not have ONLINEopt=ON) for a single database – [YourDatabase] – use the following call:
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''OFFLINE'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 0,
	@StmtOnly = 0,
	@Include = ''YourDatabase'', 
	@Exclude = NULL, 
	@LogProgress = 1;', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (70, N'ObjectName', 70, 1, N'ObjectName', N'ObjectName', N'Reindex only indexes that are marked ONLINE = ON (or, only ONLINE = OFF)', NULL, NULL, NULL, NULL, NULL)
GO

INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (68, N'Example', 68, 10, N'Example', N'Example', N'Because we have so few tables in this example, the simplest method is to assign the heaviest “weight” to dbo.[Best], and lesser weights to dbo.[Okay]. In our example, we would insert two rows: 
-- Insert IndexSettingsDB row for dbo.[Best], ReindexOrder=255 (first)
INSERT	INTO [Minion].[IndexSettingsTable]
		( [DBName] ,
		  [SchemaName] ,
		  [TableName] ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [IncludeUsageDetails]

		)
VALUES	( ''YourDatabase'' , -- DBName
		  ''dbo'' ,		-- SchemaName
		  ''Best'' ,	-- TableName
		  0 ,		-- Exclude
		  0 ,		-- ReindexGroupOrder
		  255 ,		-- ReindexOrder
		  10 ,		-- ReorgThreshold
		  20 ,		-- RebuildThreshold
		  80 ,		-- FILLFACTORopt
		  ''ON'' ,		-- PadIndex
		  1 ,		-- GetRowCT
		  1 ,		-- GetPostFragLevel
		  1 ,		-- UpdateStatsOnDefrag
		  0 ,		-- LogIndexPhysicalStats
		  ''Limited'' ,	-- IndexScanMode
		  1 ,		-- LogProgress
		  60 ,		-- LogRetDays
		  1		-- IncludeUsageDetails
 		);
-- Insert IndexSettingsDB row for dbo.[Okay], ReindexOrder=200 (after [Best])
INSERT	INTO [Minion].[IndexSettingsTable]
		( [DBName] ,
		  [SchemaName] ,
		  [TableName] ,
		  [Exclude] ,
		  [ReindexGroupOrder] ,
		  [ReindexOrder] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [IncludeUsageDetails]

		)
VALUES	( ''YourDatabase'' , -- DBName
		  ''dbo'' ,		-- SchemaName
		  ''Okay'' ,	-- TableName
		  0 ,		-- Exclude
		  0 ,		-- ReindexGroupOrder
		  200 ,		-- ReindexOrder
		  10 ,		-- ReorgThreshold
		  20 ,		-- RebuildThreshold
		  80 ,		-- FILLFACTORopt
		  ''ON'' ,		-- PadIndex
		  1 ,		-- GetRowCT
		  1 ,		-- GetPostFragLevel
		  1 ,		-- UpdateStatsOnDefrag
		  0 ,		-- LogIndexPhysicalStats
		  ''Limited'' ,	-- IndexScanMode
		  1 ,		-- LogProgress
		  60 ,		-- LogRetDays
		  1		-- IncludeUsageDetails
 		);', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (68, N'Example', 68, 20, N'Example', N'Example', N'For a more complex ordering scheme, we could divide tables up into groups, and then order the reindexing both by group, and within each group. The pseudocode for this example might be:
  * Insert rows for tables dbo.One, dbo.Two, dbo.Three, all with ReindexGroupOrder = 200
     o	Row dbo.One: ReindexOrder = 255
     o	Row dbo.Two: ReindexOrder = 225
     o	Row dbo.Three: ReindexOrder = 150
  * Insert rows for tables dbo.Dog, dbo.Cat, dbo.Horse, all with ReindexGroupOrder = 100
     o	Row dbo.Dog: ReindexOrder = 255
     o	Row dbo.Cat: ReindexOrder = 215
     o	Row dbo.Horse: ReindexOrder = 175
  * Insert rows for tables dbo.Up, dbo.Down, all with ReindexGroupOrder = 50
     o	Row dbo.Up: ReindexOrder = 200
     o	Row dbo.Down: ReindexOrder = 100
The resulting index maintenance order would be as follows:
     1.	dbo.One
     2.	dbo.Two
     3.	dbo.Three
     4.	dbo.Dog
     5.	dbo.Cat
     6.	dbo.Horse
     7.	dbo.Up
     8.	dbo.Down
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (68, N'ObjectName', 68, 1, N'ObjectName', N'ObjectName', N'Reindex tables in a specific order', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (68, N'Reindex tables in a specific order', 68, 2, N'Discussion', N'Reindex tables in a specific order', N'You can choose the order in which tables will be maintained. For example, let’s say that you want two tables in [YourDatabase] to be indexed before all other tables in that database, in this order: 
1.	dbo.[Best] (it’s the most important or most badly fragmented table)
2.	dbo.[Okay]
3.	other tables
In this case, we would insert a row into the Minion.IndexSettingsTable for each one of the tables, specifying either ReindexGroupOrder, ReindexOrder, or both, as needed. 
NOTE: For ReindexGroupOrder and ReindexOrder, higher numbers have a greater “weight” - they have a higher priority - and will be indexed earlier than lower numbers. Note also that these columns are TINYINT, so weighted values must fall between 0 and 255.
NOTE: When you insert a row for a table, the settings in that row override all of the default index maintenance settings for that table. So, inserting a row for [YourDatabase].dbo.[Best] means that ONLY those specified index settings will be used for that table; no settings defined in Minion.IndexSettingsDB will apply to those specific tables.
NOTE: Any non-specified tables will have a ReindexGroupOrder of 0, and a ReindexOrder of 0, by default. (Order settings at the database level have no effect on table-level ordering.)', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (69, N'Discussion', 69, 2, N'Discussion', N'Generate Reindex Statement Only', N'Sometimes it is useful to generate index maintenance statements and run them by hand, individually or in small groups. To generate reindex statements without running the statements, run the procedure Minion.IndexMaintMaster with the parameter @StmtOnly set to 1. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (69, N'Example', 69, 10, N'Example', N'Example', N'The following code will generate index statements for all tables in the [YourDatabase] database with the ONLINEopt set to “ONLINE” (that is, all tables that are configured to be maintained in online operations only). 
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''ONLINE'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 0,
	@StmtOnly = 1,
	@Include = ''YourDatabase'', 
	@Exclude = NULL, 
	@LogProgress = 1;', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (69, N'ObjectName', 69, 1, N'ObjectName', N'ObjectName', N'Generate reindex statements only', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (70, N'Discussion', 70, 2, N'Discussion', N'Reindex only indexes that are marked ONLINE = ON (or, only ONLINE = OFF)', N'You can choose the set of indexes to maintain at a time. One of the filters available is to choose to maintain only the indexes that are set to ONLINE mode. 
Note: The ONLINE=ON option is set in either the Minion.IndexSettingsDB table, or the Minion.IndexSettingsTable table. Alter existing rows, or insert new rows, to set which databases or tables should have the ONLINEopt set to ON.  Any index that is not marked for ONLINE=ON is, by default, an OFFLINE index (whether it is marked for ONLINEopt=OFF or ONLINEopt=NULL).
Note: ONLINE index operations may not be possible for certain editions of SQL Server, and only for indexes that are eligible for ONLINE index operations. If you specify ONLINE when it is not possible, the routine will change it to OFFLINE. (For more information on editions that support Online Reindexing, see the MSDN article “Features Supported by the Editions of SQL Server 2014” at http://msdn.microsoft.com/en-us/library/cc645993.aspx.)
To reindex only indexes marked for ONLINE=ON, run the procedure Minion.IndexMaintMaster with the parameter @IndexOption set to ‘ONLINE’. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (70, N'Example', 70, 10, N'Example', N'Example', N'For example, to reindex only the ONLINE=ON indexes for ALL databases on the instance, use the following call:
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''ONLINE'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 0,
	@StmtOnly = 0,
	@Include = NULL, 
	@Exclude = NULL, 
	@LogProgress = 1;', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (70, N'Example', 70, 15, N'Example', N'Example', N'To reindex the only the ONLINE=ON indexes for a single database – [YourDatabase] – use the following call:
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''ONLINE'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 0,
	@StmtOnly = 0,
	@Include = ''YourDatabase'', 
	@Exclude = NULL, 
	@LogProgress = 1;', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (71, N'Discussion', 71, 2, N'Discussion', N'Gather index fragmentation statistics on a different schedule from the reindex routine', N'Maintenance windows are never the wide open space we’d like them to be. So, we made sure you have the option to maximize it: you can schedule the gathering of fragmentation stats at a different time than your reindexing itself.  This way, you can use your entire maintenance window for processing indexes instead of finding out the fragmentation levels, which can take a very long time.
Let’s take the example of ReallyBigDB:
1.	Exclude ReallyBigDB from the job dba_MinionReindexDBs-All-All (using @Exclude=’ReallyBigDB’).
2.	Create the job MinionReindexDBs-ReallyBigDB-FragStats, to run sometime before the reindex job. For the job step, run Minion.IndexMaintMaster with @Include=’ReallyBigDB’,  @PrepOnly=1, @RunPrepped=0, and other options as appropriate.
3.	Create the job MinionReindexDBs-ReallyBigDB-All. For the job step, run Minion.IndexMaintMaster with @Include=’ReallyBigDB’,  @PrepOnly=0, @RunPrepped=1  (which tells the SP to use the stats stored by the previous @PrepOnly=1 run), and other options as appropriate.
Note: There can only be one prep per database at a time.  When you run @PrepOnly  = 1, it enters the data into the table Minion.IndexTableFrag, and deletes any previous preparation runs for the database in question.  So, while you can have as many databases as you like prepped in this table, each database can only have a single prep run.  Even if the previous ones weren’t deleted, the reindex SP only looks at the last one.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (71, N'Example', 71, 10, N'Example', N'Example', N'The following code will gather the fragmentation stats for ReallyBigDB:
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''All'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 1,
	@StmtOnly = 0,
	@Include = ''ReallyBigDB'', 
	@Exclude = NULL, 
	@LogProgress = 1;

The following execution will reindex the [ReallyBigDB] database, using the fragmentation stats stored by the previous @PrepOnly=1 run (instead of gathering statistics at the same time):
EXEC [Minion].[IndexMaintMaster] 
	@IndexOption = ''All'',
	@ReorgMode = ''All'',
	@RunPrepped = 0, 
	@PrepOnly = 0,
	@StmtOnly = 1,
	@Include = ''ReallyBigDB'', 
	@Exclude = NULL, 
	@LogProgress = 1;
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (71, N'ObjectName', 71, 1, N'ObjectName', N'ObjectName', N'Gather index fragmentation statistics on a different schedule from the reindex routine', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (72, N'Discussion', 72, 2, N'Discussion', N'Exclude databases from index maintenance', N'You can exclude a database from all index maintenance in any of three ways:
  * Database level settings: In the Minion.IndexSettingsDB table, insert or update the row for that database and set the Exclude column = 1. 
  * Run time parameter: In the appropriate reindex job(s), use the @Exclude parameter of the Minion.IndexMaintMaster procedure. This parameter accepts a column-delimited list of database names, and/or LIKE expressions. (E.g., @Exclude = ‘DB1, DB3, Archive%’.)
  * Regex exclusion (advanced): In the Minion.DBMaintRegexLookup table, insert a row with Action=’Exclude’ and the appropriate regular expression to encompass the proper set of database names.
Database level settings: To exclude [YourDatabase] from the Minion.IndexSettingsDB table, update the existing row, or insert a row:
INSERT INTO [Minion].[IndexSettingsDB]
           ( DBName
           , Exclude
           )
     VALUES
           (''YourDatabase''	-- DBName
           , 1		-- Exclude
           );
Run time parameter: To exclude [YourDatabase] from just one job running Minion.IndexMaintMaster, set the @Exclude parameter = ‘YourDatabase’.  
If you wanted to exclude all databases that begin with the string “Archive”, set @Exclude to “Archive%”.
Regex exclusion: This advanced option is controlled by regular expressions in a table, to exclude databases. This is most commonly used in rolling database scenarios, where you have archive or test databases with rolling names. 
NOTE: The use of the regular expressions exclude feature is not supported in SQL Server 2005.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (72, N'Example', 72, 10, N'Example', N'Example', N'For example, to exclude all databases beginning with the word “Archive”, and ending in a number (e.g. Archive2, Archive3, Archive201410), insert the following row:
INSERT	INTO [Minion].[DBMaintRegexLookup]
	 ( [Action]
	  , MaintType
	  , Regex )
VALUES	
( ''EXCLUDE'' 	-- Action. EXCLUDE or INCLUDE
	   , ''ALL''		-- MaintType. ALL or REINDEX
	   , ''^Archive\d'' );	-- Regex expression', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (72, N'ObjectName', 72, 1, N'ObjectName', N'ObjectName', N'Exclude databases from index maintenance', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (73, N'Discussion', 73, 2, N'Discussion', N'Exclude a table from index maintenance', N'To exclude a single table from all index maintenance, insert a row to the Minion.IndexSettingsTable table and set the Exclude column = 1.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (73, N'Example', 73, 10, N'Example', N'Example', N'INSERT	INTO [Minion].[IndexSettingsTable]
		( DBName ,
		  SchemaName ,
		  TableName ,
		  Exclude           
		)
     VALUES
	( ''YourDatabase'' -- DBName
	  , ''dbo''		-- SchemaName
	  , ''BigTable''	-- TableName
	  , 1		-- Exclude
	);', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (73, N'ObjectName', 73, 1, N'ObjectName', N'ObjectName', N'Exclude a table from index maintenance', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (75, N'Discussion', 75, 2, N'Discussion', N'Reindex databases on different schedules', N'Create a new job for each different schedule you require for index maintenance. Let us take a simple example: 
       * Perform index rebuilds on [YourDatabase] Friday night at 11pm
       * Perform index rebuilds on all other databases on Saturday night at 10pm
       * Perform index reorganization on all databases Sunday through Thursdays at 10pm.
To achieve this using the default installed Minion Reindex jobs:
1.	Connect to “YourServer” and expand the SQL Agent node. You’ll see two new jobs: 
       * dba_MinionReindexDBs-All-All – Runs once weekly – Fridays at 3:00 AM - to thoroughly defragment indexes (rebuild).
       * dba_MinionReindexDBs-All-REORG – Runs Daily – 3:00 AM except for Friday – to complete lightweight defragmenting (reorganize).
2.	Edit the “dba_MinionReindexDBs-All-All” job:
     a.	Edit the “Reindex” step: add ‘YourDatabase’ to the @Exclude parameter.
     b.	Edit the schedule to run Friday night at 11pm. 
3.	Create a new job “MinionReindexDBs-YourDatabase-All”. 
     a.	Create a “Reindex” step similar to that in the “dba_MinionReindexDBs-All-All” job. Set @Include to ‘YourDatabase’, and set @Exclude to NULL.
     b.	Schedule it to run Saturday night at 10pm. 
4.	Edit the schedules for the job “dba_MinionReindexDBs-All-REORG” to run Sunday through Thursday at 10pm. 
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (75, N'ObjectName', 75, 1, N'ObjectName', N'ObjectName', N'Reindex databases on different schedules', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (76, N'ObjectName', 76, 1, N'ObjectName', N'ObjectName', N'Overview of Procedures', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (76, N'Overview', 76, 2, N'Overview', N'Overview', N'Two separate procedures execute index maintenance operations for Minion Reindex: one procedure runs per database, and the other is a “Master” procedure that performs run time logic and calls the DB procedure as appropriate.
In addition, Minion Reindex comes with a Help procedure to provide information about the system itself.
Index maintenance procedures:
Minion.IndexMaintMaster – This procedure makes all the decisions on which databases to reindex, and what order they should be in.  
Minion.IndexMaintDB – This procedure is called by Minion.IndexMaintMaster to perform index maintenance for a single database. 
Minion.HELP – Display help on Minion Reindex objects and concepts.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (77, N'ObjectName', 77, 1, N'ObjectName', N'ObjectName', N'Overview of Jobs', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (77, N'Overview', 77, 2, N'Overview', N'Overview', N'When you install Minion Reindex, it creates and schedules a daily reorg job, and a weekly rebuild job:
dba_MinionReindexDBs-All-REORG – Runs Daily – 3:00 AM except for Friday – to complete lightweight defragmenting (reorganize).
dba_MinionReindexDBs-All-All – Runs once weekly – Fridays at 3:00 AM - to thoroughly defragment indexes (rebuild).
For information on changing schedules, see the Quick Start topic “Change Schedules”.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (125, N'Revisions', 78, 2, N'Revisions', N'Revisions', N'Version     Release Date     Changes
1.0         October 2014     * Initial release.
1.1         January 2015     * Minion Reindex now handles nonstandard naming (e.g., object names with spaces or special characters.)
                             * Added support for Availability Group replicas.
1.2         September 2015   Issues resolved:
                             * Fix: MR failed when running on BIN collation.
                             * Fix: Help didn’t install if Minion Backup was installed.
                             * Fix: MR didn’t handle XML and reorganize properly.
                             * Fix: ONLINE/OFFLINE modes were not being handled properly.
                             * Fix: XML indexes were put into ONLINE mode instead of OFFLINE mode.
                             * Fix: Situation where indexes could be processed more than once.
                             * Update: Increased Status column in log tables to varchar(max).
                             * Fix: Status variable in stored procedures had different sizes.
                             * Fix: Wrong syntax created for Wait_at_low_priority option.
                             * Fix: Reports that offline indexes were failing when it’s set to online instead of doing it offline.
New features:
                             * Error trapping and logging is improved.  MR is able to capture many more error situations now, and they all appear in the log table.
                             * Statement Prefix – All of the Settings tables now have a StmtPrefix column.  See document for details. Note: To ensure that your statements run properly, you must end the code in this column with a semicolon.
                             * Statement Suffix – All of the Settings tables now have a StmtSuffix column.  See document for details. Note: To ensure that your statements run properly, you must end the code in this column with a semicolon.', NULL, NULL, NULL, NULL, NULL);
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (125, N'ObjectName', 78, 1, N'ObjectName', N'ObjectName', N'Revisions', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Discussion', 73, 2, N'Discussion', N'Run code before or after index maintenance', N'You can schedule code to run before or after index maintenance operations. There are several options available: 
  * Run code before or after a single database
  * Run code before or after each and every table in a database
  * Run code before or after a single table
  * Run code before or after each of a few tables (code executing before or after each table)
  * Run code before or after all but a few tables (code executing before or after each table)
  * Run code before or after reindex statements (within the same batch)
NOTE: Unless otherwise specified, pre and post code will run in the context of the Minion Reindex’s database (wherever the Minion Reindex objects are stored), because it was a design decision not to limit the code that can be run to a specific database. Therefore, always use “USE” statements – or, for stored procedures, three-part naming convention – for pre and postcode.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 10, N'Example', N'Example', N'To run code before or after a single database, insert a row for the database into Minion.IndexSettingsDB. Populate the column DBPreCode to run code before the index operations for that database; populate the column DBPostCode to run code before the index operations after that database. For example: 
INSERT INTO [Minion].[IndexSettingsDB]
           ( DBName
           , Exclude
           , ReorgThreshold
           , RebuildThreshold
           , FILLFACTORopt
           , PadIndex 
           , DBPreCode
           , DBPostCode)
     VALUES
           (''YourDatabase''	-- DBName
           , 0		-- Exclude
           , 15		-- ReorgThreshold
           , 25		-- RebuildThreshold
           , 90		-- FILLFACTORopt
           , ''ON''		-- DBPreCode
           , ''EXEC YourDatabase.dbo.SomeSP;'' -- DBPreCode
           , ''EXEC YourDatabase.dbo.OtherSP;'' -- DBPostCode
           );', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 15, N'Example', N'Example', N'To run code before or after each and every table in a database, insert a row for the database into Minion.IndexSettingsDB. Populate the column TablePreCode to run code before the index operations for each individual table in the database; populate the column TablePostCode to run code after the index operations for each individual table in the database. For example: 
INSERT INTO [Minion].[IndexSettingsDB]
           ( DBName
           , Exclude
           , ReorgThreshold
           , RebuildThreshold
           , FILLFACTORopt
           , PadIndex 
           , TablePreCode
           , TablePostCode)
     VALUES
           (''YourDatabase''	-- DBName
           , 0		-- Exclude
           , 15		-- ReorgThreshold
           , 25		-- RebuildThreshold
           , 90		-- FILLFACTORopt
           , ''ON''		-- DBPreCode
           , ''EXEC YourDatabase.dbo.SomeSP;'' -- TablePreCode
           , ''EXEC YourDatabase.dbo.OtherSP;'' -- TablePostCode
           );', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 20, N'Example', N'Example', N'To run code before or after a single table (instead of each table), insert a row for the table into Minion.IndexSettingsTable. Populate the column TablePreCode to run code before the index operations for that database; populate the column TablePostCode to run code before the index operations after that database. 
Note: An entry in Minion.IndexSettingsTable overrides ALL the index maintenance settings for that table; defaults set in Minion.IndexSettingsDB will be ignored for this table.
For example:
INSERT	INTO [Minion].[IndexSettingsTable]
		( [DBName] ,
		  [SchemaName] ,
		  [TableName] ,
		  [ReorgThreshold] ,
		  [RebuildThreshold] ,
		  [FILLFACTORopt] ,
		  [PadIndex] ,
		  [GetRowCT] ,
		  [GetPostFragLevel] ,
		  [UpdateStatsOnDefrag] ,
		  [LogIndexPhysicalStats] ,
		  [IndexScanMode] ,
		  [LogProgress] ,
		  [LogRetDays] ,
		  [IncludeUsageDetails] ,
		  [TablePreCode] ,
		  [TablePostCode] 
		)
VALUES	( ''YourDatabase'' ,	-- DBName
		  ''dbo'' ,		-- SchemaName
		  ''YourTable'' ,	-- TableName
		  10 ,		-- ReorgThreshold
		  20 ,		-- RebuildThreshold
		  80 ,		-- FILLFACTORopt
		  ''ON'' ,		-- PadIndex
		  1 ,		-- GetRowCT
		  1 ,		-- GetPostFragLevel
		  1 ,		-- UpdateStatsOnDefrag
		  0 ,		-- LogIndexPhysicalStats
		  ''Limited'' ,	-- IndexScanMode
		  1 ,		-- LogProgress
		  60 ,		-- LogRetDays
		  1 ,		-- IncludeUsageDetails
		  ''EXEC YourDatabase.dbo.SomeSP;'' ,	-- TablePreCode
		  ''EXEC YourDatabase.dbo.OtherSP;''	-- TablePostCode
 		);', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 25, N'Example', N'Example', N'To run code before or after each of a few tables, insert one row for each of the tables into Minion.IndexSettingsTable, populating the TablePreCode column and/or TablePostCode column as appropriate.', NULL, NULL, NULL, NULL, NULL)
GO

INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 30, N'Example', N'Example', N'To run code before or after all but a few tables, insert one row for the database into Minion.IndexSettingsDB, populating the TablePreCode column and/or the TablePostCode column as appropriate. This will set up the execution code for all tables. Then, to prevent that code from running on a handful of tables, insert a row for each of those tables to Minion.IndexSettingsTable, and keep the TablePreCode and TablePostCode columns set to NULL. 
For example, if we want to run the stored procedure dbo.SomeSP before each table in [YourDatabase] except tables T1, T2, and T3, we would: 
1.	Insert a row to Minion.IndexSettingsDB for [YourDatabase], setting PreCode to ‘EXEC dbo.SomeSP;’
2.	Insert a row to Minion.IndexSettingsTable for [YourDatabase].dbo.T1, establishing all appropriate settings, and setting PreCode to NULL. 
3.	Insert a row to Minion.IndexSettingsTable for [YourDatabase].dbo.T2, establishing all appropriate settings, and setting PreCode to NULL. 
4.	Insert a row to Minion.IndexSettingsTable for [YourDatabase].dbo.T3, establishing all appropriate settings, and setting PreCode to NULL. 
NOTE: We strongly recommend that you encapsulate any pre- or post-code into a stored procedure, unless the code is extremely simple. You can’t pass pre- or post-code parameters into the indexing routine, so pre- and post-code must be self-contained. ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 35, N'Example', N'Example', N'A real world TablePreCode example:  You have a database supplied by a vendor.  This database has a table with a non-clustered index with ALLOW_PAGE_LOCKS = OFF set.  This option causes the reorganize operation on that index to fail.  To resolve this, enter a row for that table into the Minion.IndexSettingsTable table, and include the following TablePreCode and TablePostCode options:
INSERT	Minion.IndexSettingsTable
		( DBName 
		  , SchemaName 
		  , TableName 
		  , Exclude 
		  , ReindexGroupOrder 
		  , ReindexOrder 
		  , ReorgThreshold 
		  , RebuildThreshold 
		  , AllowPageLocks 
		  , TablePreCode 
		  , TablePostCode
		)
SELECT	''Demo'' 		--DBName
		, ''dbo'' 	--SchemaName
		, ''fragment''  --TableName
		, 0 		--Exclude
		, 0 		--ReindexGroupOrder
		, 0 		--ReindexOrder
		, 10 		--ReorgThreshold,
		, 20 		--RebuildThreshold
		, ''ON'' 
		, ''USE [Demo]; ALTER index ix_fragment2 ON dbo.fragment SET (ALLOW_PAGE_LOCKS = ON);''   -- TablePreCode
		, ''USE [Demo]; ALTER index ix_fragment2 ON dbo.fragment SET (ALLOW_PAGE_LOCKS = OFF);'' --TablePostCode
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'Example', 73, 40, N'Example', N'Example', N'To run code before or after reindex statements and within the same batch, you can use the StmtPrefix and/or StmtSuffix columns in Minion.IndexSettingsDB, Minion.IndexSettingsTable, or both.  
It is important to understand that this column allows you to prefix every reindex statement for a table, or for a database, with a statement of your own.  This is different from the table precode and postcode, because it is run in the same batch. Whereas, precode and postcode are run as completely separate statements, in different contexts.  
A good example use case for this is the need to ensure that your reindex statement is chosen as the deadlock victim (should a deadlock occur) for DatabaseA.  In this case, you would set StmtPrefix to “SET DEADLOCK_PRIORITY LOW;” for DatabaseA in the Minion.IndexSettingsDB table.  Other uses include setting a lock timeout, or adding a time delay to every reindex statement.  
The StmtPrefix you choose will be shown as part of the Cmd column in the Minion.IndexMaintLogDetails table. IMPORTANT: To ensure that your statements run properly, you must end the code in this column with a semicolon.', NULL, NULL, NULL, NULL, NULL);
GO



INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (82, N'ObjectName', 73, 1, N'ObjectName', N'ObjectName', N'Run code before or after index maintenance', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (83, N'Discussion', 73, 2, N'Discussion', N'Configure how long the reindex logs are kept', N'Minion Reindex stores the “log retention in days” setting (LogRetDays) in the Minion.IndexSettingsDB table and the Minion.IndexSettingsTable table. You can therefore set the log retention for individual tables, individual databases and/or the system as a whole.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (83, N'Example', 73, 10, N'Example', N'Example', N'To change the default log retention for the system, run an update statement on the MinionDefault row in Minion.IndexSettingsDB. For example:
UPDATE [Minion].[IndexSettingsDB]
SET  [LogRetDays] = 60
WHERE [DBName] = ''MinionDefault'';', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (83, N'Example', 73, 15, N'Example', N'Example', N'To change the log retention for a specific database, run an update statement on that database’s row in Minion.IndexSettingsDB. For example:
UPDATE [Minion].[IndexSettingsDB]
SET  [LogRetDays] = 90
WHERE [DBName] = ''YourDatabase'';', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (83, N'ObjectName', 73, 1, N'ObjectName', N'ObjectName', N'Configure how long the reindex logs are kept', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (112, N'ObjectName', 80, 1, N'ObjectName', N'ObjectName', N'Overview of Tables', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (112, N'Overview', 80, 2, N'Overview', N'Overview', N'Settings (like rebuild threshold) are stored in two separate tables, one for database-level defaults, and another for table-level defaults. Index fragmentation statistics are stored long term in one table, and in the short term (to aid the index maintenance operations) in another table. Index maintenance activities are logged at a high (“master”) level, and also at a per-operation level. So, for example, you can see how long the entire maintenance operation took, or how long an individual index rebuild lasted.  
Reindex settings:
  * Minion.IndexSettingsDB – This table holds index maintenance default settings at the database level. You may insert rows to define index maintenance settings per database, or you can rely on the system-wide default settings (defined in the “MinionDefault” row), or a combination of both.
  * Minion.IndexSettingsTable - This table holds index maintenance default settings at the table level. You may insert rows to override the default index maintenance settings for individual tables. Any table that does not have a value in this table gets its settings from the appropriate entry in the Minion.IndexSettingsDB table.
  * Minion.DBMaintRegexLookup – Allows you to exclude databases from index maintenance (or all maintenance), based off of regular expressions.
Index fragmentation stats:
  * Minion.IndexPhysicalStats – This table holds index size and fragmentation information when the @currLogIndexPhysicalStats parameter is enabled.  You can use this data after an index maintenance to investigate the raw fragmentation data, to estimate the next time a table will need to be reindexed, and more. Currently, this table must be manually deleted; the large amount of data here means we don’t recommend leaving this setting on for long.  Only turn it on when you need to diagnose something. 
  * Minion.IndexTableFrag - Holds index fragmentation information during the index maintenance process.  If you run the index maintenance process with @PrepOnly = 1, this table stores that data; a subsequent run of index maintenance with @RunPrepped = 1 will make use of this prepared data, instead of gathering statistics at the same time. 
Logs: 
  * Minion.IndexMaintLog – Holds a database-level summary of the whole maintenance operation. Each row contains the database name, operation status, the start and end time of the index maintenance event, and much more. This is updated as each operation occurs, so that you have Live Insight into active index operations.
  * Minion.IndexMaintLogDetails - Keeps a record of individual index maintenance activities. It contains one time-stamped row for each individual index operation (e.g., a single index rebuild). This is updated as each operation occurs, so that you have Live Insight into active index operations.
', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (113, N'Discussion', NULL, 1, N'Discussion', N'Troubleshoot: ONLINE was set, but all or some of the indexes are being done OFFLINE.', N'Minion Reindexing strives to run no matter what.  If you’ve got the ONLINEopt column set and some indexes are being done OFFLINE, then you could be on an edition of SQL Server that doesn’t support online reindexing.  In this case, Minion Reindexing will change it to OFFLINE mode for you.  
You could also have a legacy data type in the index itself, and for versions of SQL Server under 2014, this automatically means OFFLINE mode reindexing.  These legacy types are varchar(max), nvarchar(max), text, image, and also includes, xml, and the spatial data types.  If it’s a clustered index in question, it’ll be done offline if the table itself has a legacy data type.  This is a SQL Server limitation.

', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (114, N'Discussion', NULL, 1, N'Discussion', N'Troubleshoot: Why is a certain database not being processed?', N'There are a few reasons why a database could be skipped.  
1.	It could be excluded in the @Excluded parameter of the SP.
2.	It could be excluded in the Exclude column in the Minion.IndexSettingsDB table.
3.	It could be excluded in the Minion. DBMaintRegexLookup table.
4.	It could be OFFLINE or some other troubled state.
5.	There could be no indexes in the database or none of them have exceeded the threshold.
6.	There could be a missing entry for ‘MinionDefault’ in the Minion.IndexSettingsDB table.

', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (115, N'Discussion', NULL, 1, N'Discussion', N'Troubleshoot: Nothing happens when I run a specific database.', N'There are a few reasons you could see this behavior.
1.	There could be no indexes in the database or none of them have exceeded the threshold.
2.	The settings in the tables could be incorrect or missing.  While there are few columns in the settings tables that are mandatory, there are some.  ReorgThreshold, RebuildThreshold, Exclude, ReindexGroupOrder, ReindexOrder are the only columns I can think of that need to be populated.
3.	The SP was set with @RunPrepped = 1 and there are no rows in the Minion.IndexTableFrag table for that database.  This is because the PrepOnly was never run or failed.
4.	You’re running it with @StmtOnly  = 1.

', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (116, N'Discussion', NULL, 1, N'Discussion', N'Troubleshoot: Some tables aren’t reindexing at the proper threshold.', N'The only thing that might cause this would be a table override.  Check that the Minion.IndexSettingsTable table doesn’t have an entry for the problem tables.

', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (117, N'Discussion', NULL, 1, N'Discussion', N'Troubleshoot: Not all indexes in the Minion.IndexMaintLogDetails table are marked "Complete".', N'This is often do to an unhandled exception or caused by someone manually stopping the routine before it is finished.  Unhandled exceptions aren’t very common but there are still some errors that can halt the database run.
', NULL, NULL, NULL, NULL, NULL)
GO

INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (126, N'ObjectName', 81, 1, N'ObjectName', N'ObjectName', N'FAQ', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (78, N'About', 80, 2, N'About', N'About', N'Minion by MidnightDBA is a creation of Jen and Sean McCown, owners of MidnightSQL Consulting, LLC.
In our “MidnightSQL” consulting work, we perform a full range of databases services that revolve around SQL Server. We’ve got over 30 years of experience between us and we''ve seen and done almost everything there is to do.  We have two decades of experience managing large enterprises, and we bring that straight to you. Take a look at www.MidnightSQL.com for more information on what we can do for you and your databases.
Under the “MidnightDBA” banner, we make free technology tutorials, blogs, and a live weekly webshow (DBAs@Midnight). We cover various aspects of SQL Server and PowerShell, technology news, and whatever else strikes our fancy. You’ll also find recordings of our classes – we speak at user groups and conferences internationally – and of our webshow. Check all of that out at www.MidnightDBA.com 
We are both “MidnightDBA” and “MidnightSQL”…the terms are nearly interchangeable, but we tend to keep all of our free stuff under the MidnightDBA banner, and paid services under MidnightSQL Consulting, LLC. Feel free to call us the MidnightDBAs, those MidnightSQL guys, or just “Sean” and “Jen”. We''re all good.', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (78, N'ObjectName', 80, 1, N'ObjectName', N'ObjectName', N'About Us', NULL, NULL, NULL, NULL, NULL)
GO
INSERT #HelpObjectDetail ([ObjectID], [DetailName], [GlobalPosition], [Position], [DetailType], [DetailHeader], [DetailText], [Datatype], [max_length], [precision], [scale], [is_nullable]) VALUES (126, N'FAQ', 81, 2, N'FAQ', N'FAQ', N'How do I install Minion Reindex?
     For information on this, see the “Quick Start” on page 1, or use the Minion Reindex help function: EXEC Minion.Help ''Reindex'', ''Quick Start'';

Do I really need SQL Server 2005 or above / xp_cmdshell / PowerShell 2.0?
     Yep. Minion Reindex does an awful lot for you. To simplify a great many things, we’ve decided not to support SQL Server 2000 and previous versions (er, sorry about that), to require xp_cmdshell, and to make use of PowerShell 2.0 or above.  There’s no such thing as a free lunch, they say, but this particular lunch is very very cheap.

Why is Minion Reindex better than [some other index maintenance solution]?
     This is a very big question, and I’m tempted to just point to the entire body of documentation. But briefly: (1) Minion Reindex provides vastly improved logging and insight, including live insight into the active process. (2) It provides ease of management, especially through reducing the number of jobs (or job steps) required. (3) Minion Reindex gives you fine-grained control, in the form of database- and table-level configurations and exclusions. (4) And, Minion Reindex is massively scalable, where other solutions require a “one by one by one” approach to deployment and configuration.

Does Minion Reindex support Availability Groups?
     Yes, as of version 1.1.

Does Minion Reindex support clusters?
     Clusters have no impact on Minion Reindex. So, yes.

I have an old database that has objects named with keywords and spaces. Does Minion handle that?
     Yes, as of version 1.1.

Have a questions? Get in contact at http://www.midnightsql.com/contact-me/ ', NULL, NULL, NULL, NULL, NULL)
GO


--&--------------------------------------------
-- 4. Insert all HelpObjects

INSERT  INTO Minion.HELPObjects
        ( [Module] ,
          [ObjectName] ,
          [ObjectType] ,
          [Synopsis] ,
          [Descript] ,
          [MinionVersion] ,
          [GlobalPosition]
        )
        SELECT  [Module] ,
                [ObjectName] ,
                [ObjectType] ,
                [Synopsis] ,
                [Descript] ,
                [MinionVersion] ,
                [GlobalPosition]
        FROM    #HelpObjects;


--&--------------------------------------------
-- 5. Update #HelpObjects and #HelpObjectDetails with the new object IDs from Minion.HelpObjects
UPDATE  HO
SET     NewObjectID = MHO.ID
FROM    #HelpObjects AS HO
        JOIN Minion.HELPObjects AS MHO ON ISNULL(HO.[Module], '') = ISNULL(MHO.[Module],'')
                AND ISNULL(HO.[ObjectName], '') = ISNULL(MHO.[ObjectName],'')
                AND ISNULL(HO.[ObjectType], '') = ISNULL(MHO.[ObjectType],'')
                AND ISNULL(HO.[Synopsis], '') = ISNULL(MHO.[Synopsis],'')
                AND ISNULL(HO.[Descript], '') = ISNULL(MHO.[Descript],'')
                AND ISNULL(HO.[MinionVersion], 1) = ISNULL(MHO.[MinionVersion],1)
                AND ISNULL(HO.[GlobalPosition], 1) = ISNULL(MHO.[GlobalPosition],1);

UPDATE  HDO
SET     HDO.ObjectID = HO.NewObjectID ,
        updated = 1
FROM    #HelpObjectDetail HDO
        JOIN #HelpObjects HO ON HDO.ObjectID = HO.ID;


--&--------------------------------------------
-- 6. Insert all HelpObjectDetail rows
INSERT  INTO Minion.HELPObjectDetail
        ( [ObjectID] ,
          [DetailName] ,
          [GlobalPosition] ,
          [Position] ,
          [DetailType] ,
          [DetailHeader] ,
          [DetailText] ,
          [DataType] ,
          [max_length] ,
          [precision] ,
          [scale] ,
          [is_nullable]
        )
        SELECT  [ObjectID] ,
                [DetailName] ,
                [GlobalPosition] ,
                [Position] ,
                [DetailType] ,
                [DetailHeader] ,
                [DetailText] ,
                [Datatype] ,
                [max_length] ,
                [precision] ,
                [scale] ,
                [is_nullable]
        FROM    #HelpObjectDetail
        ORDER BY [ObjectID] ,
                [Position];


--&--------------------------------------------
-- 7. Cleanup

DROP TABLE #HelpObjectDetail;
DROP TABLE #HelpObjects;


------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-----------------------------------END Help Data Insert-----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------










-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- MinionDefault Data ----------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------

IF NOT EXISTS (SELECT * FROM Minion.IndexSettingsDB WHERE DBName = 'MinionDefault')
BEGIN
	INSERT [Minion].[IndexSettingsDB] ([DBName], [Exclude], [ReindexGroupOrder], [ReindexOrder], [ReorgThreshold], [RebuildThreshold], [FILLFACTORopt], [PadIndex], [ONLINEopt], [SortInTempDB], [MAXDOPopt], [DataCompression], [GetRowCT], [GetPostFragLevel], [UpdateStatsOnDefrag], [StatScanOption], [IgnoreDupKey], [StatsNoRecompute], [AllowRowLocks], [AllowPageLocks], [WaitAtLowPriority], [MaxDurationInMins], [AbortAfterWait], [PushToMinion], [LogIndexPhysicalStats], [IndexScanMode], [DBPreCode], [DBPostCode], [TablePreCode], [TablePostCode], [LogProgress], [LogRetDays], [LogLoc], [MinionTriggerPath], [RecoveryModel], [IncludeUsageDetails]) 
	VALUES (N'MinionDefault', 0, 0, 0, 10, 20, 90, N'ON', NULL, NULL, NULL, NULL, 1, 1, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 1, 60, N'Local', NULL, NULL, 1)
END




EXEC Minion.HELP 'Reindex'



-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------- JOBS ------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------

USE [msdb]
GO

/****** Object:  Job [dba_MinionReindexDBs-All-All]    Script Date: 10/20/2014 10:36:55 AM ******/
IF NOT EXISTS (select * from msdb..sysjobs where name=N'dba_MinionReindexDBs-All-All')
BEGIN
	BEGIN TRANSACTION
	DECLARE	@ReturnCode INT
	SELECT	@ReturnCode = 0

	DECLARE @dbname sysname;
	SELECT TOP 1
			@dbname = dbname
	FROM	#dbname; 

	/****** Object:  JobCategory [[DBAJobs]]]    Script Date: 10/20/2014 10:36:56 AM ******/
	IF NOT EXISTS ( SELECT	name
					FROM	msdb.dbo.syscategories
					WHERE	name = N'[DBAJobs]'
							AND category_class = 1 ) 
		BEGIN
			EXEC @ReturnCode = msdb.dbo.sp_add_category @class = N'JOB',
				@type = N'LOCAL', @name = N'[DBAJobs]'
			IF ( @@ERROR <> 0
				 OR @ReturnCode <> 0
			   ) 
				GOTO QuitWithRollback

		END

	DECLARE	@jobId BINARY(16)

    DECLARE @Domain sysname
     , @UserAcct sysname
SELECT @Domain = DEFAULT_DOMAIN()
   SET @UserAcct = @Domain + N'\sqlagent_svc'

	EXEC @ReturnCode = msdb.dbo.sp_add_job @job_name = N'dba_MinionReindexDBs-All-All',
		@enabled = 1, @notify_level_eventlog = 0, @notify_level_email = 2,
		@notify_level_netsend = 0, @notify_level_page = 0, @delete_level = 0,
		@description = N'No description available.',
		@category_name = N'[DBAJobs]', @owner_login_name = @UserAcct,
		@notify_email_operator_name=N'DBA Group', @job_id = @jobId OUTPUT
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Primary Check', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=3, 
		@on_success_step_id=0, 
		@on_fail_action=1, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'declare @primary as nvarchar(128);
declare @machine as nvarchar(128)=
     case when @@SERVERNAME like ''%\%''
              then left(@@SERVERNAME,charindex(''\'',@@SERVERNAME,1)-1)
              else @@SERVERNAME end
 
-- if AlwaysOn, then check if we are primary node
if SERVERPROPERTY(''IsHadrEnabled'')= 1
begin
    -- get primary node
          select @primary = hags.primary_replica
            from master.sys.dm_hadr_availability_group_states hags
            join master.sys.availability_groups ag
              on hags.group_id=ag.group_id
 
end
 
if (@primary = @machine) or (@primary is null) -- either AAG and primary node, or not AAG
            begin
                        select 1 -- continue to next step
            end
else
            begin
                        RAISERROR (35251, 10, 1)-- do not continue to next step; does not fail step but provides informational message
                        select 1 from raise_error_dummy_table
            end', 
		@database_name=N'master', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	/****** Object:  Step [Reindex]    Script Date: 10/20/2014 10:36:56 AM ******/
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @jobId,
		@step_name = N'Reindex', @step_id = 2, @cmdexec_success_code = 0,
		@on_success_action = 1, @on_success_step_id = 0, @on_fail_action = 2,
		@on_fail_step_id = 0, @retry_attempts = 0, @retry_interval = 0,
		@os_run_priority = 0, @subsystem = N'TSQL',
		@command = N'[Minion].[IndexMaintMaster] 
	@IndexOption = ''All'', -- Valid options: All, ONLINE, OFFLINE
	@ReorgMode = ''All'', -- Valid options: All, Reorg, Rebuild
	@RunPrepped = 0, -- Valid options: 1, 0. If you''ve collected index frag stats ahead of time by running with @PrepOnly = 1, then you can use this option. 
	@PrepOnly = 0, -- Valid options: 1, 0. Allows you to take frag stats earlier in the day and save them for use at a later time.
	@StmtOnly = 0, -- Print the reindex stmts w/o modifying the SP.  This will NOT run any reindex stmts, only PRINT them.
	@Include = NULL, -- Only do DBs listed here. Commas are used. ex: @Include = ''master, model, msdb''
	@Exclude = NULL, -- Do all DBs except the ones listed here. Commas are used. ex: @Exclude = ''master, model, msdb''
	@LogProgress = 1 -- Allows Live Insight through Log tables.
	', @database_name = @dbname, @flags = 0	
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'Daily 2000', 
		@enabled=1, 
		@freq_type=8, 
		@freq_interval=63, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=1, 
		@active_start_date=20110807, 
		@active_end_date=99991231, 
		@active_start_time=220000, 
		@active_end_time=235959
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId,
		@server_name = N'(local)'
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	COMMIT TRANSACTION
	GOTO EndSave
	QuitWithRollback:
	IF ( @@TRANCOUNT > 0 ) 
		ROLLBACK TRANSACTION
	EndSave:
END

GO

/****** Object:  Job [dba_MinionReindexDBs-All-REORG]    Script Date: 10/20/2014 10:36:56 AM ******/
IF NOT EXISTS (select * from msdb..sysjobs where name=N'dba_MinionReindexDBs-All-REORG')
BEGIN
	BEGIN TRANSACTION
	DECLARE	@ReturnCode INT
	SELECT	@ReturnCode = 0

	DECLARE @dbname sysname;
	SELECT TOP 1
			@dbname = dbname
	FROM	#dbname; 

	/****** Object:  JobCategory [[DBAJobs]]]    Script Date: 10/20/2014 10:36:56 AM ******/
	IF NOT EXISTS ( SELECT	name
					FROM	msdb.dbo.syscategories
					WHERE	name = N'[DBAJobs]'
							AND category_class = 1 ) 
		BEGIN
			EXEC @ReturnCode = msdb.dbo.sp_add_category @class = N'JOB',
				@type = N'LOCAL', @name = N'[DBAJobs]'
			IF ( @@ERROR <> 0
				 OR @ReturnCode <> 0
			   ) 
				GOTO QuitWithRollback

		END

	DECLARE	@jobId BINARY(16)

    DECLARE @Domain sysname
     , @UserAcct sysname
SELECT @Domain = DEFAULT_DOMAIN()
   SET @UserAcct = @Domain + N'\sqlagent_svc'

	EXEC @ReturnCode = msdb.dbo.sp_add_job @job_name = N'dba_MinionReindexDBs-All-REORG',
		@enabled = 1, @notify_level_eventlog = 0, @notify_level_email = 2,
		@notify_level_netsend = 0, @notify_level_page = 0, @delete_level = 0,
		@description = N'No description available.',
		@category_name = N'[DBAJobs]', @owner_login_name = @UserAcct,
		@notify_email_operator_name=N'DBA Group', @job_id = @jobId OUTPUT
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Primary Check', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=3, 
		@on_success_step_id=0, 
		@on_fail_action=1, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0,
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'declare @primary as nvarchar(128);
declare @machine as nvarchar(128)=
     case when @@SERVERNAME like ''%\%''
              then left(@@SERVERNAME,charindex(''\'',@@SERVERNAME,1)-1)
              else @@SERVERNAME end
 
-- if AlwaysOn, then check if we are primary node
if SERVERPROPERTY(''IsHadrEnabled'')= 1
begin
    -- get primary node
          select @primary = hags.primary_replica
            from master.sys.dm_hadr_availability_group_states hags
            join master.sys.availability_groups ag
              on hags.group_id=ag.group_id
 
end
 
if (@primary = @machine) or (@primary is null) -- either AAG and primary node, or not AAG
            begin
                        select 1 -- continue to next step
            end
else
            begin
                        RAISERROR (35251, 10, 1)-- do not continue to next step; does not fail step but provides informational message
                        select 1 from raise_error_dummy_table
            end', 
		@database_name=N'master', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	/****** Object:  Step [Reindex]    Script Date: 10/20/2014 10:36:56 AM ******/
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @jobId,
		@step_name = N'Reindex', @step_id = 2, @cmdexec_success_code = 0,
		@on_success_action = 1, @on_success_step_id = 0, @on_fail_action = 2,
		@on_fail_step_id = 0, @retry_attempts = 0, @retry_interval = 0,
		@os_run_priority = 0, @subsystem = N'TSQL',
		@command = N'[Minion].[IndexMaintMaster] 
	@IndexOption = ''All'', -- Valid options: All, ONLINE, OFFLINE
	@ReorgMode = ''REORG'', -- Valid options: All, Reorg, Rebuild
	@RunPrepped = 0, -- Valid options: 1, 0. If you''ve collected index frag stats ahead of time by running with @PrepOnly = 1, then you can use this option. 
	@PrepOnly = 0, -- Valid options: 1, 0. Allows you to take frag stats earlier in the day and save them for use at a later time.
	@StmtOnly = 0, -- Print the reindex stmts w/o modifying the SP.  This will NOT run any reindex stmts, only PRINT them.
	@Include = NULL, -- Only do DBs listed here. Commas are used. ex: @Include = ''master, model, msdb''
	@Exclude = NULL, -- Do all DBs except the ones listed here. Commas are used. ex: @Exclude = ''master, model, msdb''
	@LogProgress = 1 -- Allows Live Insight through Log tables.
	', @database_name = @dbname, @flags = 0		
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id = @jobId,
		@name = N'Daily 0200', @enabled = 1, @freq_type = 8, @freq_interval = 63,
		@freq_subday_type = 1, @freq_subday_interval = 0,
		@freq_relative_interval = 0, @freq_recurrence_factor = 1,
		@active_start_date = 20141020, @active_end_date = 99991231,
		@active_start_time = 20000, @active_end_time = 235959
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId,
		@server_name = N'(local)'
	IF ( @@ERROR <> 0
		 OR @ReturnCode <> 0
	   ) 
		GOTO QuitWithRollback
	COMMIT TRANSACTION
	GOTO EndSave
	QuitWithRollback:
	IF ( @@TRANCOUNT > 0 ) 
		ROLLBACK TRANSACTION
	EndSave:
END
GO

	DECLARE @dbname sysname;
	SELECT TOP 1
			@dbname = dbname
	FROM	#dbname; 

EXEC ( 'UPDATE ' + @dbname + '.Minion.IndexSettingsDB
           SET ONLINEopt = ''ON''
         WHERE DBName = ''MinionDefault''' );

DROP TABLE #dbname; 